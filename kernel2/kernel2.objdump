
kernel2:     file format elf32-i386


Disassembly of section .text:

00100000 <MultiBootHeader>:
  100000:	02 b0 ad 1b 06 00    	add    0x61bad(%eax),%dh
  100006:	00 00                	add    %al,(%eax)
  100008:	f8                   	clc    
  100009:	4f                   	dec    %edi
  10000a:	52                   	push   %edx
  10000b:	e4 00                	in     $0x0,%al
	...
  100021:	00 00                	add    %al,(%eax)
  100023:	00 50 00             	add    %dl,0x0(%eax)
  100026:	00 00                	add    %al,(%eax)
  100028:	19 00                	sbb    %eax,(%eax)
  10002a:	00 00                	add    %al,(%eax)
  10002c:	00 00                	add    %al,(%eax)
	...

00100030 <_start>:
  100030:	bc 54 f9 10 00       	mov    $0x10f954,%esp
  100035:	50                   	push   %eax
  100036:	53                   	push   %ebx
  100037:	e8 78 25 00 00       	call   1025b4 <main>
  10003c:	81 c4 08 00 00 00    	add    $0x8,%esp
  100042:	fa                   	cli    
  100043:	f4                   	hlt    

00100044 <init_stacksize>:
  100044:	00 10 00 00                                         ....

00100048 <biosint_init>:
#include <procm.h>

#define IVT_GET_IP(i) (((uint16_t*)IVT_ADDRESS)[i*2])
#define IVT_GET_CS(i) (((uint16_t*)IVT_ADDRESS)[i*2+1])

int biosint_init() {
  100048:	55                   	push   %ebp
  100049:	89 e5                	mov    %esp,%ebp
  10004b:	83 ec 18             	sub    $0x18,%esp
  if (syscall_create(SYSCALL_MISC_BIOSINT,biosint_call,10)==-1) return -1;
  10004e:	c7 44 24 08 0a 00 00 	movl   $0xa,0x8(%esp)
  100055:	00 
  100056:	c7 44 24 04 84 00 10 	movl   $0x100084,0x4(%esp)
  10005d:	00 
  10005e:	c7 04 24 4e 00 00 00 	movl   $0x4e,(%esp)
  100065:	e8 d0 9d 00 00       	call   109e3a <syscall_create>
  10006a:	83 f8 ff             	cmp    $0xffffffff,%eax
  10006d:	75 09                	jne    100078 <biosint_init+0x30>
  10006f:	c7 45 fc ff ff ff ff 	movl   $0xffffffff,-0x4(%ebp)
  100076:	eb 07                	jmp    10007f <biosint_init+0x37>
  return 0;
  100078:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
  10007f:	8b 45 fc             	mov    -0x4(%ebp),%eax
}
  100082:	c9                   	leave  
  100083:	c3                   	ret    

00100084 <biosint_call>:

uint16_t biosint_call(unsigned int *meminfo,size_t meminfo_count,uint16_t ax,uint16_t bx,uint16_t cx,uint16_t dx,uint16_t si,uint16_t di,uint16_t ds,uint16_t es) {
  100084:	55                   	push   %ebp
  100085:	89 e5                	mov    %esp,%ebp
  100087:	57                   	push   %edi
  100088:	56                   	push   %esi
  100089:	53                   	push   %ebx
  10008a:	83 ec 4c             	sub    $0x4c,%esp
  10008d:	8b 45 10             	mov    0x10(%ebp),%eax
  100090:	89 45 b8             	mov    %eax,-0x48(%ebp)
  100093:	8b 55 14             	mov    0x14(%ebp),%edx
  100096:	8b 4d 18             	mov    0x18(%ebp),%ecx
  100099:	8b 5d 1c             	mov    0x1c(%ebp),%ebx
  10009c:	8b 75 20             	mov    0x20(%ebp),%esi
  10009f:	8b 7d 24             	mov    0x24(%ebp),%edi
  1000a2:	8b 45 28             	mov    0x28(%ebp),%eax
  1000a5:	89 45 c0             	mov    %eax,-0x40(%ebp)
  1000a8:	8b 45 2c             	mov    0x2c(%ebp),%eax
  1000ab:	89 45 bc             	mov    %eax,-0x44(%ebp)
  1000ae:	0f b7 45 b8          	movzwl -0x48(%ebp),%eax
  1000b2:	66 89 45 e0          	mov    %ax,-0x20(%ebp)
  1000b6:	66 89 55 dc          	mov    %dx,-0x24(%ebp)
  1000ba:	66 89 4d d8          	mov    %cx,-0x28(%ebp)
  1000be:	66 89 5d d4          	mov    %bx,-0x2c(%ebp)
  1000c2:	66 89 75 d0          	mov    %si,-0x30(%ebp)
  1000c6:	66 89 7d cc          	mov    %di,-0x34(%ebp)
  1000ca:	0f b7 45 c0          	movzwl -0x40(%ebp),%eax
  1000ce:	66 89 45 c8          	mov    %ax,-0x38(%ebp)
  1000d2:	0f b7 45 bc          	movzwl -0x44(%ebp),%eax
  1000d6:	66 89 45 c4          	mov    %ax,-0x3c(%ebp)
  size_t i;
  proc_t *proc = vm86_proc_create("bios_int",proc_current->uid,proc_current->gid,proc_current);
  1000da:	8b 15 a0 e1 10 00    	mov    0x10e1a0,%edx
  1000e0:	a1 a0 e1 10 00       	mov    0x10e1a0,%eax
  1000e5:	8b 48 10             	mov    0x10(%eax),%ecx
  1000e8:	a1 a0 e1 10 00       	mov    0x10e1a0,%eax
  1000ed:	8b 40 04             	mov    0x4(%eax),%eax
  1000f0:	89 54 24 0c          	mov    %edx,0xc(%esp)
  1000f4:	89 4c 24 08          	mov    %ecx,0x8(%esp)
  1000f8:	89 44 24 04          	mov    %eax,0x4(%esp)
  1000fc:	c7 04 24 00 d0 10 00 	movl   $0x10d000,(%esp)
  100103:	e8 dc a2 00 00       	call   10a3e4 <vm86_proc_create>
  100108:	89 45 f0             	mov    %eax,-0x10(%ebp)

  proc->registers.eax = ax;
  10010b:	0f b7 55 e0          	movzwl -0x20(%ebp),%edx
  10010f:	8b 45 f0             	mov    -0x10(%ebp),%eax
  100112:	89 50 2c             	mov    %edx,0x2c(%eax)
  proc->registers.ebx = bx;
  100115:	0f b7 55 dc          	movzwl -0x24(%ebp),%edx
  100119:	8b 45 f0             	mov    -0x10(%ebp),%eax
  10011c:	89 50 30             	mov    %edx,0x30(%eax)
  proc->registers.ecx = cx;
  10011f:	0f b7 55 d8          	movzwl -0x28(%ebp),%edx
  100123:	8b 45 f0             	mov    -0x10(%ebp),%eax
  100126:	89 50 34             	mov    %edx,0x34(%eax)
  proc->registers.edx = dx;
  100129:	0f b7 55 d4          	movzwl -0x2c(%ebp),%edx
  10012d:	8b 45 f0             	mov    -0x10(%ebp),%eax
  100130:	89 50 38             	mov    %edx,0x38(%eax)
  proc->registers.esi = si;
  100133:	0f b7 55 d0          	movzwl -0x30(%ebp),%edx
  100137:	8b 45 f0             	mov    -0x10(%ebp),%eax
  10013a:	89 50 3c             	mov    %edx,0x3c(%eax)
  proc->registers.edi = di;
  10013d:	0f b7 55 cc          	movzwl -0x34(%ebp),%edx
  100141:	8b 45 f0             	mov    -0x10(%ebp),%eax
  100144:	89 50 40             	mov    %edx,0x40(%eax)
  proc->registers.ds = ds;
  100147:	0f b7 55 c8          	movzwl -0x38(%ebp),%edx
  10014b:	8b 45 f0             	mov    -0x10(%ebp),%eax
  10014e:	89 50 58             	mov    %edx,0x58(%eax)
  proc->registers.es = es;
  100151:	0f b7 55 c4          	movzwl -0x3c(%ebp),%edx
  100155:	8b 45 f0             	mov    -0x10(%ebp),%eax
  100158:	89 50 5c             	mov    %edx,0x5c(%eax)

  proc->registers.eip = IVT_GET_IP(0x10);
  10015b:	b8 40 00 00 00       	mov    $0x40,%eax
  100160:	0f b7 00             	movzwl (%eax),%eax
  100163:	0f b7 d0             	movzwl %ax,%edx
  100166:	8b 45 f0             	mov    -0x10(%ebp),%eax
  100169:	89 50 4c             	mov    %edx,0x4c(%eax)
  proc->registers.cs = IVT_GET_CS(0x10);
  10016c:	b8 42 00 00 00       	mov    $0x42,%eax
  100171:	0f b7 00             	movzwl (%eax),%eax
  100174:	0f b7 d0             	movzwl %ax,%edx
  100177:	8b 45 f0             	mov    -0x10(%ebp),%eax
  10017a:	89 50 54             	mov    %edx,0x54(%eax)

  kprintf("Process: %s\n",proc_current->name);
  10017d:	a1 a0 e1 10 00       	mov    0x10e1a0,%eax
  100182:	8b 40 20             	mov    0x20(%eax),%eax
  100185:	89 44 24 04          	mov    %eax,0x4(%esp)
  100189:	c7 04 24 09 d0 10 00 	movl   $0x10d009,(%esp)
  100190:	e8 06 22 00 00       	call   10239b <kprintf>
  kprintf("AX: 0x%x\n",proc->registers.eax);
  100195:	8b 45 f0             	mov    -0x10(%ebp),%eax
  100198:	8b 40 2c             	mov    0x2c(%eax),%eax
  10019b:	89 44 24 04          	mov    %eax,0x4(%esp)
  10019f:	c7 04 24 16 d0 10 00 	movl   $0x10d016,(%esp)
  1001a6:	e8 f0 21 00 00       	call   10239b <kprintf>
  kprintf("BX: 0x%x\n",proc->registers.ebx);
  1001ab:	8b 45 f0             	mov    -0x10(%ebp),%eax
  1001ae:	8b 40 30             	mov    0x30(%eax),%eax
  1001b1:	89 44 24 04          	mov    %eax,0x4(%esp)
  1001b5:	c7 04 24 20 d0 10 00 	movl   $0x10d020,(%esp)
  1001bc:	e8 da 21 00 00       	call   10239b <kprintf>
  kprintf("CX: 0x%x\n",proc->registers.ecx);
  1001c1:	8b 45 f0             	mov    -0x10(%ebp),%eax
  1001c4:	8b 40 34             	mov    0x34(%eax),%eax
  1001c7:	89 44 24 04          	mov    %eax,0x4(%esp)
  1001cb:	c7 04 24 2a d0 10 00 	movl   $0x10d02a,(%esp)
  1001d2:	e8 c4 21 00 00       	call   10239b <kprintf>
  kprintf("DX: 0x%x\n",proc->registers.edx);
  1001d7:	8b 45 f0             	mov    -0x10(%ebp),%eax
  1001da:	8b 40 38             	mov    0x38(%eax),%eax
  1001dd:	89 44 24 04          	mov    %eax,0x4(%esp)
  1001e1:	c7 04 24 34 d0 10 00 	movl   $0x10d034,(%esp)
  1001e8:	e8 ae 21 00 00       	call   10239b <kprintf>
  kprintf("SI: 0x%x\n",proc->registers.esi);
  1001ed:	8b 45 f0             	mov    -0x10(%ebp),%eax
  1001f0:	8b 40 3c             	mov    0x3c(%eax),%eax
  1001f3:	89 44 24 04          	mov    %eax,0x4(%esp)
  1001f7:	c7 04 24 3e d0 10 00 	movl   $0x10d03e,(%esp)
  1001fe:	e8 98 21 00 00       	call   10239b <kprintf>
  kprintf("DI: 0x%x\n",proc->registers.edi);
  100203:	8b 45 f0             	mov    -0x10(%ebp),%eax
  100206:	8b 40 40             	mov    0x40(%eax),%eax
  100209:	89 44 24 04          	mov    %eax,0x4(%esp)
  10020d:	c7 04 24 48 d0 10 00 	movl   $0x10d048,(%esp)
  100214:	e8 82 21 00 00       	call   10239b <kprintf>
  kprintf("DS: 0x%x\n",proc->registers.ds);
  100219:	8b 45 f0             	mov    -0x10(%ebp),%eax
  10021c:	8b 40 58             	mov    0x58(%eax),%eax
  10021f:	89 44 24 04          	mov    %eax,0x4(%esp)
  100223:	c7 04 24 52 d0 10 00 	movl   $0x10d052,(%esp)
  10022a:	e8 6c 21 00 00       	call   10239b <kprintf>
  kprintf("ES: 0x%x\n",proc->registers.es);
  10022f:	8b 45 f0             	mov    -0x10(%ebp),%eax
  100232:	8b 40 5c             	mov    0x5c(%eax),%eax
  100235:	89 44 24 04          	mov    %eax,0x4(%esp)
  100239:	c7 04 24 5c d0 10 00 	movl   $0x10d05c,(%esp)
  100240:	e8 56 21 00 00       	call   10239b <kprintf>
  kprintf("IP: 0x%x\n",proc->registers.eip);
  100245:	8b 45 f0             	mov    -0x10(%ebp),%eax
  100248:	8b 40 4c             	mov    0x4c(%eax),%eax
  10024b:	89 44 24 04          	mov    %eax,0x4(%esp)
  10024f:	c7 04 24 66 d0 10 00 	movl   $0x10d066,(%esp)
  100256:	e8 40 21 00 00       	call   10239b <kprintf>
  kprintf("CS: 0x%x\n",proc->registers.cs);
  10025b:	8b 45 f0             	mov    -0x10(%ebp),%eax
  10025e:	8b 40 54             	mov    0x54(%eax),%eax
  100261:	89 44 24 04          	mov    %eax,0x4(%esp)
  100265:	c7 04 24 70 d0 10 00 	movl   $0x10d070,(%esp)
  10026c:	e8 2a 21 00 00       	call   10239b <kprintf>

  for (i=0;i<meminfo_count*3;i+=3) {
  100271:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
  100278:	eb 5b                	jmp    1002d5 <biosint_call+0x251>
    kprintf("Dest: 0x%x\n",meminfo[i]);
  10027a:	8b 45 ec             	mov    -0x14(%ebp),%eax
  10027d:	c1 e0 02             	shl    $0x2,%eax
  100280:	03 45 08             	add    0x8(%ebp),%eax
  100283:	8b 00                	mov    (%eax),%eax
  100285:	89 44 24 04          	mov    %eax,0x4(%esp)
  100289:	c7 04 24 7a d0 10 00 	movl   $0x10d07a,(%esp)
  100290:	e8 06 21 00 00       	call   10239b <kprintf>
    kprintf("Src:  0x%x\n",meminfo[i+1]);
  100295:	8b 45 ec             	mov    -0x14(%ebp),%eax
  100298:	83 c0 01             	add    $0x1,%eax
  10029b:	c1 e0 02             	shl    $0x2,%eax
  10029e:	03 45 08             	add    0x8(%ebp),%eax
  1002a1:	8b 00                	mov    (%eax),%eax
  1002a3:	89 44 24 04          	mov    %eax,0x4(%esp)
  1002a7:	c7 04 24 86 d0 10 00 	movl   $0x10d086,(%esp)
  1002ae:	e8 e8 20 00 00       	call   10239b <kprintf>
    kprintf("Size: 0x%x\n",meminfo[i+2]);
  1002b3:	8b 45 ec             	mov    -0x14(%ebp),%eax
  1002b6:	83 c0 02             	add    $0x2,%eax
  1002b9:	c1 e0 02             	shl    $0x2,%eax
  1002bc:	03 45 08             	add    0x8(%ebp),%eax
  1002bf:	8b 00                	mov    (%eax),%eax
  1002c1:	89 44 24 04          	mov    %eax,0x4(%esp)
  1002c5:	c7 04 24 92 d0 10 00 	movl   $0x10d092,(%esp)
  1002cc:	e8 ca 20 00 00       	call   10239b <kprintf>
  kprintf("DS: 0x%x\n",proc->registers.ds);
  kprintf("ES: 0x%x\n",proc->registers.es);
  kprintf("IP: 0x%x\n",proc->registers.eip);
  kprintf("CS: 0x%x\n",proc->registers.cs);

  for (i=0;i<meminfo_count*3;i+=3) {
  1002d1:	83 45 ec 03          	addl   $0x3,-0x14(%ebp)
  1002d5:	8b 45 0c             	mov    0xc(%ebp),%eax
  1002d8:	89 c2                	mov    %eax,%edx
  1002da:	01 d2                	add    %edx,%edx
  1002dc:	8d 04 02             	lea    (%edx,%eax,1),%eax
  1002df:	3b 45 ec             	cmp    -0x14(%ebp),%eax
  1002e2:	77 96                	ja     10027a <biosint_call+0x1f6>
    kprintf("Dest: 0x%x\n",meminfo[i]);
    kprintf("Src:  0x%x\n",meminfo[i+1]);
    kprintf("Size: 0x%x\n",meminfo[i+2]);
  }

  proc_sleep(proc_current);
  1002e4:	a1 a0 e1 10 00       	mov    0x10e1a0,%eax
  1002e9:	89 04 24             	mov    %eax,(%esp)
  1002ec:	e8 30 63 00 00       	call   106621 <proc_sleep>

  return -1;
  1002f1:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  1002f6:	83 c4 4c             	add    $0x4c,%esp
  1002f9:	5b                   	pop    %ebx
  1002fa:	5e                   	pop    %esi
  1002fb:	5f                   	pop    %edi
  1002fc:	5d                   	pop    %ebp
  1002fd:	c3                   	ret    
	...

00100300 <cpu_init>:

/**
 * Initializes CPUs
 *  @return 0=Success; -1=Failure
 */
int cpu_init() {
  100300:	55                   	push   %ebp
  100301:	89 e5                	mov    %esp,%ebp
  100303:	83 ec 28             	sub    $0x28,%esp
  if ((cpus = llist_create())==NULL) return -1;
  100306:	e8 c9 a5 00 00       	call   10a8d4 <llist_create>
  10030b:	a3 54 e4 10 00       	mov    %eax,0x10e454
  100310:	a1 54 e4 10 00       	mov    0x10e454,%eax
  100315:	85 c0                	test   %eax,%eax
  100317:	75 09                	jne    100322 <cpu_init+0x22>
  100319:	c7 45 ec ff ff ff ff 	movl   $0xffffffff,-0x14(%ebp)
  100320:	eb 57                	jmp    100379 <cpu_init+0x79>
  cpu_t *cpu = malloc(sizeof(cpu_t));
  100322:	c7 04 24 60 00 00 00 	movl   $0x60,(%esp)
  100329:	e8 3b 2c 00 00       	call   102f69 <malloc>
  10032e:	89 45 fc             	mov    %eax,-0x4(%ebp)
  if (cpu==NULL) return -1;
  100331:	83 7d fc 00          	cmpl   $0x0,-0x4(%ebp)
  100335:	75 09                	jne    100340 <cpu_init+0x40>
  100337:	c7 45 ec ff ff ff ff 	movl   $0xffffffff,-0x14(%ebp)
  10033e:	eb 39                	jmp    100379 <cpu_init+0x79>
  cpu->enabled = 1;
  100340:	8b 45 fc             	mov    -0x4(%ebp),%eax
  100343:	c7 40 04 01 00 00 00 	movl   $0x1,0x4(%eax)
  cpu_stack_create(cpu,PAGE_SIZE);
  10034a:	c7 44 24 04 00 10 00 	movl   $0x1000,0x4(%esp)
  100351:	00 
  100352:	8b 45 fc             	mov    -0x4(%ebp),%eax
  100355:	89 04 24             	mov    %eax,(%esp)
  100358:	e8 21 00 00 00       	call   10037e <cpu_stack_create>
  llist_push(cpus,cpu);
  10035d:	8b 15 54 e4 10 00    	mov    0x10e454,%edx
  100363:	8b 45 fc             	mov    -0x4(%ebp),%eax
  100366:	89 44 24 04          	mov    %eax,0x4(%esp)
  10036a:	89 14 24             	mov    %edx,(%esp)
  10036d:	e8 dd a5 00 00       	call   10a94f <llist_push>
  return 0;
  100372:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
  100379:	8b 45 ec             	mov    -0x14(%ebp),%eax
}
  10037c:	c9                   	leave  
  10037d:	c3                   	ret    

0010037e <cpu_stack_create>:
 * Creates stack
 *  @param cpu CPU to create stack for
 *  @param size Stack size
 *  @return 0=Success; -1=Failure
 */
int cpu_stack_create(cpu_t *cpu,size_t size) {
  10037e:	55                   	push   %ebp
  10037f:	89 e5                	mov    %esp,%ebp
  100381:	83 ec 08             	sub    $0x8,%esp
  if ((cpu->stack = memkernel_alloc((size_t)PAGEUP(size)))==NULL) return -1;
  100384:	8b 45 0c             	mov    0xc(%ebp),%eax
  100387:	83 e8 01             	sub    $0x1,%eax
  10038a:	c1 e8 0c             	shr    $0xc,%eax
  10038d:	83 c0 01             	add    $0x1,%eax
  100390:	c1 e0 0c             	shl    $0xc,%eax
  100393:	89 04 24             	mov    %eax,(%esp)
  100396:	e8 03 2f 00 00       	call   10329e <memkernel_alloc>
  10039b:	89 c2                	mov    %eax,%edx
  10039d:	8b 45 08             	mov    0x8(%ebp),%eax
  1003a0:	89 50 08             	mov    %edx,0x8(%eax)
  1003a3:	8b 45 08             	mov    0x8(%ebp),%eax
  1003a6:	8b 40 08             	mov    0x8(%eax),%eax
  1003a9:	85 c0                	test   %eax,%eax
  1003ab:	75 09                	jne    1003b6 <cpu_stack_create+0x38>
  1003ad:	c7 45 fc ff ff ff ff 	movl   $0xffffffff,-0x4(%ebp)
  1003b4:	eb 10                	jmp    1003c6 <cpu_stack_create+0x48>
  cpu->stacksize = size;
  1003b6:	8b 55 08             	mov    0x8(%ebp),%edx
  1003b9:	8b 45 0c             	mov    0xc(%ebp),%eax
  1003bc:	89 42 0c             	mov    %eax,0xc(%edx)
  return 0;
  1003bf:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
  1003c6:	8b 45 fc             	mov    -0x4(%ebp),%eax
}
  1003c9:	c9                   	leave  
  1003ca:	c3                   	ret    

001003cb <cpu_id>:

void cpu_id(uint32_t seax,uint32_t *deax,uint32_t *debx,uint32_t *decx,uint32_t *dedx) {
  1003cb:	55                   	push   %ebp
  1003cc:	89 e5                	mov    %esp,%ebp
  1003ce:	53                   	push   %ebx
  1003cf:	83 ec 10             	sub    $0x10,%esp
  uint32_t eax,ebx,ecx,edx;
  asm("cpuid":"=a"(eax),"=b"(ebx),"=c"(ecx),"=d"(edx):"a"(seax));
  1003d2:	8b 45 08             	mov    0x8(%ebp),%eax
  1003d5:	0f a2                	cpuid  
  1003d7:	89 45 ec             	mov    %eax,-0x14(%ebp)
  1003da:	89 5d f0             	mov    %ebx,-0x10(%ebp)
  1003dd:	89 4d f4             	mov    %ecx,-0xc(%ebp)
  1003e0:	89 55 f8             	mov    %edx,-0x8(%ebp)
  if (deax!=NULL) *deax = eax;
  1003e3:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
  1003e7:	74 08                	je     1003f1 <cpu_id+0x26>
  1003e9:	8b 55 0c             	mov    0xc(%ebp),%edx
  1003ec:	8b 45 ec             	mov    -0x14(%ebp),%eax
  1003ef:	89 02                	mov    %eax,(%edx)
  if (debx!=NULL) *debx = ebx;
  1003f1:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
  1003f5:	74 08                	je     1003ff <cpu_id+0x34>
  1003f7:	8b 55 10             	mov    0x10(%ebp),%edx
  1003fa:	8b 45 f0             	mov    -0x10(%ebp),%eax
  1003fd:	89 02                	mov    %eax,(%edx)
  if (decx!=NULL) *decx = ecx;
  1003ff:	83 7d 14 00          	cmpl   $0x0,0x14(%ebp)
  100403:	74 08                	je     10040d <cpu_id+0x42>
  100405:	8b 55 14             	mov    0x14(%ebp),%edx
  100408:	8b 45 f4             	mov    -0xc(%ebp),%eax
  10040b:	89 02                	mov    %eax,(%edx)
  if (dedx!=NULL) *dedx = edx;
  10040d:	83 7d 18 00          	cmpl   $0x0,0x18(%ebp)
  100411:	74 08                	je     10041b <cpu_id+0x50>
  100413:	8b 55 18             	mov    0x18(%ebp),%edx
  100416:	8b 45 f8             	mov    -0x8(%ebp),%eax
  100419:	89 02                	mov    %eax,(%edx)
}
  10041b:	83 c4 10             	add    $0x10,%esp
  10041e:	5b                   	pop    %ebx
  10041f:	5d                   	pop    %ebp
  100420:	c3                   	ret    

00100421 <cpu_shutdown>:

/**
 * Shuts down computer
 */
void cpu_shutdown() {
  100421:	55                   	push   %ebp
  100422:	89 e5                	mov    %esp,%ebp
  100424:	83 ec 08             	sub    $0x8,%esp
  //vga_text_clear();
  kprintf("Please turn off the computer\n");
  100427:	c7 04 24 9e d0 10 00 	movl   $0x10d09e,(%esp)
  10042e:	e8 68 1f 00 00       	call   10239b <kprintf>
  interrupt_enable(0);
  100433:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  10043a:	e8 8c 0b 00 00       	call   100fcb <interrupt_enable>
  cpu_halt();
  10043f:	e8 02 00 00 00       	call   100446 <cpu_halt>
}
  100444:	c9                   	leave  
  100445:	c3                   	ret    

00100446 <cpu_halt>:
  clock_t ticks;
} cpu_t;

llist_t cpus;

static inline void cpu_halt() {
  100446:	55                   	push   %ebp
  100447:	89 e5                	mov    %esp,%ebp
  asm("hlt");
  100449:	f4                   	hlt    
}
  10044a:	5d                   	pop    %ebp
  10044b:	c3                   	ret    

0010044c <cpu_restart>:

/**
 * Resets computer
 */
void cpu_restart() {
  10044c:	55                   	push   %ebp
  10044d:	89 e5                	mov    %esp,%ebp
  10044f:	83 ec 10             	sub    $0x10,%esp
  idtsel_t idtsel = {
    .size = 0,
    .offset = 0
  };
  100452:	66 c7 45 fa 00 00    	movw   $0x0,-0x6(%ebp)
  100458:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
  asm("lidt (%0)"::"r"(&idtsel));
  10045f:	8d 45 fa             	lea    -0x6(%ebp),%eax
  100462:	0f 01 18             	lidtl  (%eax)
}
  100465:	c9                   	leave  
  100466:	c3                   	ret    
	...

00100468 <elf_validate>:
#include <memmap.h>
#include <string.h>
#include <debug.h>
#include <cpu.h>

int elf_validate(elf_header_t *header) {
  100468:	55                   	push   %ebp
  100469:	89 e5                	mov    %esp,%ebp
  10046b:	83 ec 04             	sub    $0x4,%esp
  if (header->ident[EI_MAG0]!=ELFMAG0 || header->ident[EI_MAG1]!=ELFMAG1 || header->ident[EI_MAG2]!=ELFMAG2 || header->ident[EI_MAG3]!=ELFMAG3) return -1;
  10046e:	8b 45 08             	mov    0x8(%ebp),%eax
  100471:	0f b6 00             	movzbl (%eax),%eax
  100474:	3c 7f                	cmp    $0x7f,%al
  100476:	75 21                	jne    100499 <elf_validate+0x31>
  100478:	8b 45 08             	mov    0x8(%ebp),%eax
  10047b:	0f b6 40 01          	movzbl 0x1(%eax),%eax
  10047f:	3c 45                	cmp    $0x45,%al
  100481:	75 16                	jne    100499 <elf_validate+0x31>
  100483:	8b 45 08             	mov    0x8(%ebp),%eax
  100486:	0f b6 40 02          	movzbl 0x2(%eax),%eax
  10048a:	3c 4c                	cmp    $0x4c,%al
  10048c:	75 0b                	jne    100499 <elf_validate+0x31>
  10048e:	8b 45 08             	mov    0x8(%ebp),%eax
  100491:	0f b6 40 03          	movzbl 0x3(%eax),%eax
  100495:	3c 46                	cmp    $0x46,%al
  100497:	74 09                	je     1004a2 <elf_validate+0x3a>
  100499:	c7 45 fc ff ff ff ff 	movl   $0xffffffff,-0x4(%ebp)
  1004a0:	eb 62                	jmp    100504 <elf_validate+0x9c>
  if (header->machine!=EM_386) return -1;
  1004a2:	8b 45 08             	mov    0x8(%ebp),%eax
  1004a5:	0f b7 40 12          	movzwl 0x12(%eax),%eax
  1004a9:	66 83 f8 03          	cmp    $0x3,%ax
  1004ad:	74 09                	je     1004b8 <elf_validate+0x50>
  1004af:	c7 45 fc ff ff ff ff 	movl   $0xffffffff,-0x4(%ebp)
  1004b6:	eb 4c                	jmp    100504 <elf_validate+0x9c>
  if (header->ident[EI_CLASS]!=ELFCLASS32) return -1;
  1004b8:	8b 45 08             	mov    0x8(%ebp),%eax
  1004bb:	0f b6 40 04          	movzbl 0x4(%eax),%eax
  1004bf:	3c 01                	cmp    $0x1,%al
  1004c1:	74 09                	je     1004cc <elf_validate+0x64>
  1004c3:	c7 45 fc ff ff ff ff 	movl   $0xffffffff,-0x4(%ebp)
  1004ca:	eb 38                	jmp    100504 <elf_validate+0x9c>
  if (header->ident[EI_DATA]!=ELFDATA2LSB) return -1;
  1004cc:	8b 45 08             	mov    0x8(%ebp),%eax
  1004cf:	0f b6 40 05          	movzbl 0x5(%eax),%eax
  1004d3:	3c 01                	cmp    $0x1,%al
  1004d5:	74 09                	je     1004e0 <elf_validate+0x78>
  1004d7:	c7 45 fc ff ff ff ff 	movl   $0xffffffff,-0x4(%ebp)
  1004de:	eb 24                	jmp    100504 <elf_validate+0x9c>
  if (header->ident[EI_VERSION]!=header->version) return -1;
  1004e0:	8b 45 08             	mov    0x8(%ebp),%eax
  1004e3:	0f b6 40 06          	movzbl 0x6(%eax),%eax
  1004e7:	0f b6 d0             	movzbl %al,%edx
  1004ea:	8b 45 08             	mov    0x8(%ebp),%eax
  1004ed:	8b 40 14             	mov    0x14(%eax),%eax
  1004f0:	39 c2                	cmp    %eax,%edx
  1004f2:	74 09                	je     1004fd <elf_validate+0x95>
  1004f4:	c7 45 fc ff ff ff ff 	movl   $0xffffffff,-0x4(%ebp)
  1004fb:	eb 07                	jmp    100504 <elf_validate+0x9c>
  return 0;
  1004fd:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
  100504:	8b 45 fc             	mov    -0x4(%ebp),%eax
}
  100507:	c9                   	leave  
  100508:	c3                   	ret    

00100509 <elf_loadseg>:
 *  @param fileaddr Source address in file (absolute)
 *  @param filesize Size in file
 *  @param addrspace User address space
 *  @param writable If segment is writeable
 */
int elf_loadseg(void *memaddr,size_t memsize,void *fileaddr,size_t filesize,addrspace_t *addrspace,int writable) {
  100509:	55                   	push   %ebp
  10050a:	89 e5                	mov    %esp,%ebp
  10050c:	83 ec 28             	sub    $0x28,%esp
  size_t i;

  if (memaddr<(void*)USERDATA_ADDRESS) return -1;
  10050f:	81 7d 08 ff ff ff 3f 	cmpl   $0x3fffffff,0x8(%ebp)
  100516:	77 0c                	ja     100524 <elf_loadseg+0x1b>
  100518:	c7 45 e8 ff ff ff ff 	movl   $0xffffffff,-0x18(%ebp)
  10051f:	e9 c1 00 00 00       	jmp    1005e5 <elf_loadseg+0xdc>
  if (memuser_load_addrspace(addrspace)==-1) return -1;
  100524:	8b 45 18             	mov    0x18(%ebp),%eax
  100527:	89 04 24             	mov    %eax,(%esp)
  10052a:	e8 ec 36 00 00       	call   103c1b <memuser_load_addrspace>
  10052f:	83 f8 ff             	cmp    $0xffffffff,%eax
  100532:	75 0c                	jne    100540 <elf_loadseg+0x37>
  100534:	c7 45 e8 ff ff ff ff 	movl   $0xffffffff,-0x18(%ebp)
  10053b:	e9 a5 00 00 00       	jmp    1005e5 <elf_loadseg+0xdc>
  for (i=0;i<memsize;i+=PAGE_SIZE) {
  100540:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
  100547:	eb 5f                	jmp    1005a8 <elf_loadseg+0x9f>
    if (memuser_alloc_at(addrspace,memaddr+i,i<filesize?paging_getphysaddr(fileaddr+i):NULL,writable)==-1) return -1;
  100549:	8b 45 fc             	mov    -0x4(%ebp),%eax
  10054c:	3b 45 14             	cmp    0x14(%ebp),%eax
  10054f:	73 15                	jae    100566 <elf_loadseg+0x5d>
  100551:	8b 55 fc             	mov    -0x4(%ebp),%edx
  100554:	8b 45 10             	mov    0x10(%ebp),%eax
  100557:	01 d0                	add    %edx,%eax
  100559:	89 04 24             	mov    %eax,(%esp)
  10055c:	e8 61 55 00 00       	call   105ac2 <paging_getphysaddr>
  100561:	89 45 ec             	mov    %eax,-0x14(%ebp)
  100564:	eb 07                	jmp    10056d <elf_loadseg+0x64>
  100566:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
  10056d:	8b 55 fc             	mov    -0x4(%ebp),%edx
  100570:	8b 45 08             	mov    0x8(%ebp),%eax
  100573:	8d 14 10             	lea    (%eax,%edx,1),%edx
  100576:	8b 45 1c             	mov    0x1c(%ebp),%eax
  100579:	89 44 24 0c          	mov    %eax,0xc(%esp)
  10057d:	8b 45 ec             	mov    -0x14(%ebp),%eax
  100580:	89 44 24 08          	mov    %eax,0x8(%esp)
  100584:	89 54 24 04          	mov    %edx,0x4(%esp)
  100588:	8b 45 18             	mov    0x18(%ebp),%eax
  10058b:	89 04 24             	mov    %eax,(%esp)
  10058e:	e8 87 3c 00 00       	call   10421a <memuser_alloc_at>
  100593:	83 f8 ff             	cmp    $0xffffffff,%eax
  100596:	75 09                	jne    1005a1 <elf_loadseg+0x98>
  100598:	c7 45 e8 ff ff ff ff 	movl   $0xffffffff,-0x18(%ebp)
  10059f:	eb 44                	jmp    1005e5 <elf_loadseg+0xdc>
int elf_loadseg(void *memaddr,size_t memsize,void *fileaddr,size_t filesize,addrspace_t *addrspace,int writable) {
  size_t i;

  if (memaddr<(void*)USERDATA_ADDRESS) return -1;
  if (memuser_load_addrspace(addrspace)==-1) return -1;
  for (i=0;i<memsize;i+=PAGE_SIZE) {
  1005a1:	81 45 fc 00 10 00 00 	addl   $0x1000,-0x4(%ebp)
  1005a8:	8b 45 fc             	mov    -0x4(%ebp),%eax
  1005ab:	3b 45 0c             	cmp    0xc(%ebp),%eax
  1005ae:	72 99                	jb     100549 <elf_loadseg+0x40>
    if (memuser_alloc_at(addrspace,memaddr+i,i<filesize?paging_getphysaddr(fileaddr+i):NULL,writable)==-1) return -1;
  }
  if (filesize<memsize) memset(memaddr+filesize,0,memsize-filesize);
  1005b0:	8b 45 14             	mov    0x14(%ebp),%eax
  1005b3:	3b 45 0c             	cmp    0xc(%ebp),%eax
  1005b6:	73 26                	jae    1005de <elf_loadseg+0xd5>
  1005b8:	8b 55 14             	mov    0x14(%ebp),%edx
  1005bb:	8b 45 0c             	mov    0xc(%ebp),%eax
  1005be:	89 c1                	mov    %eax,%ecx
  1005c0:	29 d1                	sub    %edx,%ecx
  1005c2:	8b 55 14             	mov    0x14(%ebp),%edx
  1005c5:	8b 45 08             	mov    0x8(%ebp),%eax
  1005c8:	01 d0                	add    %edx,%eax
  1005ca:	89 4c 24 08          	mov    %ecx,0x8(%esp)
  1005ce:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  1005d5:	00 
  1005d6:	89 04 24             	mov    %eax,(%esp)
  1005d9:	e8 83 b7 00 00       	call   10bd61 <memset>
  return 0;
  1005de:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
  1005e5:	8b 45 e8             	mov    -0x18(%ebp),%eax
}
  1005e8:	c9                   	leave  
  1005e9:	c3                   	ret    

001005ea <elf_load>:
 *  @param addrspace Address space
 *  @param file Pointer to ELF file
 *  @param filesize Size of ELF file
 *  @return Entrypoint
 */
void *elf_load(addrspace_t *addrspace,void *file,size_t filesize) {
  1005ea:	55                   	push   %ebp
  1005eb:	89 e5                	mov    %esp,%ebp
  1005ed:	57                   	push   %edi
  1005ee:	56                   	push   %esi
  1005ef:	53                   	push   %ebx
  1005f0:	83 ec 2c             	sub    $0x2c,%esp
  elf_header_t *header = file;
  1005f3:	8b 45 0c             	mov    0xc(%ebp),%eax
  1005f6:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  elf_progheader_t *progheader;
  void *entrypoint;
  size_t i;

  if (elf_validate(header)==-1) return NULL;
  1005f9:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  1005fc:	89 04 24             	mov    %eax,(%esp)
  1005ff:	e8 64 fe ff ff       	call   100468 <elf_validate>
  100604:	83 f8 ff             	cmp    $0xffffffff,%eax
  100607:	75 0c                	jne    100615 <elf_load+0x2b>
  100609:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
  100610:	e9 cc 00 00 00       	jmp    1006e1 <elf_load+0xf7>

  entrypoint = (void*)(header->entry);
  100615:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  100618:	8b 40 18             	mov    0x18(%eax),%eax
  10061b:	89 45 ec             	mov    %eax,-0x14(%ebp)
  progheader = file+header->phoff;
  10061e:	8b 55 0c             	mov    0xc(%ebp),%edx
  100621:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  100624:	8b 40 1c             	mov    0x1c(%eax),%eax
  100627:	8d 04 02             	lea    (%edx,%eax,1),%eax
  10062a:	89 45 e8             	mov    %eax,-0x18(%ebp)

  for (i=0;i<header->phnum;i++) {
  10062d:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
  100634:	e9 8f 00 00 00       	jmp    1006c8 <elf_load+0xde>
    if (progheader[i].type==PT_LOAD) {
  100639:	8b 45 f0             	mov    -0x10(%ebp),%eax
  10063c:	c1 e0 05             	shl    $0x5,%eax
  10063f:	03 45 e8             	add    -0x18(%ebp),%eax
  100642:	8b 00                	mov    (%eax),%eax
  100644:	83 f8 01             	cmp    $0x1,%eax
  100647:	75 7b                	jne    1006c4 <elf_load+0xda>
      if (elf_loadseg((void*)(progheader[i].vaddr),progheader[i].memsz,file+progheader[i].offset,progheader[i].filesz,addrspace,(progheader[i].flags&PF_W)==PF_W?1:0)==-1) return NULL;
  100649:	8b 45 f0             	mov    -0x10(%ebp),%eax
  10064c:	c1 e0 05             	shl    $0x5,%eax
  10064f:	03 45 e8             	add    -0x18(%ebp),%eax
  100652:	8b 40 18             	mov    0x18(%eax),%eax
  100655:	83 e0 02             	and    $0x2,%eax
  100658:	85 c0                	test   %eax,%eax
  10065a:	0f 95 c0             	setne  %al
  10065d:	0f b6 c8             	movzbl %al,%ecx
  100660:	8b 45 f0             	mov    -0x10(%ebp),%eax
  100663:	c1 e0 05             	shl    $0x5,%eax
  100666:	03 45 e8             	add    -0x18(%ebp),%eax
  100669:	8b 58 10             	mov    0x10(%eax),%ebx
  10066c:	8b 45 f0             	mov    -0x10(%ebp),%eax
  10066f:	c1 e0 05             	shl    $0x5,%eax
  100672:	03 45 e8             	add    -0x18(%ebp),%eax
  100675:	8b 40 04             	mov    0x4(%eax),%eax
  100678:	89 c6                	mov    %eax,%esi
  10067a:	03 75 0c             	add    0xc(%ebp),%esi
  10067d:	8b 45 f0             	mov    -0x10(%ebp),%eax
  100680:	c1 e0 05             	shl    $0x5,%eax
  100683:	03 45 e8             	add    -0x18(%ebp),%eax
  100686:	8b 78 14             	mov    0x14(%eax),%edi
  100689:	8b 45 f0             	mov    -0x10(%ebp),%eax
  10068c:	c1 e0 05             	shl    $0x5,%eax
  10068f:	03 45 e8             	add    -0x18(%ebp),%eax
  100692:	8b 40 08             	mov    0x8(%eax),%eax
  100695:	89 c2                	mov    %eax,%edx
  100697:	89 4c 24 14          	mov    %ecx,0x14(%esp)
  10069b:	8b 45 08             	mov    0x8(%ebp),%eax
  10069e:	89 44 24 10          	mov    %eax,0x10(%esp)
  1006a2:	89 5c 24 0c          	mov    %ebx,0xc(%esp)
  1006a6:	89 74 24 08          	mov    %esi,0x8(%esp)
  1006aa:	89 7c 24 04          	mov    %edi,0x4(%esp)
  1006ae:	89 14 24             	mov    %edx,(%esp)
  1006b1:	e8 53 fe ff ff       	call   100509 <elf_loadseg>
  1006b6:	83 f8 ff             	cmp    $0xffffffff,%eax
  1006b9:	75 09                	jne    1006c4 <elf_load+0xda>
  1006bb:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
  1006c2:	eb 1d                	jmp    1006e1 <elf_load+0xf7>
  if (elf_validate(header)==-1) return NULL;

  entrypoint = (void*)(header->entry);
  progheader = file+header->phoff;

  for (i=0;i<header->phnum;i++) {
  1006c4:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
  1006c8:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  1006cb:	0f b7 40 2c          	movzwl 0x2c(%eax),%eax
  1006cf:	0f b7 c0             	movzwl %ax,%eax
  1006d2:	3b 45 f0             	cmp    -0x10(%ebp),%eax
  1006d5:	0f 87 5e ff ff ff    	ja     100639 <elf_load+0x4f>
    if (progheader[i].type==PT_LOAD) {
      if (elf_loadseg((void*)(progheader[i].vaddr),progheader[i].memsz,file+progheader[i].offset,progheader[i].filesz,addrspace,(progheader[i].flags&PF_W)==PF_W?1:0)==-1) return NULL;
    }
  }

  return entrypoint;
  1006db:	8b 45 ec             	mov    -0x14(%ebp),%eax
  1006de:	89 45 e0             	mov    %eax,-0x20(%ebp)
  1006e1:	8b 45 e0             	mov    -0x20(%ebp),%eax
}
  1006e4:	83 c4 2c             	add    $0x2c,%esp
  1006e7:	5b                   	pop    %ebx
  1006e8:	5e                   	pop    %esi
  1006e9:	5f                   	pop    %edi
  1006ea:	5d                   	pop    %ebp
  1006eb:	c3                   	ret    

001006ec <gdt_reloadsregs>:
#include <gdt.h>
#include <malloc.h>
#include <string.h>
#include <debug.h>

void gdt_reloadsregs() {
  1006ec:	55                   	push   %ebp
  1006ed:	89 e5                	mov    %esp,%ebp
  1006ef:	83 ec 10             	sub    $0x10,%esp
  };*/
  const selector_t dsel = {
    .index = 2,
    .ti = 0,
    .priv = PRIV_KERNEL
  };
  1006f2:	0f b6 45 fe          	movzbl -0x2(%ebp),%eax
  1006f6:	83 e0 fc             	and    $0xfffffffc,%eax
  1006f9:	88 45 fe             	mov    %al,-0x2(%ebp)
  1006fc:	0f b6 45 fe          	movzbl -0x2(%ebp),%eax
  100700:	83 e0 fb             	and    $0xfffffffb,%eax
  100703:	88 45 fe             	mov    %al,-0x2(%ebp)
  100706:	0f b7 45 fe          	movzwl -0x2(%ebp),%eax
  10070a:	83 e0 07             	and    $0x7,%eax
  10070d:	83 c8 10             	or     $0x10,%eax
  100710:	66 89 45 fe          	mov    %ax,-0x2(%ebp)
  /*asm("mov %0,%%ds;"
      "ljmp %1,$gdt_reloadregs_fi;"
      "gdt_reloadregs_fi:"
      ::"r"((uint16_t)16),"i"((uint16_t)8));*/

  asm("ljmpl $0x08, $1f;"
  100714:	0f b7 55 fe          	movzwl -0x2(%ebp),%edx
  100718:	ea 1f 07 10 00 08 00 	ljmp   $0x8,$0x10071f
  10071f:	8e da                	mov    %edx,%ds
  100721:	8e c2                	mov    %edx,%es
  100723:	8e e2                	mov    %edx,%fs
  100725:	8e ea                	mov    %edx,%gs
  100727:	8e d2                	mov    %edx,%ss
      "mov %0, %%fs;"
      "mov %0, %%gs;"
      "mov %0, %%ss;"
      ::"r"(dsel):"eax");
  return;
}
  100729:	c9                   	leave  
  10072a:	c3                   	ret    

0010072b <gdt_init>:

/**
 * Initializes GDT
 *  @return 0=Success; -1=Failure
 */
int gdt_init() {
  10072b:	55                   	push   %ebp
  10072c:	89 e5                	mov    %esp,%ebp
  10072e:	83 ec 28             	sub    $0x28,%esp
  //gdt = calloc(GDT_MAXDESC,sizeof(gdtdesc_t));
  memset(gdt,0,GDT_MAXDESC*sizeof(gdtdesc_t));
  100731:	c7 44 24 08 00 02 00 	movl   $0x200,0x8(%esp)
  100738:	00 
  100739:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  100740:	00 
  100741:	c7 04 24 a0 e4 10 00 	movl   $0x10e4a0,(%esp)
  100748:	e8 14 b6 00 00       	call   10bd61 <memset>

  // Ring 0
  gdt_set_descriptor(1,0x000FFFFF,0x00000000,GDT_SEGMENT|GDT_PRESENT|GDT_CODESEG,PRIV_KERNEL);
  10074d:	c7 44 24 10 00 00 00 	movl   $0x0,0x10(%esp)
  100754:	00 
  100755:	c7 44 24 0c 9a 00 00 	movl   $0x9a,0xc(%esp)
  10075c:	00 
  10075d:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  100764:	00 
  100765:	c7 44 24 04 ff ff 0f 	movl   $0xfffff,0x4(%esp)
  10076c:	00 
  10076d:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
  100774:	e8 a4 00 00 00       	call   10081d <gdt_set_descriptor>
  gdt_set_descriptor(2,0x000FFFFF,0x00000000,GDT_SEGMENT|GDT_PRESENT|GDT_DATASEG,PRIV_KERNEL);
  100779:	c7 44 24 10 00 00 00 	movl   $0x0,0x10(%esp)
  100780:	00 
  100781:	c7 44 24 0c 92 00 00 	movl   $0x92,0xc(%esp)
  100788:	00 
  100789:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  100790:	00 
  100791:	c7 44 24 04 ff ff 0f 	movl   $0xfffff,0x4(%esp)
  100798:	00 
  100799:	c7 04 24 02 00 00 00 	movl   $0x2,(%esp)
  1007a0:	e8 78 00 00 00       	call   10081d <gdt_set_descriptor>

  // Ring 3
  gdt_set_descriptor(3,0x000FFFFF,0x00000000,GDT_SEGMENT|GDT_PRESENT|GDT_CODESEG,PRIV_USER);
  1007a5:	c7 44 24 10 03 00 00 	movl   $0x3,0x10(%esp)
  1007ac:	00 
  1007ad:	c7 44 24 0c 9a 00 00 	movl   $0x9a,0xc(%esp)
  1007b4:	00 
  1007b5:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  1007bc:	00 
  1007bd:	c7 44 24 04 ff ff 0f 	movl   $0xfffff,0x4(%esp)
  1007c4:	00 
  1007c5:	c7 04 24 03 00 00 00 	movl   $0x3,(%esp)
  1007cc:	e8 4c 00 00 00       	call   10081d <gdt_set_descriptor>
  gdt_set_descriptor(4,0x000FFFFF,0x00000000,GDT_SEGMENT|GDT_PRESENT|GDT_DATASEG,PRIV_USER);
  1007d1:	c7 44 24 10 03 00 00 	movl   $0x3,0x10(%esp)
  1007d8:	00 
  1007d9:	c7 44 24 0c 92 00 00 	movl   $0x92,0xc(%esp)
  1007e0:	00 
  1007e1:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  1007e8:	00 
  1007e9:	c7 44 24 04 ff ff 0f 	movl   $0xfffff,0x4(%esp)
  1007f0:	00 
  1007f1:	c7 04 24 04 00 00 00 	movl   $0x4,(%esp)
  1007f8:	e8 20 00 00 00       	call   10081d <gdt_set_descriptor>

  gdtsel_t selector = {
    .size = GDT_MAXDESC*sizeof(gdtdesc_t)-1,
    .offset = (uint32_t)&gdt
  };
  1007fd:	66 c7 45 fa ff 01    	movw   $0x1ff,-0x6(%ebp)
  100803:	b8 a0 e4 10 00       	mov    $0x10e4a0,%eax
  100808:	89 45 fc             	mov    %eax,-0x4(%ebp)
  asm("lgdt (%0)"::"r"(&selector));
  10080b:	8d 45 fa             	lea    -0x6(%ebp),%eax
  10080e:	0f 01 10             	lgdtl  (%eax)
  gdt_reloadsregs();
  100811:	e8 d6 fe ff ff       	call   1006ec <gdt_reloadsregs>

  return 0;
  100816:	b8 00 00 00 00       	mov    $0x0,%eax
}
  10081b:	c9                   	leave  
  10081c:	c3                   	ret    

0010081d <gdt_set_descriptor>:

void gdt_set_descriptor(int segment,size_t size,void *vdbase,int access,priv_t priv) {
  10081d:	55                   	push   %ebp
  10081e:	89 e5                	mov    %esp,%ebp
  100820:	83 ec 10             	sub    $0x10,%esp
  uint32_t base = (uint32_t)vdbase;
  100823:	8b 45 10             	mov    0x10(%ebp),%eax
  100826:	89 45 fc             	mov    %eax,-0x4(%ebp)
  gdt[segment].size0_15 = size&0xFFFF;
  100829:	8b 55 08             	mov    0x8(%ebp),%edx
  10082c:	8b 45 0c             	mov    0xc(%ebp),%eax
  10082f:	66 89 04 d5 a0 e4 10 	mov    %ax,0x10e4a0(,%edx,8)
  100836:	00 
  gdt[segment].flags = ((size>>16)&0x0F)|0xC0;
  100837:	8b 55 08             	mov    0x8(%ebp),%edx
  10083a:	8b 45 0c             	mov    0xc(%ebp),%eax
  10083d:	c1 e8 10             	shr    $0x10,%eax
  100840:	83 e0 0f             	and    $0xf,%eax
  100843:	83 c8 c0             	or     $0xffffffc0,%eax
  100846:	88 04 d5 a6 e4 10 00 	mov    %al,0x10e4a6(,%edx,8)
  gdt[segment].base0_15 = base&0xFFFF;
  10084d:	8b 55 08             	mov    0x8(%ebp),%edx
  100850:	8b 45 fc             	mov    -0x4(%ebp),%eax
  100853:	66 89 04 d5 a2 e4 10 	mov    %ax,0x10e4a2(,%edx,8)
  10085a:	00 
  gdt[segment].base16_23 = (base>>16)&0xFF;
  10085b:	8b 55 08             	mov    0x8(%ebp),%edx
  10085e:	8b 45 fc             	mov    -0x4(%ebp),%eax
  100861:	c1 e8 10             	shr    $0x10,%eax
  100864:	88 04 d5 a4 e4 10 00 	mov    %al,0x10e4a4(,%edx,8)
  gdt[segment].base24_31 = ((base>>24)&0xFF);
  10086b:	8b 55 08             	mov    0x8(%ebp),%edx
  10086e:	8b 45 fc             	mov    -0x4(%ebp),%eax
  100871:	c1 e8 18             	shr    $0x18,%eax
  100874:	88 04 d5 a7 e4 10 00 	mov    %al,0x10e4a7(,%edx,8)
  gdt[segment].access = access|((priv&3)<<5);
  10087b:	8b 4d 08             	mov    0x8(%ebp),%ecx
  10087e:	8b 45 18             	mov    0x18(%ebp),%eax
  100881:	83 e0 03             	and    $0x3,%eax
  100884:	89 c2                	mov    %eax,%edx
  100886:	c1 e2 05             	shl    $0x5,%edx
  100889:	8b 45 14             	mov    0x14(%ebp),%eax
  10088c:	09 d0                	or     %edx,%eax
  10088e:	88 04 cd a5 e4 10 00 	mov    %al,0x10e4a5(,%ecx,8)
}
  100895:	c9                   	leave  
  100896:	c3                   	ret    
	...

00100898 <idt_init>:

/**
 * Initializes IDT
 *  @return 0=Success; -1=Failure
 */
int idt_init() {
  100898:	55                   	push   %ebp
  100899:	89 e5                	mov    %esp,%ebp
  10089b:	83 ec 28             	sub    $0x28,%esp
  int i;
  //idt = calloc(ISR_NUM,sizeof(idtdesc_t));
  memset(idt,0,ISR_NUM*sizeof(idtdesc_t));
  10089e:	c7 44 24 08 c0 01 00 	movl   $0x1c0,0x8(%esp)
  1008a5:	00 
  1008a6:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  1008ad:	00 
  1008ae:	c7 04 24 60 e7 10 00 	movl   $0x10e760,(%esp)
  1008b5:	e8 a7 b4 00 00       	call   10bd61 <memset>

  selector_t selector = {
    .index = 1,
    .ti = 0,
    .priv = PRIV_KERNEL
  };
  1008ba:	0f b6 45 fa          	movzbl -0x6(%ebp),%eax
  1008be:	83 e0 fc             	and    $0xfffffffc,%eax
  1008c1:	88 45 fa             	mov    %al,-0x6(%ebp)
  1008c4:	0f b6 45 fa          	movzbl -0x6(%ebp),%eax
  1008c8:	83 e0 fb             	and    $0xfffffffb,%eax
  1008cb:	88 45 fa             	mov    %al,-0x6(%ebp)
  1008ce:	0f b7 45 fa          	movzwl -0x6(%ebp),%eax
  1008d2:	83 e0 07             	and    $0x7,%eax
  1008d5:	83 c8 08             	or     $0x8,%eax
  1008d8:	66 89 45 fa          	mov    %ax,-0x6(%ebp)
  for (i=0;i<ISR_NUM;i++) {
  1008dc:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
  1008e3:	eb 52                	jmp    100937 <idt_init+0x9f>
    idt_set_descriptor(i,isr[i],selector,i==SYSCALL_INT?PRIV_USER:PRIV_KERNEL,IDT_INTGATE32|IDT_PRESENT);
  1008e5:	83 7d fc 37          	cmpl   $0x37,-0x4(%ebp)
  1008e9:	75 09                	jne    1008f4 <idt_init+0x5c>
  1008eb:	c7 45 ec 03 00 00 00 	movl   $0x3,-0x14(%ebp)
  1008f2:	eb 07                	jmp    1008fb <idt_init+0x63>
  1008f4:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
  1008fb:	8b 15 9e 15 10 00    	mov    0x10159e,%edx
  100901:	8b 45 fc             	mov    -0x4(%ebp),%eax
  100904:	c1 e0 02             	shl    $0x2,%eax
  100907:	8d 04 02             	lea    (%edx,%eax,1),%eax
  10090a:	8b 10                	mov    (%eax),%edx
  10090c:	c7 44 24 10 8e 00 00 	movl   $0x8e,0x10(%esp)
  100913:	00 
  100914:	8b 45 ec             	mov    -0x14(%ebp),%eax
  100917:	89 44 24 0c          	mov    %eax,0xc(%esp)
  10091b:	0f b7 45 fa          	movzwl -0x6(%ebp),%eax
  10091f:	66 89 44 24 08       	mov    %ax,0x8(%esp)
  100924:	89 54 24 04          	mov    %edx,0x4(%esp)
  100928:	8b 45 fc             	mov    -0x4(%ebp),%eax
  10092b:	89 04 24             	mov    %eax,(%esp)
  10092e:	e8 25 00 00 00       	call   100958 <idt_set_descriptor>
  selector_t selector = {
    .index = 1,
    .ti = 0,
    .priv = PRIV_KERNEL
  };
  for (i=0;i<ISR_NUM;i++) {
  100933:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
  100937:	83 7d fc 37          	cmpl   $0x37,-0x4(%ebp)
  10093b:	7e a8                	jle    1008e5 <idt_init+0x4d>
  }

  idtsel_t idtsel = {
    .size = ISR_NUM*sizeof(idtdesc_t)-1,
    .offset = (uint32_t)&idt
  };
  10093d:	66 c7 45 f4 bf 01    	movw   $0x1bf,-0xc(%ebp)
  100943:	b8 60 e7 10 00       	mov    $0x10e760,%eax
  100948:	89 45 f6             	mov    %eax,-0xa(%ebp)
  asm("lidt (%0)"::"r"(&idtsel));
  10094b:	8d 45 f4             	lea    -0xc(%ebp),%eax
  10094e:	0f 01 18             	lidtl  (%eax)

  return 0;
  100951:	b8 00 00 00 00       	mov    $0x0,%eax
}
  100956:	c9                   	leave  
  100957:	c3                   	ret    

00100958 <idt_set_descriptor>:

void idt_set_descriptor(int i,void *addr,selector_t selector,priv_t priv,int type) {
  100958:	55                   	push   %ebp
  100959:	89 e5                	mov    %esp,%ebp
  idt[i].zero = 0;
  10095b:	8b 45 08             	mov    0x8(%ebp),%eax
  10095e:	c6 04 c5 64 e7 10 00 	movb   $0x0,0x10e764(,%eax,8)
  100965:	00 
  idt[i].address0_15 = ((unsigned int)addr)&0xFFFF;
  100966:	8b 55 08             	mov    0x8(%ebp),%edx
  100969:	8b 45 0c             	mov    0xc(%ebp),%eax
  10096c:	66 89 04 d5 60 e7 10 	mov    %ax,0x10e760(,%edx,8)
  100973:	00 
  idt[i].address16_31 = (((unsigned int)addr)>>16)&0xFFFF;
  100974:	8b 55 08             	mov    0x8(%ebp),%edx
  100977:	8b 45 0c             	mov    0xc(%ebp),%eax
  10097a:	c1 e8 10             	shr    $0x10,%eax
  10097d:	66 89 04 d5 66 e7 10 	mov    %ax,0x10e766(,%edx,8)
  100984:	00 
  idt[i].selector = selector;
  100985:	8b 55 08             	mov    0x8(%ebp),%edx
  100988:	0f b7 45 10          	movzwl 0x10(%ebp),%eax
  10098c:	66 89 04 d5 62 e7 10 	mov    %ax,0x10e762(,%edx,8)
  100993:	00 
  idt[i].type = type|((priv&3)<<5);
  100994:	8b 4d 08             	mov    0x8(%ebp),%ecx
  100997:	8b 45 14             	mov    0x14(%ebp),%eax
  10099a:	83 e0 03             	and    $0x3,%eax
  10099d:	89 c2                	mov    %eax,%edx
  10099f:	c1 e2 05             	shl    $0x5,%edx
  1009a2:	8b 45 18             	mov    0x18(%ebp),%eax
  1009a5:	09 d0                	or     %edx,%eax
  1009a7:	88 04 cd 65 e7 10 00 	mov    %al,0x10e765(,%ecx,8)
}
  1009ae:	5d                   	pop    %ebp
  1009af:	c3                   	ret    

001009b0 <interrupt_init>:

/**
 * Initializes Interrupts
 *  @return 0=Success; -1=Failure
 */
int interrupt_init() {
  1009b0:	55                   	push   %ebp
  1009b1:	89 e5                	mov    %esp,%ebp
  1009b3:	53                   	push   %ebx
  1009b4:	83 ec 24             	sub    $0x24,%esp
  size_t i;
  interrupt_enabled = 0;
  1009b7:	c7 05 0c e7 10 00 00 	movl   $0x0,0x10e70c
  1009be:	00 00 00 
  interrupt_sleep = llist_create();
  1009c1:	e8 0e 9f 00 00       	call   10a8d4 <llist_create>
  1009c6:	a3 80 e4 10 00       	mov    %eax,0x10e480
  for (i=0;i<16;i++) interrupt_irq[i] = llist_create();
  1009cb:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
  1009d2:	eb 13                	jmp    1009e7 <interrupt_init+0x37>
  1009d4:	8b 5d f8             	mov    -0x8(%ebp),%ebx
  1009d7:	e8 f8 9e 00 00       	call   10a8d4 <llist_create>
  1009dc:	89 04 9d c0 e6 10 00 	mov    %eax,0x10e6c0(,%ebx,4)
  1009e3:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
  1009e7:	83 7d f8 0f          	cmpl   $0xf,-0x8(%ebp)
  1009eb:	76 e7                	jbe    1009d4 <interrupt_init+0x24>
  if (syscall_create(SYSCALL_IRQ_HANDLER,interrupt_irq_reghandler,2)==-1) return -1;
  1009ed:	c7 44 24 08 02 00 00 	movl   $0x2,0x8(%esp)
  1009f4:	00 
  1009f5:	c7 44 24 04 e2 0f 10 	movl   $0x100fe2,0x4(%esp)
  1009fc:	00 
  1009fd:	c7 04 24 4a 00 00 00 	movl   $0x4a,(%esp)
  100a04:	e8 31 94 00 00       	call   109e3a <syscall_create>
  100a09:	83 f8 ff             	cmp    $0xffffffff,%eax
  100a0c:	75 0c                	jne    100a1a <interrupt_init+0x6a>
  100a0e:	c7 45 e8 ff ff ff ff 	movl   $0xffffffff,-0x18(%ebp)
  100a15:	e9 b2 00 00 00       	jmp    100acc <interrupt_init+0x11c>
  if (syscall_create(SYSCALL_IRQ_SLEEP,interrupt_irq_sleep,1)==-1) return -1;
  100a1a:	c7 44 24 08 01 00 00 	movl   $0x1,0x8(%esp)
  100a21:	00 
  100a22:	c7 44 24 04 49 10 10 	movl   $0x101049,0x4(%esp)
  100a29:	00 
  100a2a:	c7 04 24 4b 00 00 00 	movl   $0x4b,(%esp)
  100a31:	e8 04 94 00 00       	call   109e3a <syscall_create>
  100a36:	83 f8 ff             	cmp    $0xffffffff,%eax
  100a39:	75 0c                	jne    100a47 <interrupt_init+0x97>
  100a3b:	c7 45 e8 ff ff ff ff 	movl   $0xffffffff,-0x18(%ebp)
  100a42:	e9 85 00 00 00       	jmp    100acc <interrupt_init+0x11c>
  if (syscall_create(SYSCALL_TIME_SLEEP,interrupt_time_sleep,1)==-1) return -1;
  100a47:	c7 44 24 08 01 00 00 	movl   $0x1,0x8(%esp)
  100a4e:	00 
  100a4f:	c7 44 24 04 4a 11 10 	movl   $0x10114a,0x4(%esp)
  100a56:	00 
  100a57:	c7 04 24 47 00 00 00 	movl   $0x47,(%esp)
  100a5e:	e8 d7 93 00 00       	call   109e3a <syscall_create>
  100a63:	83 f8 ff             	cmp    $0xffffffff,%eax
  100a66:	75 09                	jne    100a71 <interrupt_init+0xc1>
  100a68:	c7 45 e8 ff ff ff ff 	movl   $0xffffffff,-0x18(%ebp)
  100a6f:	eb 5b                	jmp    100acc <interrupt_init+0x11c>
  if (syscall_create(SYSCALL_TIME_USLEEP,interrupt_time_usleep,1)==-1) return -1;
  100a71:	c7 44 24 08 01 00 00 	movl   $0x1,0x8(%esp)
  100a78:	00 
  100a79:	c7 44 24 04 b4 11 10 	movl   $0x1011b4,0x4(%esp)
  100a80:	00 
  100a81:	c7 04 24 48 00 00 00 	movl   $0x48,(%esp)
  100a88:	e8 ad 93 00 00       	call   109e3a <syscall_create>
  100a8d:	83 f8 ff             	cmp    $0xffffffff,%eax
  100a90:	75 09                	jne    100a9b <interrupt_init+0xeb>
  100a92:	c7 45 e8 ff ff ff ff 	movl   $0xffffffff,-0x18(%ebp)
  100a99:	eb 31                	jmp    100acc <interrupt_init+0x11c>
  if (syscall_create(SYSCALL_TIME_GETTICKS,interrupt_time_getticks,0)==-1) return -1;
  100a9b:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  100aa2:	00 
  100aa3:	c7 44 24 04 e7 12 10 	movl   $0x1012e7,0x4(%esp)
  100aaa:	00 
  100aab:	c7 04 24 49 00 00 00 	movl   $0x49,(%esp)
  100ab2:	e8 83 93 00 00       	call   109e3a <syscall_create>
  100ab7:	83 f8 ff             	cmp    $0xffffffff,%eax
  100aba:	75 09                	jne    100ac5 <interrupt_init+0x115>
  100abc:	c7 45 e8 ff ff ff ff 	movl   $0xffffffff,-0x18(%ebp)
  100ac3:	eb 07                	jmp    100acc <interrupt_init+0x11c>
  return 0;
  100ac5:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
  100acc:	8b 45 e8             	mov    -0x18(%ebp),%eax
}
  100acf:	83 c4 24             	add    $0x24,%esp
  100ad2:	5b                   	pop    %ebx
  100ad3:	5d                   	pop    %ebp
  100ad4:	c3                   	ret    

00100ad5 <interrupt_handler>:

/**
 * Interrupt handler
 *  @param interrupt Interrupt number
 */
void interrupt_handler(unsigned int interrupt,uint32_t *stack) {
  100ad5:	55                   	push   %ebp
  100ad6:	89 e5                	mov    %esp,%ebp
  100ad8:	83 ec 18             	sub    $0x18,%esp
  asm("mov %%ss,%0; mov %0,%%ds"::"r"(0));
  100adb:	b8 00 00 00 00       	mov    $0x0,%eax
  100ae0:	8c d0                	mov    %ss,%eax
  100ae2:	8e d8                	mov    %eax,%ds
  cpu_t *cpu = cpu_this;
  100ae4:	a1 54 e4 10 00       	mov    0x10e454,%eax
  100ae9:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  100af0:	00 
  100af1:	89 04 24             	mov    %eax,(%esp)
  100af4:	e8 8e 9f 00 00       	call   10aa87 <llist_get>
  100af9:	89 45 fc             	mov    %eax,-0x4(%ebp)

  uint32_t errorcode = 0;
  100afc:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
  interrupt_save_stack(stack,&errorcode);
  100b03:	8d 45 f8             	lea    -0x8(%ebp),%eax
  100b06:	89 44 24 04          	mov    %eax,0x4(%esp)
  100b0a:	8b 45 0c             	mov    0xc(%ebp),%eax
  100b0d:	89 04 24             	mov    %eax,(%esp)
  100b10:	e8 f2 07 00 00       	call   101307 <interrupt_save_stack>

  // Exceptions
  if (interrupt<0x20 && interrupt!=0x0F) interrupt_exception_handler(interrupt,errorcode);
  100b15:	83 7d 08 1f          	cmpl   $0x1f,0x8(%ebp)
  100b19:	77 18                	ja     100b33 <interrupt_handler+0x5e>
  100b1b:	83 7d 08 0f          	cmpl   $0xf,0x8(%ebp)
  100b1f:	74 12                	je     100b33 <interrupt_handler+0x5e>
  100b21:	8b 45 f8             	mov    -0x8(%ebp),%eax
  100b24:	89 44 24 04          	mov    %eax,0x4(%esp)
  100b28:	8b 45 08             	mov    0x8(%ebp),%eax
  100b2b:	89 04 24             	mov    %eax,(%esp)
  100b2e:	e8 01 01 00 00       	call   100c34 <interrupt_exception_handler>

  // IRQs
  if (interrupt>0x1F && interrupt<0x30) interrupt_irq_handler(interrupt-0x20);
  100b33:	83 7d 08 1f          	cmpl   $0x1f,0x8(%ebp)
  100b37:	76 14                	jbe    100b4d <interrupt_handler+0x78>
  100b39:	83 7d 08 2f          	cmpl   $0x2f,0x8(%ebp)
  100b3d:	77 0e                	ja     100b4d <interrupt_handler+0x78>
  100b3f:	8b 45 08             	mov    0x8(%ebp),%eax
  100b42:	83 e8 20             	sub    $0x20,%eax
  100b45:	89 04 24             	mov    %eax,(%esp)
  100b48:	e8 bc 00 00 00       	call   100c09 <interrupt_irq_handler>
  if (!cpu->uselapic && interrupt==0x30) interrupt_irq_handler(0);
  100b4d:	8b 45 fc             	mov    -0x4(%ebp),%eax
  100b50:	8b 40 54             	mov    0x54(%eax),%eax
  100b53:	85 c0                	test   %eax,%eax
  100b55:	75 12                	jne    100b69 <interrupt_handler+0x94>
  100b57:	83 7d 08 30          	cmpl   $0x30,0x8(%ebp)
  100b5b:	75 0c                	jne    100b69 <interrupt_handler+0x94>
  100b5d:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  100b64:	e8 a0 00 00 00       	call   100c09 <interrupt_irq_handler>

  // LAPIC
  if (cpu->uselapic && interrupt>0x2F && interrupt<0x37 && interrupt==0x0F) interrupt_lapic_handler(interrupt);
  100b69:	8b 45 fc             	mov    -0x4(%ebp),%eax
  100b6c:	8b 40 54             	mov    0x54(%eax),%eax
  100b6f:	85 c0                	test   %eax,%eax
  100b71:	74 1d                	je     100b90 <interrupt_handler+0xbb>
  100b73:	83 7d 08 2f          	cmpl   $0x2f,0x8(%ebp)
  100b77:	76 17                	jbe    100b90 <interrupt_handler+0xbb>
  100b79:	83 7d 08 36          	cmpl   $0x36,0x8(%ebp)
  100b7d:	77 11                	ja     100b90 <interrupt_handler+0xbb>
  100b7f:	83 7d 08 0f          	cmpl   $0xf,0x8(%ebp)
  100b83:	75 0b                	jne    100b90 <interrupt_handler+0xbb>
  100b85:	8b 45 08             	mov    0x8(%ebp),%eax
  100b88:	89 04 24             	mov    %eax,(%esp)
  100b8b:	e8 61 00 00 00       	call   100bf1 <interrupt_lapic_handler>

  asm("mov %%es,%0; mov %0,%%ds"::"r"(0));
  100b90:	b8 00 00 00 00       	mov    $0x0,%eax
  100b95:	8c c0                	mov    %es,%eax
  100b97:	8e d8                	mov    %eax,%ds

  if (proc_current==NULL) proc_shedule();
  100b99:	a1 a0 e1 10 00       	mov    0x10e1a0,%eax
  100b9e:	85 c0                	test   %eax,%eax
  100ba0:	75 05                	jne    100ba7 <interrupt_handler+0xd2>
  100ba2:	e8 3d 5d 00 00       	call   1068e4 <proc_shedule>
}
  100ba7:	c9                   	leave  
  100ba8:	c3                   	ret    

00100ba9 <interrupt_timer>:

/**
 * Timer (PIC or LAPIC)
 */
void interrupt_timer() {
  100ba9:	55                   	push   %ebp
  100baa:	89 e5                	mov    %esp,%ebp
  100bac:	83 ec 18             	sub    $0x18,%esp
  cpu_t *cpu = cpu_this;
  100baf:	a1 54 e4 10 00       	mov    0x10e454,%eax
  100bb4:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  100bbb:	00 
  100bbc:	89 04 24             	mov    %eax,(%esp)
  100bbf:	e8 c3 9e 00 00       	call   10aa87 <llist_get>
  100bc4:	89 45 fc             	mov    %eax,-0x4(%ebp)
  cpu->ticks++;
  100bc7:	8b 45 fc             	mov    -0x4(%ebp),%eax
  100bca:	8b 40 5c             	mov    0x5c(%eax),%eax
  100bcd:	8d 50 01             	lea    0x1(%eax),%edx
  100bd0:	8b 45 fc             	mov    -0x4(%ebp),%eax
  100bd3:	89 50 5c             	mov    %edx,0x5c(%eax)
  interrupt_time_check(cpu->interval*1000);
  100bd6:	8b 45 fc             	mov    -0x4(%ebp),%eax
  100bd9:	8b 40 58             	mov    0x58(%eax),%eax
  100bdc:	69 c0 e8 03 00 00    	imul   $0x3e8,%eax,%eax
  100be2:	89 04 24             	mov    %eax,(%esp)
  100be5:	e8 2e 06 00 00       	call   101218 <interrupt_time_check>
  proc_shedule();
  100bea:	e8 f5 5c 00 00       	call   1068e4 <proc_shedule>
}
  100bef:	c9                   	leave  
  100bf0:	c3                   	ret    

00100bf1 <interrupt_lapic_handler>:

/**
 * LAPIC interrupt handler
 *  @param interrupt Interrupt
 */
void interrupt_lapic_handler(unsigned int interrupt) {
  100bf1:	55                   	push   %ebp
  100bf2:	89 e5                	mov    %esp,%ebp
  100bf4:	83 ec 08             	sub    $0x8,%esp
  lapic_eoi();
  100bf7:	e8 a0 18 00 00       	call   10249c <lapic_eoi>
  if (interrupt==0x30) interrupt_timer();
  100bfc:	83 7d 08 30          	cmpl   $0x30,0x8(%ebp)
  100c00:	75 05                	jne    100c07 <interrupt_lapic_handler+0x16>
  100c02:	e8 a2 ff ff ff       	call   100ba9 <interrupt_timer>
}
  100c07:	c9                   	leave  
  100c08:	c3                   	ret    

00100c09 <interrupt_irq_handler>:

/**
 * IRQ handler
 *  @param irq IRQ
 */
void interrupt_irq_handler(unsigned int irq) {
  100c09:	55                   	push   %ebp
  100c0a:	89 e5                	mov    %esp,%ebp
  100c0c:	83 ec 08             	sub    $0x8,%esp
  pic_eoi(irq);
  100c0f:	8b 45 08             	mov    0x8(%ebp),%eax
  100c12:	89 04 24             	mov    %eax,(%esp)
  100c15:	e8 af 50 00 00       	call   105cc9 <pic_eoi>
  if (irq==0) interrupt_timer();
  100c1a:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
  100c1e:	75 07                	jne    100c27 <interrupt_irq_handler+0x1e>
  100c20:	e8 84 ff ff ff       	call   100ba9 <interrupt_timer>
  100c25:	eb 0b                	jmp    100c32 <interrupt_irq_handler+0x29>
  else interrupt_irq_check(irq);
  100c27:	8b 45 08             	mov    0x8(%ebp),%eax
  100c2a:	89 04 24             	mov    %eax,(%esp)
  100c2d:	e8 75 04 00 00       	call   1010a7 <interrupt_irq_check>
}
  100c32:	c9                   	leave  
  100c33:	c3                   	ret    

00100c34 <interrupt_exception_handler>:

/**
 * Exception handler
 *  @param exception Exception number
 */
void interrupt_exception_handler(unsigned int exception,uint32_t errcode) {
  100c34:	55                   	push   %ebp
  100c35:	89 e5                	mov    %esp,%ebp
  100c37:	57                   	push   %edi
  100c38:	56                   	push   %esi
  100c39:	53                   	push   %ebx
  100c3a:	81 ec 9c 00 00 00    	sub    $0x9c,%esp
    "Stack Exception",
    "General Protection Fault",
    "Page Fault",
    "Intel reserved",
    "Coprocessor Error"
  };
  100c40:	8d 45 a8             	lea    -0x58(%ebp),%eax
  100c43:	89 85 78 ff ff ff    	mov    %eax,-0x88(%ebp)
  100c49:	c7 85 74 ff ff ff e0 	movl   $0x10d1e0,-0x8c(%ebp)
  100c50:	d1 10 00 
  100c53:	c7 85 70 ff ff ff 11 	movl   $0x11,-0x90(%ebp)
  100c5a:	00 00 00 
  100c5d:	8b bd 78 ff ff ff    	mov    -0x88(%ebp),%edi
  100c63:	8b b5 74 ff ff ff    	mov    -0x8c(%ebp),%esi
  100c69:	8b 8d 70 ff ff ff    	mov    -0x90(%ebp),%ecx
  100c6f:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)

  uint32_t cr2;
  asm("mov %%cr2,%0":"=a"(cr2));
  100c71:	0f 20 d0             	mov    %cr2,%eax
  100c74:	89 45 ec             	mov    %eax,-0x14(%ebp)
  errcode &= 0xFFFF;
  100c77:	81 65 0c ff ff 00 00 	andl   $0xffff,0xc(%ebp)

  if (exception==INTERRUPT_EXCEPTION_PAGE_FAULT) {
  100c7e:	83 7d 08 0e          	cmpl   $0xe,0x8(%ebp)
  100c82:	75 13                	jne    100c97 <interrupt_exception_handler+0x63>
    if (memuser_pagefault((void*)cr2)==0) return;
  100c84:	8b 45 ec             	mov    -0x14(%ebp),%eax
  100c87:	89 04 24             	mov    %eax,(%esp)
  100c8a:	e8 60 33 00 00       	call   103fef <memuser_pagefault>
  100c8f:	85 c0                	test   %eax,%eax
  100c91:	0f 84 23 03 00 00    	je     100fba <interrupt_exception_handler+0x386>
  }
  vga_text_cursor.color = VGA_TEXT_COLOR_RED_BLACK;
  100c97:	c7 05 08 e7 10 00 0c 	movl   $0xc,0x10e708
  100c9e:	00 00 00 
  kprintf(" **EXCEPTION[0x%x]: %s from %s (by EIP)\n",exception,exception<0x10?exceptions[exception]:"Unknown",*interrupt_curregs.eip<USERDATA_ADDRESS?"Kernel":"Userland");
  100ca1:	a1 40 e7 10 00       	mov    0x10e740,%eax
  100ca6:	8b 00                	mov    (%eax),%eax
  100ca8:	3d ff ff ff 3f       	cmp    $0x3fffffff,%eax
  100cad:	77 0c                	ja     100cbb <interrupt_exception_handler+0x87>
  100caf:	c7 85 7c ff ff ff 24 	movl   $0x10d224,-0x84(%ebp)
  100cb6:	d2 10 00 
  100cb9:	eb 0a                	jmp    100cc5 <interrupt_exception_handler+0x91>
  100cbb:	c7 85 7c ff ff ff 2b 	movl   $0x10d22b,-0x84(%ebp)
  100cc2:	d2 10 00 
  100cc5:	83 7d 08 0f          	cmpl   $0xf,0x8(%ebp)
  100cc9:	77 0c                	ja     100cd7 <interrupt_exception_handler+0xa3>
  100ccb:	8b 45 08             	mov    0x8(%ebp),%eax
  100cce:	8b 44 85 a8          	mov    -0x58(%ebp,%eax,4),%eax
  100cd2:	89 45 80             	mov    %eax,-0x80(%ebp)
  100cd5:	eb 07                	jmp    100cde <interrupt_exception_handler+0xaa>
  100cd7:	c7 45 80 34 d2 10 00 	movl   $0x10d234,-0x80(%ebp)
  100cde:	8b 85 7c ff ff ff    	mov    -0x84(%ebp),%eax
  100ce4:	89 44 24 0c          	mov    %eax,0xc(%esp)
  100ce8:	8b 55 80             	mov    -0x80(%ebp),%edx
  100ceb:	89 54 24 08          	mov    %edx,0x8(%esp)
  100cef:	8b 45 08             	mov    0x8(%ebp),%eax
  100cf2:	89 44 24 04          	mov    %eax,0x4(%esp)
  100cf6:	c7 04 24 3c d2 10 00 	movl   $0x10d23c,(%esp)
  100cfd:	e8 99 16 00 00       	call   10239b <kprintf>
  if (proc_current!=NULL) kprintf("Process: #%d %s\n",proc_current->pid,proc_current->name);
  100d02:	a1 a0 e1 10 00       	mov    0x10e1a0,%eax
  100d07:	85 c0                	test   %eax,%eax
  100d09:	74 25                	je     100d30 <interrupt_exception_handler+0xfc>
  100d0b:	a1 a0 e1 10 00       	mov    0x10e1a0,%eax
  100d10:	8b 50 20             	mov    0x20(%eax),%edx
  100d13:	a1 a0 e1 10 00       	mov    0x10e1a0,%eax
  100d18:	8b 00                	mov    (%eax),%eax
  100d1a:	89 54 24 08          	mov    %edx,0x8(%esp)
  100d1e:	89 44 24 04          	mov    %eax,0x4(%esp)
  100d22:	c7 04 24 65 d2 10 00 	movl   $0x10d265,(%esp)
  100d29:	e8 6d 16 00 00       	call   10239b <kprintf>
  100d2e:	eb 0c                	jmp    100d3c <interrupt_exception_handler+0x108>
  else kprintf("Process: none\n");
  100d30:	c7 04 24 76 d2 10 00 	movl   $0x10d276,(%esp)
  100d37:	e8 5f 16 00 00       	call   10239b <kprintf>
  vga_text_cursor.color = VGA_TEXT_COLOR_DEFAULT;
  100d3c:	c7 05 08 e7 10 00 07 	movl   $0x7,0x10e708
  100d43:	00 00 00 
  kprintf("EAX: 0x%x\tEBX: 0x%x\tECX: 0x%x\tEDX: 0x%x\n",*interrupt_curregs.eax,*interrupt_curregs.ebx,*interrupt_curregs.ecx,*interrupt_curregs.edx);
  100d46:	a1 2c e7 10 00       	mov    0x10e72c,%eax
  100d4b:	8b 08                	mov    (%eax),%ecx
  100d4d:	a1 28 e7 10 00       	mov    0x10e728,%eax
  100d52:	8b 18                	mov    (%eax),%ebx
  100d54:	a1 24 e7 10 00       	mov    0x10e724,%eax
  100d59:	8b 10                	mov    (%eax),%edx
  100d5b:	a1 20 e7 10 00       	mov    0x10e720,%eax
  100d60:	8b 00                	mov    (%eax),%eax
  100d62:	89 4c 24 10          	mov    %ecx,0x10(%esp)
  100d66:	89 5c 24 0c          	mov    %ebx,0xc(%esp)
  100d6a:	89 54 24 08          	mov    %edx,0x8(%esp)
  100d6e:	89 44 24 04          	mov    %eax,0x4(%esp)
  100d72:	c7 04 24 88 d2 10 00 	movl   $0x10d288,(%esp)
  100d79:	e8 1d 16 00 00       	call   10239b <kprintf>
  kprintf("EIP: 0x%x\tEFL: 0x%x\tEBP: 0x%x\tESP: 0x%x\n",*interrupt_curregs.eip,*interrupt_curregs.efl,*interrupt_curregs.ebp,*interrupt_curregs.esp);
  100d7e:	a1 3c e7 10 00       	mov    0x10e73c,%eax
  100d83:	8b 08                	mov    (%eax),%ecx
  100d85:	a1 38 e7 10 00       	mov    0x10e738,%eax
  100d8a:	8b 18                	mov    (%eax),%ebx
  100d8c:	a1 44 e7 10 00       	mov    0x10e744,%eax
  100d91:	8b 10                	mov    (%eax),%edx
  100d93:	a1 40 e7 10 00       	mov    0x10e740,%eax
  100d98:	8b 00                	mov    (%eax),%eax
  100d9a:	89 4c 24 10          	mov    %ecx,0x10(%esp)
  100d9e:	89 5c 24 0c          	mov    %ebx,0xc(%esp)
  100da2:	89 54 24 08          	mov    %edx,0x8(%esp)
  100da6:	89 44 24 04          	mov    %eax,0x4(%esp)
  100daa:	c7 04 24 b4 d2 10 00 	movl   $0x10d2b4,(%esp)
  100db1:	e8 e5 15 00 00       	call   10239b <kprintf>
  kprintf("EDI: 0x%x\tESI: 0x%x\n",*interrupt_curregs.edi,*interrupt_curregs.esi);
  100db6:	a1 30 e7 10 00       	mov    0x10e730,%eax
  100dbb:	8b 10                	mov    (%eax),%edx
  100dbd:	a1 34 e7 10 00       	mov    0x10e734,%eax
  100dc2:	8b 00                	mov    (%eax),%eax
  100dc4:	89 54 24 08          	mov    %edx,0x8(%esp)
  100dc8:	89 44 24 04          	mov    %eax,0x4(%esp)
  100dcc:	c7 04 24 dd d2 10 00 	movl   $0x10d2dd,(%esp)
  100dd3:	e8 c3 15 00 00       	call   10239b <kprintf>
  kprintf("CS:  0x%x\tDS:  0x%x\tES:  0x%x\tFS:  0x%x\n",*interrupt_curregs.cs,*interrupt_curregs.ds,*interrupt_curregs.es,*interrupt_curregs.fs);
  100dd8:	a1 54 e7 10 00       	mov    0x10e754,%eax
  100ddd:	8b 08                	mov    (%eax),%ecx
  100ddf:	a1 50 e7 10 00       	mov    0x10e750,%eax
  100de4:	8b 18                	mov    (%eax),%ebx
  100de6:	a1 4c e7 10 00       	mov    0x10e74c,%eax
  100deb:	8b 10                	mov    (%eax),%edx
  100ded:	a1 48 e7 10 00       	mov    0x10e748,%eax
  100df2:	8b 00                	mov    (%eax),%eax
  100df4:	89 4c 24 10          	mov    %ecx,0x10(%esp)
  100df8:	89 5c 24 0c          	mov    %ebx,0xc(%esp)
  100dfc:	89 54 24 08          	mov    %edx,0x8(%esp)
  100e00:	89 44 24 04          	mov    %eax,0x4(%esp)
  100e04:	c7 04 24 f4 d2 10 00 	movl   $0x10d2f4,(%esp)
  100e0b:	e8 8b 15 00 00       	call   10239b <kprintf>
  kprintf("GS:  0x%x\tSS:  0x%x\n",interrupt_curregs.gs,interrupt_curregs.ss);
  100e10:	a1 5c e7 10 00       	mov    0x10e75c,%eax
  100e15:	8b 15 58 e7 10 00    	mov    0x10e758,%edx
  100e1b:	89 44 24 08          	mov    %eax,0x8(%esp)
  100e1f:	89 54 24 04          	mov    %edx,0x4(%esp)
  100e23:	c7 04 24 1d d3 10 00 	movl   $0x10d31d,(%esp)
  100e2a:	e8 6c 15 00 00       	call   10239b <kprintf>
  if (exception==INTERRUPT_EXCEPTION_PAGE_FAULT) {
  100e2f:	83 7d 08 0e          	cmpl   $0xe,0x8(%ebp)
  100e33:	0f 85 a4 00 00 00    	jne    100edd <interrupt_exception_handler+0x2a9>
    kprintf("Pagefault at: 0x%x\n",cr2);
  100e39:	8b 45 ec             	mov    -0x14(%ebp),%eax
  100e3c:	89 44 24 04          	mov    %eax,0x4(%esp)
  100e40:	c7 04 24 32 d3 10 00 	movl   $0x10d332,(%esp)
  100e47:	e8 4f 15 00 00       	call   10239b <kprintf>
    kprintf("%s by %s from %s\n",(errcode&1)?"Rights violation":"Accessing a not present page",(errcode&8)?"instruction fetch":((errcode&2)?"writing":"reading"),(errcode&4)?proc_current->name:"Kernel");
  100e4c:	8b 45 0c             	mov    0xc(%ebp),%eax
  100e4f:	83 e0 04             	and    $0x4,%eax
  100e52:	85 c0                	test   %eax,%eax
  100e54:	74 0d                	je     100e63 <interrupt_exception_handler+0x22f>
  100e56:	a1 a0 e1 10 00       	mov    0x10e1a0,%eax
  100e5b:	8b 40 20             	mov    0x20(%eax),%eax
  100e5e:	89 45 84             	mov    %eax,-0x7c(%ebp)
  100e61:	eb 07                	jmp    100e6a <interrupt_exception_handler+0x236>
  100e63:	c7 45 84 24 d2 10 00 	movl   $0x10d224,-0x7c(%ebp)
  100e6a:	8b 45 0c             	mov    0xc(%ebp),%eax
  100e6d:	83 e0 08             	and    $0x8,%eax
  100e70:	85 c0                	test   %eax,%eax
  100e72:	75 22                	jne    100e96 <interrupt_exception_handler+0x262>
  100e74:	8b 45 0c             	mov    0xc(%ebp),%eax
  100e77:	83 e0 02             	and    $0x2,%eax
  100e7a:	85 c0                	test   %eax,%eax
  100e7c:	74 09                	je     100e87 <interrupt_exception_handler+0x253>
  100e7e:	c7 45 8c 46 d3 10 00 	movl   $0x10d346,-0x74(%ebp)
  100e85:	eb 07                	jmp    100e8e <interrupt_exception_handler+0x25a>
  100e87:	c7 45 8c 4e d3 10 00 	movl   $0x10d34e,-0x74(%ebp)
  100e8e:	8b 4d 8c             	mov    -0x74(%ebp),%ecx
  100e91:	89 4d 88             	mov    %ecx,-0x78(%ebp)
  100e94:	eb 07                	jmp    100e9d <interrupt_exception_handler+0x269>
  100e96:	c7 45 88 56 d3 10 00 	movl   $0x10d356,-0x78(%ebp)
  100e9d:	8b 45 0c             	mov    0xc(%ebp),%eax
  100ea0:	83 e0 01             	and    $0x1,%eax
  100ea3:	84 c0                	test   %al,%al
  100ea5:	74 09                	je     100eb0 <interrupt_exception_handler+0x27c>
  100ea7:	c7 45 90 68 d3 10 00 	movl   $0x10d368,-0x70(%ebp)
  100eae:	eb 07                	jmp    100eb7 <interrupt_exception_handler+0x283>
  100eb0:	c7 45 90 79 d3 10 00 	movl   $0x10d379,-0x70(%ebp)
  100eb7:	8b 75 84             	mov    -0x7c(%ebp),%esi
  100eba:	89 74 24 0c          	mov    %esi,0xc(%esp)
  100ebe:	8b 7d 88             	mov    -0x78(%ebp),%edi
  100ec1:	89 7c 24 08          	mov    %edi,0x8(%esp)
  100ec5:	8b 45 90             	mov    -0x70(%ebp),%eax
  100ec8:	89 44 24 04          	mov    %eax,0x4(%esp)
  100ecc:	c7 04 24 96 d3 10 00 	movl   $0x10d396,(%esp)
  100ed3:	e8 c3 14 00 00       	call   10239b <kprintf>
  100ed8:	e9 84 00 00 00       	jmp    100f61 <interrupt_exception_handler+0x32d>
  }
  else if (errcode!=0) {
  100edd:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
  100ee1:	74 7e                	je     100f61 <interrupt_exception_handler+0x32d>
    kprintf("%s error in %s at index 0x%x\n",(errcode&1)?"External":"Internal",(errcode&2)?"IDT":((errcode&4)?"LDT":"GDT"),(errcode&0xFFF8)>>3);
  100ee3:	8b 45 0c             	mov    0xc(%ebp),%eax
  100ee6:	25 f8 ff 00 00       	and    $0xfff8,%eax
  100eeb:	89 c2                	mov    %eax,%edx
  100eed:	c1 ea 03             	shr    $0x3,%edx
  100ef0:	89 55 94             	mov    %edx,-0x6c(%ebp)
  100ef3:	8b 45 0c             	mov    0xc(%ebp),%eax
  100ef6:	83 e0 02             	and    $0x2,%eax
  100ef9:	85 c0                	test   %eax,%eax
  100efb:	75 22                	jne    100f1f <interrupt_exception_handler+0x2eb>
  100efd:	8b 45 0c             	mov    0xc(%ebp),%eax
  100f00:	83 e0 04             	and    $0x4,%eax
  100f03:	85 c0                	test   %eax,%eax
  100f05:	74 09                	je     100f10 <interrupt_exception_handler+0x2dc>
  100f07:	c7 45 9c a8 d3 10 00 	movl   $0x10d3a8,-0x64(%ebp)
  100f0e:	eb 07                	jmp    100f17 <interrupt_exception_handler+0x2e3>
  100f10:	c7 45 9c ac d3 10 00 	movl   $0x10d3ac,-0x64(%ebp)
  100f17:	8b 4d 9c             	mov    -0x64(%ebp),%ecx
  100f1a:	89 4d 98             	mov    %ecx,-0x68(%ebp)
  100f1d:	eb 07                	jmp    100f26 <interrupt_exception_handler+0x2f2>
  100f1f:	c7 45 98 b0 d3 10 00 	movl   $0x10d3b0,-0x68(%ebp)
  100f26:	8b 45 0c             	mov    0xc(%ebp),%eax
  100f29:	83 e0 01             	and    $0x1,%eax
  100f2c:	84 c0                	test   %al,%al
  100f2e:	74 09                	je     100f39 <interrupt_exception_handler+0x305>
  100f30:	c7 45 a0 b4 d3 10 00 	movl   $0x10d3b4,-0x60(%ebp)
  100f37:	eb 07                	jmp    100f40 <interrupt_exception_handler+0x30c>
  100f39:	c7 45 a0 bd d3 10 00 	movl   $0x10d3bd,-0x60(%ebp)
  100f40:	8b 75 94             	mov    -0x6c(%ebp),%esi
  100f43:	89 74 24 0c          	mov    %esi,0xc(%esp)
  100f47:	8b 7d 98             	mov    -0x68(%ebp),%edi
  100f4a:	89 7c 24 08          	mov    %edi,0x8(%esp)
  100f4e:	8b 45 a0             	mov    -0x60(%ebp),%eax
  100f51:	89 44 24 04          	mov    %eax,0x4(%esp)
  100f55:	c7 04 24 c6 d3 10 00 	movl   $0x10d3c6,(%esp)
  100f5c:	e8 3a 14 00 00       	call   10239b <kprintf>
  if (*interrupt_curregs.esp>=0x4000000 && *interrupt_curregs.esp<0x40001000 && 0) {
    int *i;
    kprintf("Stack:\n");
    for (i=(int*)*interrupt_curregs.esp;i<(int*)0x40001000;i++) kprintf("0x%x:\t0x%x\n",i,*i);
  }
  cpu_halt();
  100f61:	e8 5f 00 00 00       	call   100fc5 <cpu_halt>

  if (exception==INTERRUPT_EXCEPTION_PAGE_FAULT) kill(proc_current,SIGSEGV);
  100f66:	83 7d 08 0e          	cmpl   $0xe,0x8(%ebp)
  100f6a:	75 17                	jne    100f83 <interrupt_exception_handler+0x34f>
  100f6c:	a1 a0 e1 10 00       	mov    0x10e1a0,%eax
  100f71:	c7 44 24 04 0b 00 00 	movl   $0xb,0x4(%esp)
  100f78:	00 
  100f79:	89 04 24             	mov    %eax,(%esp)
  100f7c:	e8 51 8a 00 00       	call   1099d2 <signal_send>
  100f81:	eb 32                	jmp    100fb5 <interrupt_exception_handler+0x381>
  else if (exception==INTERRUPT_EXCEPTION_INVALID_OPCODE) kill(proc_current,SIGILL);
  100f83:	83 7d 08 06          	cmpl   $0x6,0x8(%ebp)
  100f87:	75 17                	jne    100fa0 <interrupt_exception_handler+0x36c>
  100f89:	a1 a0 e1 10 00       	mov    0x10e1a0,%eax
  100f8e:	c7 44 24 04 04 00 00 	movl   $0x4,0x4(%esp)
  100f95:	00 
  100f96:	89 04 24             	mov    %eax,(%esp)
  100f99:	e8 34 8a 00 00       	call   1099d2 <signal_send>
  100f9e:	eb 15                	jmp    100fb5 <interrupt_exception_handler+0x381>
  else kill(proc_current,SIGKILL);
  100fa0:	a1 a0 e1 10 00       	mov    0x10e1a0,%eax
  100fa5:	c7 44 24 04 09 00 00 	movl   $0x9,0x4(%esp)
  100fac:	00 
  100fad:	89 04 24             	mov    %eax,(%esp)
  100fb0:	e8 1d 8a 00 00       	call   1099d2 <signal_send>

  proc_idle();
  100fb5:	e8 66 61 00 00       	call   107120 <proc_idle>
}
  100fba:	81 c4 9c 00 00 00    	add    $0x9c,%esp
  100fc0:	5b                   	pop    %ebx
  100fc1:	5e                   	pop    %esi
  100fc2:	5f                   	pop    %edi
  100fc3:	5d                   	pop    %ebp
  100fc4:	c3                   	ret    

00100fc5 <cpu_halt>:
  clock_t ticks;
} cpu_t;

llist_t cpus;

static inline void cpu_halt() {
  100fc5:	55                   	push   %ebp
  100fc6:	89 e5                	mov    %esp,%ebp
  asm("hlt");
  100fc8:	f4                   	hlt    
}
  100fc9:	5d                   	pop    %ebp
  100fca:	c3                   	ret    

00100fcb <interrupt_enable>:

/**
 * Enables/Disables interrupts
 *  @param enable Whether to enable or disable interrupts
 */
void interrupt_enable(int enable) {
  100fcb:	55                   	push   %ebp
  100fcc:	89 e5                	mov    %esp,%ebp
  interrupt_enabled = enable;
  100fce:	8b 45 08             	mov    0x8(%ebp),%eax
  100fd1:	a3 0c e7 10 00       	mov    %eax,0x10e70c
  if (enable) asm("sti");
  100fd6:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
  100fda:	74 03                	je     100fdf <interrupt_enable+0x14>
  100fdc:	fb                   	sti    
  100fdd:	eb 01                	jmp    100fe0 <interrupt_enable+0x15>
  else asm("cli");
  100fdf:	fa                   	cli    
}
  100fe0:	5d                   	pop    %ebp
  100fe1:	c3                   	ret    

00100fe2 <interrupt_irq_reghandler>:
/**
 * Registers an IRQ handler (Syscall)
 *  @param irq IRQ
 *  @param func Function
 */
int interrupt_irq_reghandler(unsigned int irq,void *func) {
  100fe2:	55                   	push   %ebp
  100fe3:	89 e5                	mov    %esp,%ebp
  100fe5:	83 ec 28             	sub    $0x28,%esp
  if (irq<16) {
  100fe8:	83 7d 08 0f          	cmpl   $0xf,0x8(%ebp)
  100fec:	77 4f                	ja     10103d <interrupt_irq_reghandler+0x5b>
    interrupt_irq_t *new = malloc(sizeof(interrupt_irq_t));
  100fee:	c7 04 24 0c 00 00 00 	movl   $0xc,(%esp)
  100ff5:	e8 6f 1f 00 00       	call   102f69 <malloc>
  100ffa:	89 45 fc             	mov    %eax,-0x4(%ebp)
    new->func = func;
  100ffd:	8b 55 fc             	mov    -0x4(%ebp),%edx
  101000:	8b 45 0c             	mov    0xc(%ebp),%eax
  101003:	89 42 08             	mov    %eax,0x8(%edx)
    new->proc = proc_current;
  101006:	8b 15 a0 e1 10 00    	mov    0x10e1a0,%edx
  10100c:	8b 45 fc             	mov    -0x4(%ebp),%eax
  10100f:	89 50 04             	mov    %edx,0x4(%eax)
    new->type = IRQ_HANDLER;
  101012:	8b 45 fc             	mov    -0x4(%ebp),%eax
  101015:	c7 00 01 00 00 00    	movl   $0x1,(%eax)
    llist_push(interrupt_irq[irq],new);
  10101b:	8b 45 08             	mov    0x8(%ebp),%eax
  10101e:	8b 14 85 c0 e6 10 00 	mov    0x10e6c0(,%eax,4),%edx
  101025:	8b 45 fc             	mov    -0x4(%ebp),%eax
  101028:	89 44 24 04          	mov    %eax,0x4(%esp)
  10102c:	89 14 24             	mov    %edx,(%esp)
  10102f:	e8 1b 99 00 00       	call   10a94f <llist_push>
    return 0;
  101034:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
  10103b:	eb 07                	jmp    101044 <interrupt_irq_reghandler+0x62>
  }
  else return -1;
  10103d:	c7 45 ec ff ff ff ff 	movl   $0xffffffff,-0x14(%ebp)
  101044:	8b 45 ec             	mov    -0x14(%ebp),%eax
}
  101047:	c9                   	leave  
  101048:	c3                   	ret    

00101049 <interrupt_irq_sleep>:

/**
 * Sleeps until an IRQ is fired (Syscall)
 *  @param irq IRQ
 */
int interrupt_irq_sleep(unsigned int irq) {
  101049:	55                   	push   %ebp
  10104a:	89 e5                	mov    %esp,%ebp
  10104c:	83 ec 28             	sub    $0x28,%esp
  if (irq<16) {
  10104f:	83 7d 08 0f          	cmpl   $0xf,0x8(%ebp)
  101053:	77 46                	ja     10109b <interrupt_irq_sleep+0x52>
    interrupt_irq_t *new = malloc(sizeof(interrupt_irq_t));
  101055:	c7 04 24 0c 00 00 00 	movl   $0xc,(%esp)
  10105c:	e8 08 1f 00 00       	call   102f69 <malloc>
  101061:	89 45 fc             	mov    %eax,-0x4(%ebp)
    new->proc = proc_current;
  101064:	8b 15 a0 e1 10 00    	mov    0x10e1a0,%edx
  10106a:	8b 45 fc             	mov    -0x4(%ebp),%eax
  10106d:	89 50 04             	mov    %edx,0x4(%eax)
    new->type = IRQ_SLEEP;
  101070:	8b 45 fc             	mov    -0x4(%ebp),%eax
  101073:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
    llist_push(interrupt_irq[irq],new);
  101079:	8b 45 08             	mov    0x8(%ebp),%eax
  10107c:	8b 14 85 c0 e6 10 00 	mov    0x10e6c0(,%eax,4),%edx
  101083:	8b 45 fc             	mov    -0x4(%ebp),%eax
  101086:	89 44 24 04          	mov    %eax,0x4(%esp)
  10108a:	89 14 24             	mov    %edx,(%esp)
  10108d:	e8 bd 98 00 00       	call   10a94f <llist_push>
    return 0;
  101092:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
  101099:	eb 07                	jmp    1010a2 <interrupt_irq_sleep+0x59>
  }
  else return -1;
  10109b:	c7 45 ec ff ff ff ff 	movl   $0xffffffff,-0x14(%ebp)
  1010a2:	8b 45 ec             	mov    -0x14(%ebp),%eax
}
  1010a5:	c9                   	leave  
  1010a6:	c3                   	ret    

001010a7 <interrupt_irq_check>:

/**
 * Checks for IRQ events
 *  @param irq IRQ
 */
void interrupt_irq_check(unsigned int irq) {
  1010a7:	55                   	push   %ebp
  1010a8:	89 e5                	mov    %esp,%ebp
  1010aa:	83 ec 28             	sub    $0x28,%esp
  interrupt_irq_t *irqo;
  size_t i;
  for (i=0;(irqo = llist_get(interrupt_irq[irq],i));i++) {
  1010ad:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
  1010b4:	eb 6c                	jmp    101122 <interrupt_irq_check+0x7b>
    if (irqo->type==IRQ_SLEEP) {
  1010b6:	8b 45 f8             	mov    -0x8(%ebp),%eax
  1010b9:	8b 00                	mov    (%eax),%eax
  1010bb:	85 c0                	test   %eax,%eax
  1010bd:	75 38                	jne    1010f7 <interrupt_irq_check+0x50>
      proc_wake(irqo->proc);
  1010bf:	8b 45 f8             	mov    -0x8(%ebp),%eax
  1010c2:	8b 40 04             	mov    0x4(%eax),%eax
  1010c5:	89 04 24             	mov    %eax,(%esp)
  1010c8:	e8 c0 55 00 00       	call   10668d <proc_wake>
      free(irqo);
  1010cd:	8b 45 f8             	mov    -0x8(%ebp),%eax
  1010d0:	89 04 24             	mov    %eax,(%esp)
  1010d3:	e8 c5 1e 00 00       	call   102f9d <free>
      llist_remove(interrupt_irq[irq],i);
  1010d8:	8b 45 08             	mov    0x8(%ebp),%eax
  1010db:	8b 14 85 c0 e6 10 00 	mov    0x10e6c0(,%eax,4),%edx
  1010e2:	8b 45 fc             	mov    -0x4(%ebp),%eax
  1010e5:	89 44 24 04          	mov    %eax,0x4(%esp)
  1010e9:	89 14 24             	mov    %edx,(%esp)
  1010ec:	e8 68 9a 00 00       	call   10ab59 <llist_remove>
      i--;
  1010f1:	83 6d fc 01          	subl   $0x1,-0x4(%ebp)
  1010f5:	eb 27                	jmp    10111e <interrupt_irq_check+0x77>
    }
    else proc_call(irqo->proc,irqo->func,1,irq);
  1010f7:	8b 45 f8             	mov    -0x8(%ebp),%eax
  1010fa:	8b 48 08             	mov    0x8(%eax),%ecx
  1010fd:	8b 45 f8             	mov    -0x8(%ebp),%eax
  101100:	8b 50 04             	mov    0x4(%eax),%edx
  101103:	8b 45 08             	mov    0x8(%ebp),%eax
  101106:	89 44 24 0c          	mov    %eax,0xc(%esp)
  10110a:	c7 44 24 08 01 00 00 	movl   $0x1,0x8(%esp)
  101111:	00 
  101112:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  101116:	89 14 24             	mov    %edx,(%esp)
  101119:	e8 a0 5e 00 00       	call   106fbe <proc_call>
 *  @param irq IRQ
 */
void interrupt_irq_check(unsigned int irq) {
  interrupt_irq_t *irqo;
  size_t i;
  for (i=0;(irqo = llist_get(interrupt_irq[irq],i));i++) {
  10111e:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
  101122:	8b 45 08             	mov    0x8(%ebp),%eax
  101125:	8b 14 85 c0 e6 10 00 	mov    0x10e6c0(,%eax,4),%edx
  10112c:	8b 45 fc             	mov    -0x4(%ebp),%eax
  10112f:	89 44 24 04          	mov    %eax,0x4(%esp)
  101133:	89 14 24             	mov    %edx,(%esp)
  101136:	e8 4c 99 00 00       	call   10aa87 <llist_get>
  10113b:	89 45 f8             	mov    %eax,-0x8(%ebp)
  10113e:	83 7d f8 00          	cmpl   $0x0,-0x8(%ebp)
  101142:	0f 85 6e ff ff ff    	jne    1010b6 <interrupt_irq_check+0xf>
      llist_remove(interrupt_irq[irq],i);
      i--;
    }
    else proc_call(irqo->proc,irqo->func,1,irq);
  }
}
  101148:	c9                   	leave  
  101149:	c3                   	ret    

0010114a <interrupt_time_sleep>:

/**
 * Sleeps until an time elapsed (Syscall)
 *  @param sec Seconds
 */
int interrupt_time_sleep(unsigned int sec) {
  10114a:	55                   	push   %ebp
  10114b:	89 e5                	mov    %esp,%ebp
  10114d:	83 ec 18             	sub    $0x18,%esp
  interrupt_sleep_t *new = malloc(sizeof(interrupt_sleep_t));
  101150:	c7 04 24 10 00 00 00 	movl   $0x10,(%esp)
  101157:	e8 0d 1e 00 00       	call   102f69 <malloc>
  10115c:	89 45 fc             	mov    %eax,-0x4(%ebp)
  new->type = TIME_SLEEP;
  10115f:	8b 45 fc             	mov    -0x4(%ebp),%eax
  101162:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
  new->usec = sec*1000000;
  101168:	8b 45 08             	mov    0x8(%ebp),%eax
  10116b:	69 c0 40 42 0f 00    	imul   $0xf4240,%eax,%eax
  101171:	ba 00 00 00 00       	mov    $0x0,%edx
  101176:	8b 4d fc             	mov    -0x4(%ebp),%ecx
  101179:	89 41 04             	mov    %eax,0x4(%ecx)
  10117c:	89 51 08             	mov    %edx,0x8(%ecx)
  new->proc = proc_current;
  10117f:	8b 15 a0 e1 10 00    	mov    0x10e1a0,%edx
  101185:	8b 45 fc             	mov    -0x4(%ebp),%eax
  101188:	89 50 0c             	mov    %edx,0xc(%eax)
  llist_push(interrupt_sleep,new);
  10118b:	8b 15 80 e4 10 00    	mov    0x10e480,%edx
  101191:	8b 45 fc             	mov    -0x4(%ebp),%eax
  101194:	89 44 24 04          	mov    %eax,0x4(%esp)
  101198:	89 14 24             	mov    %edx,(%esp)
  10119b:	e8 af 97 00 00       	call   10a94f <llist_push>
  proc_sleep(proc_current);
  1011a0:	a1 a0 e1 10 00       	mov    0x10e1a0,%eax
  1011a5:	89 04 24             	mov    %eax,(%esp)
  1011a8:	e8 74 54 00 00       	call   106621 <proc_sleep>
  return 0;
  1011ad:	b8 00 00 00 00       	mov    $0x0,%eax
}
  1011b2:	c9                   	leave  
  1011b3:	c3                   	ret    

001011b4 <interrupt_time_usleep>:

/**
 * Sleeps until an time elapsed (Syscall)
 *  @param sec Microseconds
 */
int interrupt_time_usleep(unsigned int usec) {
  1011b4:	55                   	push   %ebp
  1011b5:	89 e5                	mov    %esp,%ebp
  1011b7:	83 ec 18             	sub    $0x18,%esp
  interrupt_sleep_t *new = malloc(sizeof(interrupt_sleep_t));
  1011ba:	c7 04 24 10 00 00 00 	movl   $0x10,(%esp)
  1011c1:	e8 a3 1d 00 00       	call   102f69 <malloc>
  1011c6:	89 45 fc             	mov    %eax,-0x4(%ebp)
  new->type = TIME_SLEEP;
  1011c9:	8b 45 fc             	mov    -0x4(%ebp),%eax
  1011cc:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
  new->usec = usec;
  1011d2:	8b 45 08             	mov    0x8(%ebp),%eax
  1011d5:	ba 00 00 00 00       	mov    $0x0,%edx
  1011da:	8b 4d fc             	mov    -0x4(%ebp),%ecx
  1011dd:	89 41 04             	mov    %eax,0x4(%ecx)
  1011e0:	89 51 08             	mov    %edx,0x8(%ecx)
  new->proc = proc_current;
  1011e3:	8b 15 a0 e1 10 00    	mov    0x10e1a0,%edx
  1011e9:	8b 45 fc             	mov    -0x4(%ebp),%eax
  1011ec:	89 50 0c             	mov    %edx,0xc(%eax)
  llist_push(interrupt_sleep,new);
  1011ef:	8b 15 80 e4 10 00    	mov    0x10e480,%edx
  1011f5:	8b 45 fc             	mov    -0x4(%ebp),%eax
  1011f8:	89 44 24 04          	mov    %eax,0x4(%esp)
  1011fc:	89 14 24             	mov    %edx,(%esp)
  1011ff:	e8 4b 97 00 00       	call   10a94f <llist_push>
  proc_sleep(proc_current);
  101204:	a1 a0 e1 10 00       	mov    0x10e1a0,%eax
  101209:	89 04 24             	mov    %eax,(%esp)
  10120c:	e8 10 54 00 00       	call   106621 <proc_sleep>
  return 0;
  101211:	b8 00 00 00 00       	mov    $0x0,%eax
}
  101216:	c9                   	leave  
  101217:	c3                   	ret    

00101218 <interrupt_time_check>:

/**
 * Checks for ending sleeps
 *  @param usec Time since last check
 */
void interrupt_time_check(unsigned int usec) {
  101218:	55                   	push   %ebp
  101219:	89 e5                	mov    %esp,%ebp
  10121b:	57                   	push   %edi
  10121c:	56                   	push   %esi
  10121d:	53                   	push   %ebx
  10121e:	83 ec 2c             	sub    $0x2c,%esp
  interrupt_sleep_t *sleep;
  size_t i;
  for (i=0;(sleep = llist_get(interrupt_sleep,i));i++) {
  101221:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
  101228:	e9 91 00 00 00       	jmp    1012be <interrupt_time_check+0xa6>
    if (sleep->usec<=usec) {
  10122d:	8b 45 e8             	mov    -0x18(%ebp),%eax
  101230:	8b 50 04             	mov    0x4(%eax),%edx
  101233:	8b 48 08             	mov    0x8(%eax),%ecx
  101236:	89 55 d0             	mov    %edx,-0x30(%ebp)
  101239:	89 4d d4             	mov    %ecx,-0x2c(%ebp)
  10123c:	8b 75 08             	mov    0x8(%ebp),%esi
  10123f:	bf 00 00 00 00       	mov    $0x0,%edi
  101244:	89 75 d8             	mov    %esi,-0x28(%ebp)
  101247:	89 7d dc             	mov    %edi,-0x24(%ebp)
  10124a:	8b 7d dc             	mov    -0x24(%ebp),%edi
  10124d:	39 7d d4             	cmp    %edi,-0x2c(%ebp)
  101250:	77 42                	ja     101294 <interrupt_time_check+0x7c>
  101252:	8b 45 dc             	mov    -0x24(%ebp),%eax
  101255:	39 45 d4             	cmp    %eax,-0x2c(%ebp)
  101258:	72 08                	jb     101262 <interrupt_time_check+0x4a>
  10125a:	8b 55 d8             	mov    -0x28(%ebp),%edx
  10125d:	39 55 d0             	cmp    %edx,-0x30(%ebp)
  101260:	77 32                	ja     101294 <interrupt_time_check+0x7c>
      if (sleep->type==TIME_SLEEP) proc_wake(sleep->proc);
  101262:	8b 45 e8             	mov    -0x18(%ebp),%eax
  101265:	8b 00                	mov    (%eax),%eax
  101267:	85 c0                	test   %eax,%eax
  101269:	75 0e                	jne    101279 <interrupt_time_check+0x61>
  10126b:	8b 45 e8             	mov    -0x18(%ebp),%eax
  10126e:	8b 40 0c             	mov    0xc(%eax),%eax
  101271:	89 04 24             	mov    %eax,(%esp)
  101274:	e8 14 54 00 00       	call   10668d <proc_wake>
      llist_remove(interrupt_sleep,i);
  101279:	8b 15 80 e4 10 00    	mov    0x10e480,%edx
  10127f:	8b 45 ec             	mov    -0x14(%ebp),%eax
  101282:	89 44 24 04          	mov    %eax,0x4(%esp)
  101286:	89 14 24             	mov    %edx,(%esp)
  101289:	e8 cb 98 00 00       	call   10ab59 <llist_remove>
      i--;
  10128e:	83 6d ec 01          	subl   $0x1,-0x14(%ebp)
  101292:	eb 26                	jmp    1012ba <interrupt_time_check+0xa2>
    }
    else sleep->usec -= usec;
  101294:	8b 45 e8             	mov    -0x18(%ebp),%eax
  101297:	8b 48 04             	mov    0x4(%eax),%ecx
  10129a:	8b 58 08             	mov    0x8(%eax),%ebx
  10129d:	8b 45 08             	mov    0x8(%ebp),%eax
  1012a0:	ba 00 00 00 00       	mov    $0x0,%edx
  1012a5:	89 ce                	mov    %ecx,%esi
  1012a7:	89 df                	mov    %ebx,%edi
  1012a9:	29 c6                	sub    %eax,%esi
  1012ab:	19 d7                	sbb    %edx,%edi
  1012ad:	89 f0                	mov    %esi,%eax
  1012af:	89 fa                	mov    %edi,%edx
  1012b1:	8b 4d e8             	mov    -0x18(%ebp),%ecx
  1012b4:	89 41 04             	mov    %eax,0x4(%ecx)
  1012b7:	89 51 08             	mov    %edx,0x8(%ecx)
 *  @param usec Time since last check
 */
void interrupt_time_check(unsigned int usec) {
  interrupt_sleep_t *sleep;
  size_t i;
  for (i=0;(sleep = llist_get(interrupt_sleep,i));i++) {
  1012ba:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
  1012be:	a1 80 e4 10 00       	mov    0x10e480,%eax
  1012c3:	8b 55 ec             	mov    -0x14(%ebp),%edx
  1012c6:	89 54 24 04          	mov    %edx,0x4(%esp)
  1012ca:	89 04 24             	mov    %eax,(%esp)
  1012cd:	e8 b5 97 00 00       	call   10aa87 <llist_get>
  1012d2:	89 45 e8             	mov    %eax,-0x18(%ebp)
  1012d5:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
  1012d9:	0f 85 4e ff ff ff    	jne    10122d <interrupt_time_check+0x15>
      llist_remove(interrupt_sleep,i);
      i--;
    }
    else sleep->usec -= usec;
  }
}
  1012df:	83 c4 2c             	add    $0x2c,%esp
  1012e2:	5b                   	pop    %ebx
  1012e3:	5e                   	pop    %esi
  1012e4:	5f                   	pop    %edi
  1012e5:	5d                   	pop    %ebp
  1012e6:	c3                   	ret    

001012e7 <interrupt_time_getticks>:

/**
 * Gets number of ticks since boot
 *  @return Number of ticks
 */
clock_t interrupt_time_getticks() {
  1012e7:	55                   	push   %ebp
  1012e8:	89 e5                	mov    %esp,%ebp
  1012ea:	83 ec 08             	sub    $0x8,%esp
  return cpu_this->ticks;
  1012ed:	a1 54 e4 10 00       	mov    0x10e454,%eax
  1012f2:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  1012f9:	00 
  1012fa:	89 04 24             	mov    %eax,(%esp)
  1012fd:	e8 85 97 00 00       	call   10aa87 <llist_get>
  101302:	8b 40 5c             	mov    0x5c(%eax),%eax
}
  101305:	c9                   	leave  
  101306:	c3                   	ret    

00101307 <interrupt_save_stack>:

uint32_t *interrupt_save_stack(uint32_t *stack,uint32_t *errorcode) {
  101307:	55                   	push   %ebp
  101308:	89 e5                	mov    %esp,%ebp
  interrupt_curregs.edi = stack++;
  10130a:	8b 45 08             	mov    0x8(%ebp),%eax
  10130d:	a3 34 e7 10 00       	mov    %eax,0x10e734
  101312:	83 45 08 04          	addl   $0x4,0x8(%ebp)
  interrupt_curregs.esi = stack++;
  101316:	8b 45 08             	mov    0x8(%ebp),%eax
  101319:	a3 30 e7 10 00       	mov    %eax,0x10e730
  10131e:	83 45 08 04          	addl   $0x4,0x8(%ebp)
  interrupt_curregs.ebp = stack++;
  101322:	8b 45 08             	mov    0x8(%ebp),%eax
  101325:	a3 38 e7 10 00       	mov    %eax,0x10e738
  10132a:	83 45 08 04          	addl   $0x4,0x8(%ebp)
  stack++; // esp
  10132e:	83 45 08 04          	addl   $0x4,0x8(%ebp)
  interrupt_curregs.ebx = stack++;
  101332:	8b 45 08             	mov    0x8(%ebp),%eax
  101335:	a3 24 e7 10 00       	mov    %eax,0x10e724
  10133a:	83 45 08 04          	addl   $0x4,0x8(%ebp)
  interrupt_curregs.edx = stack++;
  10133e:	8b 45 08             	mov    0x8(%ebp),%eax
  101341:	a3 2c e7 10 00       	mov    %eax,0x10e72c
  101346:	83 45 08 04          	addl   $0x4,0x8(%ebp)
  interrupt_curregs.ecx = stack++;
  10134a:	8b 45 08             	mov    0x8(%ebp),%eax
  10134d:	a3 28 e7 10 00       	mov    %eax,0x10e728
  101352:	83 45 08 04          	addl   $0x4,0x8(%ebp)
  interrupt_curregs.eax = stack++;
  101356:	8b 45 08             	mov    0x8(%ebp),%eax
  101359:	a3 20 e7 10 00       	mov    %eax,0x10e720
  10135e:	83 45 08 04          	addl   $0x4,0x8(%ebp)
  interrupt_curregs.ds = stack++;
  101362:	8b 45 08             	mov    0x8(%ebp),%eax
  101365:	a3 4c e7 10 00       	mov    %eax,0x10e74c
  10136a:	83 45 08 04          	addl   $0x4,0x8(%ebp)
  interrupt_curregs.es = stack++;
  10136e:	8b 45 08             	mov    0x8(%ebp),%eax
  101371:	a3 50 e7 10 00       	mov    %eax,0x10e750
  101376:	83 45 08 04          	addl   $0x4,0x8(%ebp)
  interrupt_curregs.fs = stack++;
  10137a:	8b 45 08             	mov    0x8(%ebp),%eax
  10137d:	a3 54 e7 10 00       	mov    %eax,0x10e754
  101382:	83 45 08 04          	addl   $0x4,0x8(%ebp)
  interrupt_curregs.gs = stack++;
  101386:	8b 45 08             	mov    0x8(%ebp),%eax
  101389:	a3 58 e7 10 00       	mov    %eax,0x10e758
  10138e:	83 45 08 04          	addl   $0x4,0x8(%ebp)
  if (errorcode!=NULL) *errorcode = *stack++; // error code
  101392:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
  101396:	74 10                	je     1013a8 <interrupt_save_stack+0xa1>
  101398:	8b 45 08             	mov    0x8(%ebp),%eax
  10139b:	8b 10                	mov    (%eax),%edx
  10139d:	8b 45 0c             	mov    0xc(%ebp),%eax
  1013a0:	89 10                	mov    %edx,(%eax)
  1013a2:	83 45 08 04          	addl   $0x4,0x8(%ebp)
  1013a6:	eb 04                	jmp    1013ac <interrupt_save_stack+0xa5>
  else stack++;
  1013a8:	83 45 08 04          	addl   $0x4,0x8(%ebp)
  interrupt_curregs.eip = stack++;
  1013ac:	8b 45 08             	mov    0x8(%ebp),%eax
  1013af:	a3 40 e7 10 00       	mov    %eax,0x10e740
  1013b4:	83 45 08 04          	addl   $0x4,0x8(%ebp)
  interrupt_curregs.cs = stack++;
  1013b8:	8b 45 08             	mov    0x8(%ebp),%eax
  1013bb:	a3 48 e7 10 00       	mov    %eax,0x10e748
  1013c0:	83 45 08 04          	addl   $0x4,0x8(%ebp)
  interrupt_curregs.efl = stack++;
  1013c4:	8b 45 08             	mov    0x8(%ebp),%eax
  1013c7:	a3 44 e7 10 00       	mov    %eax,0x10e744
  1013cc:	83 45 08 04          	addl   $0x4,0x8(%ebp)
  interrupt_curregs.esp = stack++;
  1013d0:	8b 45 08             	mov    0x8(%ebp),%eax
  1013d3:	a3 3c e7 10 00       	mov    %eax,0x10e73c
  1013d8:	83 45 08 04          	addl   $0x4,0x8(%ebp)
  interrupt_curregs.ss = stack++;
  1013dc:	8b 45 08             	mov    0x8(%ebp),%eax
  1013df:	a3 5c e7 10 00       	mov    %eax,0x10e75c
  1013e4:	83 45 08 04          	addl   $0x4,0x8(%ebp)
  vm86_curregs.es = stack++;
  1013e8:	8b 45 08             	mov    0x8(%ebp),%eax
  1013eb:	a3 a4 e1 10 00       	mov    %eax,0x10e1a4
  1013f0:	83 45 08 04          	addl   $0x4,0x8(%ebp)
  vm86_curregs.ds = stack++;
  1013f4:	8b 45 08             	mov    0x8(%ebp),%eax
  1013f7:	a3 a8 e1 10 00       	mov    %eax,0x10e1a8
  1013fc:	83 45 08 04          	addl   $0x4,0x8(%ebp)
  vm86_curregs.fs = stack++;
  101400:	8b 45 08             	mov    0x8(%ebp),%eax
  101403:	a3 ac e1 10 00       	mov    %eax,0x10e1ac
  101408:	83 45 08 04          	addl   $0x4,0x8(%ebp)
  vm86_curregs.gs = stack++;
  10140c:	8b 45 08             	mov    0x8(%ebp),%eax
  10140f:	a3 b0 e1 10 00       	mov    %eax,0x10e1b0
  101414:	83 45 08 04          	addl   $0x4,0x8(%ebp)
kprintf("ES:  0x%x\n",*interrupt_curregs.es);
kprintf("FS:  0x%x\n",*interrupt_curregs.fs);
kprintf("GS:  0x%x\n",*interrupt_curregs.gs);
kprintf("SS:  0x%x\n",*interrupt_curregs.ss);*/

  return stack;
  101418:	8b 45 08             	mov    0x8(%ebp),%eax
}
  10141b:	5d                   	pop    %ebp
  10141c:	c3                   	ret    
  10141d:	00 00                	add    %al,(%eax)
	...

00101420 <ioport_init>:

#include <sys/types.h>
#include <ioport.h>
#include <syscall.h>

int ioport_init() {
  101420:	55                   	push   %ebp
  101421:	89 e5                	mov    %esp,%ebp
  101423:	83 ec 18             	sub    $0x18,%esp
  iopb_general = malloc(IOPORT_MAXNUM/sizeof(*iopb_general));
  101426:	c7 04 24 00 40 00 00 	movl   $0x4000,(%esp)
  10142d:	e8 37 1b 00 00       	call   102f69 <malloc>
  101432:	a3 24 e9 10 00       	mov    %eax,0x10e924
  if (syscall_create(SYSCALL_IO_REG,ioport_reg,1)==-1) return -1;
  101437:	c7 44 24 08 01 00 00 	movl   $0x1,0x8(%esp)
  10143e:	00 
  10143f:	c7 44 24 04 97 14 10 	movl   $0x101497,0x4(%esp)
  101446:	00 
  101447:	c7 04 24 44 00 00 00 	movl   $0x44,(%esp)
  10144e:	e8 e7 89 00 00       	call   109e3a <syscall_create>
  101453:	83 f8 ff             	cmp    $0xffffffff,%eax
  101456:	75 09                	jne    101461 <ioport_init+0x41>
  101458:	c7 45 fc ff ff ff ff 	movl   $0xffffffff,-0x4(%ebp)
  10145f:	eb 31                	jmp    101492 <ioport_init+0x72>
  if (syscall_create(SYSCALL_IO_UNREG,ioport_unreg,1)==-1) return -1;
  101461:	c7 44 24 08 01 00 00 	movl   $0x1,0x8(%esp)
  101468:	00 
  101469:	c7 44 24 04 a1 14 10 	movl   $0x1014a1,0x4(%esp)
  101470:	00 
  101471:	c7 04 24 45 00 00 00 	movl   $0x45,(%esp)
  101478:	e8 bd 89 00 00       	call   109e3a <syscall_create>
  10147d:	83 f8 ff             	cmp    $0xffffffff,%eax
  101480:	75 09                	jne    10148b <ioport_init+0x6b>
  101482:	c7 45 fc ff ff ff ff 	movl   $0xffffffff,-0x4(%ebp)
  101489:	eb 07                	jmp    101492 <ioport_init+0x72>
  return 0;
  10148b:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
  101492:	8b 45 fc             	mov    -0x4(%ebp),%eax
}
  101495:	c9                   	leave  
  101496:	c3                   	ret    

00101497 <ioport_reg>:

int ioport_reg(unsigned int port) {
  101497:	55                   	push   %ebp
  101498:	89 e5                	mov    %esp,%ebp
  if (proc_current->iopb==NULL) return -EPERM;
  if (IOPORT_ISREG(iopb_general,port)) return -EEXIST;

  IOPORT_REG(iopb_general,port);
  IOPORT_REG(proc_current->iopb,port);*/
  return 0;
  10149a:	b8 00 00 00 00       	mov    $0x0,%eax
}
  10149f:	5d                   	pop    %ebp
  1014a0:	c3                   	ret    

001014a1 <ioport_unreg>:

int ioport_unreg(unsigned int port) {
  1014a1:	55                   	push   %ebp
  1014a2:	89 e5                	mov    %esp,%ebp
  if (proc_current->iopb==NULL) return -EPERM;
  if (!IOPORT_ISREG(proc_current->iopb,port)) return -EPERM;

  IOPORT_UNREG(iopb_general,port);
  IOPORT_UNREG(proc_current->iopb,port);*/
  return 0;
  1014a4:	b8 00 00 00 00       	mov    $0x0,%eax
}
  1014a9:	5d                   	pop    %ebp
  1014aa:	c3                   	ret    
	...

001014ac <ipc_init>:

/**
 * Initializes IPC
 *  @return Success?
 */
int ipc_init() {
  1014ac:	55                   	push   %ebp
  1014ad:	89 e5                	mov    %esp,%ebp
  1014af:	83 ec 08             	sub    $0x8,%esp
  ipc_objects = llist_create();
  1014b2:	e8 1d 94 00 00       	call   10a8d4 <llist_create>
  1014b7:	a3 90 e1 10 00       	mov    %eax,0x10e190
  ipc_lastid = 0;
  1014bc:	c7 05 98 e1 10 00 00 	movl   $0x0,0x10e198
  1014c3:	00 00 00 
  if (ipc_msg_init()==-1) return -1;
  1014c6:	e8 69 30 00 00       	call   104534 <ipc_msg_init>
  1014cb:	83 f8 ff             	cmp    $0xffffffff,%eax
  1014ce:	75 09                	jne    1014d9 <ipc_init+0x2d>
  1014d0:	c7 45 fc ff ff ff ff 	movl   $0xffffffff,-0x4(%ebp)
  1014d7:	eb 2d                	jmp    101506 <ipc_init+0x5a>
  if (ipc_sem_init()==-1) return -1;
  1014d9:	e8 06 6b 00 00       	call   107fe4 <ipc_sem_init>
  1014de:	83 f8 ff             	cmp    $0xffffffff,%eax
  1014e1:	75 09                	jne    1014ec <ipc_init+0x40>
  1014e3:	c7 45 fc ff ff ff ff 	movl   $0xffffffff,-0x4(%ebp)
  1014ea:	eb 1a                	jmp    101506 <ipc_init+0x5a>
  if (ipc_shm_init()==-1) return -1;
  1014ec:	e8 6b 7b 00 00       	call   10905c <ipc_shm_init>
  1014f1:	83 f8 ff             	cmp    $0xffffffff,%eax
  1014f4:	75 09                	jne    1014ff <ipc_init+0x53>
  1014f6:	c7 45 fc ff ff ff ff 	movl   $0xffffffff,-0x4(%ebp)
  1014fd:	eb 07                	jmp    101506 <ipc_init+0x5a>
  return 0;
  1014ff:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
  101506:	8b 45 fc             	mov    -0x4(%ebp),%eax
}
  101509:	c9                   	leave  
  10150a:	c3                   	ret    

0010150b <ipc_find>:
 * Finds an IPC object
 *  @param key IPC Key
 *  @param id IPC object's ID
 *  @return IPC object
 */
void *ipc_find(key_t key,id_t id,int type) {
  10150b:	55                   	push   %ebp
  10150c:	89 e5                	mov    %esp,%ebp
  10150e:	83 ec 28             	sub    $0x28,%esp
  size_t i;
  ipc_obj_t *ipc;
  for (i=0;(ipc = llist_get(ipc_objects,i));i++) {
  101511:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
  101518:	eb 38                	jmp    101552 <ipc_find+0x47>
    if (ipc->type==type) {
  10151a:	8b 45 fc             	mov    -0x4(%ebp),%eax
  10151d:	8b 00                	mov    (%eax),%eax
  10151f:	3b 45 10             	cmp    0x10(%ebp),%eax
  101522:	75 2a                	jne    10154e <ipc_find+0x43>
      if ((ipc->key==key || key==-1) && (ipc->id==id || id==-1)) return ipc;
  101524:	8b 45 fc             	mov    -0x4(%ebp),%eax
  101527:	8b 40 08             	mov    0x8(%eax),%eax
  10152a:	3b 45 08             	cmp    0x8(%ebp),%eax
  10152d:	74 06                	je     101535 <ipc_find+0x2a>
  10152f:	83 7d 08 ff          	cmpl   $0xffffffff,0x8(%ebp)
  101533:	75 19                	jne    10154e <ipc_find+0x43>
  101535:	8b 45 fc             	mov    -0x4(%ebp),%eax
  101538:	8b 40 04             	mov    0x4(%eax),%eax
  10153b:	3b 45 0c             	cmp    0xc(%ebp),%eax
  10153e:	74 06                	je     101546 <ipc_find+0x3b>
  101540:	83 7d 0c ff          	cmpl   $0xffffffff,0xc(%ebp)
  101544:	75 08                	jne    10154e <ipc_find+0x43>
  101546:	8b 45 fc             	mov    -0x4(%ebp),%eax
  101549:	89 45 ec             	mov    %eax,-0x14(%ebp)
  10154c:	eb 28                	jmp    101576 <ipc_find+0x6b>
 *  @return IPC object
 */
void *ipc_find(key_t key,id_t id,int type) {
  size_t i;
  ipc_obj_t *ipc;
  for (i=0;(ipc = llist_get(ipc_objects,i));i++) {
  10154e:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
  101552:	a1 90 e1 10 00       	mov    0x10e190,%eax
  101557:	8b 55 f8             	mov    -0x8(%ebp),%edx
  10155a:	89 54 24 04          	mov    %edx,0x4(%esp)
  10155e:	89 04 24             	mov    %eax,(%esp)
  101561:	e8 21 95 00 00       	call   10aa87 <llist_get>
  101566:	89 45 fc             	mov    %eax,-0x4(%ebp)
  101569:	83 7d fc 00          	cmpl   $0x0,-0x4(%ebp)
  10156d:	75 ab                	jne    10151a <ipc_find+0xf>
    if (ipc->type==type) {
      if ((ipc->key==key || key==-1) && (ipc->id==id || id==-1)) return ipc;
    }
  }
  return NULL;
  10156f:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
  101576:	8b 45 ec             	mov    -0x14(%ebp),%eax
}
  101579:	c9                   	leave  
  10157a:	c3                   	ret    
  10157b:	00 00                	add    %al,(%eax)
  10157d:	00 00                	add    %al,(%eax)
	...

00101580 <reg_eax>:
  101580:	00 00                	add    %al,(%eax)
	...

00101584 <reg_eip>:
  101584:	00 00                	add    %al,(%eax)
	...

00101588 <reg_esp>:
  101588:	00 00                	add    %al,(%eax)
	...

0010158c <reg_efl>:
  10158c:	00 00                	add    %al,(%eax)
	...

00101590 <reg_cs>:
	...

00101592 <reg_ds>:
	...

00101594 <reg_ss>:
	...

00101596 <reg_kernelesp>:
  101596:	00 00                	add    %al,(%eax)
	...

0010159a <isr_uselapic>:
  10159a:	00 00 00 00                                         ....

0010159e <isr>:
  10159e:	a2 15 10 00                                         ....

001015a2 <isr_table>:
  1015a2:	82                   	(bad)  
  1015a3:	16                   	push   %ss
  1015a4:	10 00                	adc    %al,(%eax)
  1015a6:	ad                   	lods   %ds:(%esi),%eax
  1015a7:	16                   	push   %ss
  1015a8:	10 00                	adc    %al,(%eax)
  1015aa:	d8 16                	fcoms  (%esi)
  1015ac:	10 00                	adc    %al,(%eax)
  1015ae:	03 17                	add    (%edi),%edx
  1015b0:	10 00                	adc    %al,(%eax)
  1015b2:	2e                   	cs
  1015b3:	17                   	pop    %ss
  1015b4:	10 00                	adc    %al,(%eax)
  1015b6:	59                   	pop    %ecx
  1015b7:	17                   	pop    %ss
  1015b8:	10 00                	adc    %al,(%eax)
  1015ba:	84 17                	test   %dl,(%edi)
  1015bc:	10 00                	adc    %al,(%eax)
  1015be:	af                   	scas   %es:(%edi),%eax
  1015bf:	17                   	pop    %ss
  1015c0:	10 00                	adc    %al,(%eax)
  1015c2:	da 17                	ficoml (%edi)
  1015c4:	10 00                	adc    %al,(%eax)
  1015c6:	00 18                	add    %bl,(%eax)
  1015c8:	10 00                	adc    %al,(%eax)
  1015ca:	2b 18                	sub    (%eax),%ebx
  1015cc:	10 00                	adc    %al,(%eax)
  1015ce:	51                   	push   %ecx
  1015cf:	18 10                	sbb    %dl,(%eax)
  1015d1:	00 77 18             	add    %dh,0x18(%edi)
  1015d4:	10 00                	adc    %al,(%eax)
  1015d6:	9d                   	popf   
  1015d7:	18 10                	sbb    %dl,(%eax)
  1015d9:	00 c3                	add    %al,%bl
  1015db:	18 10                	sbb    %dl,(%eax)
  1015dd:	00 e9                	add    %ch,%cl
  1015df:	18 10                	sbb    %dl,(%eax)
  1015e1:	00 14 19             	add    %dl,(%ecx,%ebx,1)
  1015e4:	10 00                	adc    %al,(%eax)
  1015e6:	3f                   	aas    
  1015e7:	19 10                	sbb    %edx,(%eax)
  1015e9:	00 6a 19             	add    %ch,0x19(%edx)
  1015ec:	10 00                	adc    %al,(%eax)
  1015ee:	95                   	xchg   %eax,%ebp
  1015ef:	19 10                	sbb    %edx,(%eax)
  1015f1:	00 c0                	add    %al,%al
  1015f3:	19 10                	sbb    %edx,(%eax)
  1015f5:	00 eb                	add    %ch,%bl
  1015f7:	19 10                	sbb    %edx,(%eax)
  1015f9:	00 16                	add    %dl,(%esi)
  1015fb:	1a 10                	sbb    (%eax),%dl
  1015fd:	00 41 1a             	add    %al,0x1a(%ecx)
  101600:	10 00                	adc    %al,(%eax)
  101602:	6c                   	insb   (%dx),%es:(%edi)
  101603:	1a 10                	sbb    (%eax),%dl
  101605:	00 97 1a 10 00 c2    	add    %dl,-0x3dffefe6(%edi)
  10160b:	1a 10                	sbb    (%eax),%dl
  10160d:	00 ed                	add    %ch,%ch
  10160f:	1a 10                	sbb    (%eax),%dl
  101611:	00 18                	add    %bl,(%eax)
  101613:	1b 10                	sbb    (%eax),%edx
  101615:	00 43 1b             	add    %al,0x1b(%ebx)
  101618:	10 00                	adc    %al,(%eax)
  10161a:	6e                   	outsb  %ds:(%esi),(%dx)
  10161b:	1b 10                	sbb    (%eax),%edx
  10161d:	00 99 1b 10 00 c4    	add    %bl,-0x3bffefe5(%ecx)
  101623:	1b 10                	sbb    (%eax),%edx
  101625:	00 db                	add    %bl,%bl
  101627:	1b 10                	sbb    (%eax),%edx
  101629:	00 06                	add    %al,(%esi)
  10162b:	1c 10                	sbb    $0x10,%al
  10162d:	00 31                	add    %dh,(%ecx)
  10162f:	1c 10                	sbb    $0x10,%al
  101631:	00 5c 1c 10          	add    %bl,0x10(%esp,%ebx,1)
  101635:	00 87 1c 10 00 b2    	add    %al,-0x4dffefe4(%edi)
  10163b:	1c 10                	sbb    $0x10,%al
  10163d:	00 dd                	add    %bl,%ch
  10163f:	1c 10                	sbb    $0x10,%al
  101641:	00 08                	add    %cl,(%eax)
  101643:	1d 10 00 33 1d       	sbb    $0x1d330010,%eax
  101648:	10 00                	adc    %al,(%eax)
  10164a:	5e                   	pop    %esi
  10164b:	1d 10 00 89 1d       	sbb    $0x1d890010,%eax
  101650:	10 00                	adc    %al,(%eax)
  101652:	b4 1d                	mov    $0x1d,%ah
  101654:	10 00                	adc    %al,(%eax)
  101656:	df 1d 10 00 0a 1e    	fistp  0x1e0a0010
  10165c:	10 00                	adc    %al,(%eax)
  10165e:	35 1e 10 00 60       	xor    $0x6000101e,%eax
  101663:	1e                   	push   %ds
  101664:	10 00                	adc    %al,(%eax)
  101666:	8b 1e                	mov    (%esi),%ebx
  101668:	10 00                	adc    %al,(%eax)
  10166a:	b6 1e                	mov    $0x1e,%dh
  10166c:	10 00                	adc    %al,(%eax)
  10166e:	e1 1e                	loope  10168e <isr00+0xc>
  101670:	10 00                	adc    %al,(%eax)
  101672:	0c 1f                	or     $0x1f,%al
  101674:	10 00                	adc    %al,(%eax)
  101676:	37                   	aaa    
  101677:	1f                   	pop    %ds
  101678:	10 00                	adc    %al,(%eax)
  10167a:	62 1f                	bound  %ebx,(%edi)
  10167c:	10 00                	adc    %al,(%eax)
  10167e:	8d 1f                	lea    (%edi),%ebx
  101680:	10 00                	adc    %al,(%eax)

00101682 <isr00>:
  101682:	68 00 00 00 00       	push   $0x0
  101687:	1e                   	push   %ds
  101688:	06                   	push   %es
  101689:	0f a0                	push   %fs
  10168b:	0f a8                	push   %gs
  10168d:	60                   	pusha  
  10168e:	54                   	push   %esp
  10168f:	68 00 00 00 00       	push   $0x0
  101694:	e8 3c f4 ff ff       	call   100ad5 <interrupt_handler>
  101699:	81 c4 08 00 00 00    	add    $0x8,%esp
  10169f:	61                   	popa   
  1016a0:	1f                   	pop    %ds
  1016a1:	07                   	pop    %es
  1016a2:	0f a1                	pop    %fs
  1016a4:	0f a9                	pop    %gs
  1016a6:	81 c4 04 00 00 00    	add    $0x4,%esp
  1016ac:	cf                   	iret   

001016ad <isr01>:
  1016ad:	68 00 00 00 00       	push   $0x0
  1016b2:	1e                   	push   %ds
  1016b3:	06                   	push   %es
  1016b4:	0f a0                	push   %fs
  1016b6:	0f a8                	push   %gs
  1016b8:	60                   	pusha  
  1016b9:	54                   	push   %esp
  1016ba:	68 01 00 00 00       	push   $0x1
  1016bf:	e8 11 f4 ff ff       	call   100ad5 <interrupt_handler>
  1016c4:	81 c4 08 00 00 00    	add    $0x8,%esp
  1016ca:	61                   	popa   
  1016cb:	1f                   	pop    %ds
  1016cc:	07                   	pop    %es
  1016cd:	0f a1                	pop    %fs
  1016cf:	0f a9                	pop    %gs
  1016d1:	81 c4 04 00 00 00    	add    $0x4,%esp
  1016d7:	cf                   	iret   

001016d8 <isr02>:
  1016d8:	68 00 00 00 00       	push   $0x0
  1016dd:	1e                   	push   %ds
  1016de:	06                   	push   %es
  1016df:	0f a0                	push   %fs
  1016e1:	0f a8                	push   %gs
  1016e3:	60                   	pusha  
  1016e4:	54                   	push   %esp
  1016e5:	68 02 00 00 00       	push   $0x2
  1016ea:	e8 e6 f3 ff ff       	call   100ad5 <interrupt_handler>
  1016ef:	81 c4 08 00 00 00    	add    $0x8,%esp
  1016f5:	61                   	popa   
  1016f6:	1f                   	pop    %ds
  1016f7:	07                   	pop    %es
  1016f8:	0f a1                	pop    %fs
  1016fa:	0f a9                	pop    %gs
  1016fc:	81 c4 04 00 00 00    	add    $0x4,%esp
  101702:	cf                   	iret   

00101703 <isr03>:
  101703:	68 00 00 00 00       	push   $0x0
  101708:	1e                   	push   %ds
  101709:	06                   	push   %es
  10170a:	0f a0                	push   %fs
  10170c:	0f a8                	push   %gs
  10170e:	60                   	pusha  
  10170f:	54                   	push   %esp
  101710:	68 03 00 00 00       	push   $0x3
  101715:	e8 bb f3 ff ff       	call   100ad5 <interrupt_handler>
  10171a:	81 c4 08 00 00 00    	add    $0x8,%esp
  101720:	61                   	popa   
  101721:	1f                   	pop    %ds
  101722:	07                   	pop    %es
  101723:	0f a1                	pop    %fs
  101725:	0f a9                	pop    %gs
  101727:	81 c4 04 00 00 00    	add    $0x4,%esp
  10172d:	cf                   	iret   

0010172e <isr04>:
  10172e:	68 00 00 00 00       	push   $0x0
  101733:	1e                   	push   %ds
  101734:	06                   	push   %es
  101735:	0f a0                	push   %fs
  101737:	0f a8                	push   %gs
  101739:	60                   	pusha  
  10173a:	54                   	push   %esp
  10173b:	68 04 00 00 00       	push   $0x4
  101740:	e8 90 f3 ff ff       	call   100ad5 <interrupt_handler>
  101745:	81 c4 08 00 00 00    	add    $0x8,%esp
  10174b:	61                   	popa   
  10174c:	1f                   	pop    %ds
  10174d:	07                   	pop    %es
  10174e:	0f a1                	pop    %fs
  101750:	0f a9                	pop    %gs
  101752:	81 c4 04 00 00 00    	add    $0x4,%esp
  101758:	cf                   	iret   

00101759 <isr05>:
  101759:	68 00 00 00 00       	push   $0x0
  10175e:	1e                   	push   %ds
  10175f:	06                   	push   %es
  101760:	0f a0                	push   %fs
  101762:	0f a8                	push   %gs
  101764:	60                   	pusha  
  101765:	54                   	push   %esp
  101766:	68 05 00 00 00       	push   $0x5
  10176b:	e8 65 f3 ff ff       	call   100ad5 <interrupt_handler>
  101770:	81 c4 08 00 00 00    	add    $0x8,%esp
  101776:	61                   	popa   
  101777:	1f                   	pop    %ds
  101778:	07                   	pop    %es
  101779:	0f a1                	pop    %fs
  10177b:	0f a9                	pop    %gs
  10177d:	81 c4 04 00 00 00    	add    $0x4,%esp
  101783:	cf                   	iret   

00101784 <isr06>:
  101784:	68 00 00 00 00       	push   $0x0
  101789:	1e                   	push   %ds
  10178a:	06                   	push   %es
  10178b:	0f a0                	push   %fs
  10178d:	0f a8                	push   %gs
  10178f:	60                   	pusha  
  101790:	54                   	push   %esp
  101791:	68 06 00 00 00       	push   $0x6
  101796:	e8 3a f3 ff ff       	call   100ad5 <interrupt_handler>
  10179b:	81 c4 08 00 00 00    	add    $0x8,%esp
  1017a1:	61                   	popa   
  1017a2:	1f                   	pop    %ds
  1017a3:	07                   	pop    %es
  1017a4:	0f a1                	pop    %fs
  1017a6:	0f a9                	pop    %gs
  1017a8:	81 c4 04 00 00 00    	add    $0x4,%esp
  1017ae:	cf                   	iret   

001017af <isr07>:
  1017af:	68 00 00 00 00       	push   $0x0
  1017b4:	1e                   	push   %ds
  1017b5:	06                   	push   %es
  1017b6:	0f a0                	push   %fs
  1017b8:	0f a8                	push   %gs
  1017ba:	60                   	pusha  
  1017bb:	54                   	push   %esp
  1017bc:	68 07 00 00 00       	push   $0x7
  1017c1:	e8 0f f3 ff ff       	call   100ad5 <interrupt_handler>
  1017c6:	81 c4 08 00 00 00    	add    $0x8,%esp
  1017cc:	61                   	popa   
  1017cd:	1f                   	pop    %ds
  1017ce:	07                   	pop    %es
  1017cf:	0f a1                	pop    %fs
  1017d1:	0f a9                	pop    %gs
  1017d3:	81 c4 04 00 00 00    	add    $0x4,%esp
  1017d9:	cf                   	iret   

001017da <isr08>:
  1017da:	1e                   	push   %ds
  1017db:	06                   	push   %es
  1017dc:	0f a0                	push   %fs
  1017de:	0f a8                	push   %gs
  1017e0:	60                   	pusha  
  1017e1:	54                   	push   %esp
  1017e2:	68 08 00 00 00       	push   $0x8
  1017e7:	e8 e9 f2 ff ff       	call   100ad5 <interrupt_handler>
  1017ec:	81 c4 08 00 00 00    	add    $0x8,%esp
  1017f2:	61                   	popa   
  1017f3:	1f                   	pop    %ds
  1017f4:	07                   	pop    %es
  1017f5:	0f a1                	pop    %fs
  1017f7:	0f a9                	pop    %gs
  1017f9:	81 c4 04 00 00 00    	add    $0x4,%esp
  1017ff:	cf                   	iret   

00101800 <isr09>:
  101800:	68 00 00 00 00       	push   $0x0
  101805:	1e                   	push   %ds
  101806:	06                   	push   %es
  101807:	0f a0                	push   %fs
  101809:	0f a8                	push   %gs
  10180b:	60                   	pusha  
  10180c:	54                   	push   %esp
  10180d:	68 09 00 00 00       	push   $0x9
  101812:	e8 be f2 ff ff       	call   100ad5 <interrupt_handler>
  101817:	81 c4 08 00 00 00    	add    $0x8,%esp
  10181d:	61                   	popa   
  10181e:	1f                   	pop    %ds
  10181f:	07                   	pop    %es
  101820:	0f a1                	pop    %fs
  101822:	0f a9                	pop    %gs
  101824:	81 c4 04 00 00 00    	add    $0x4,%esp
  10182a:	cf                   	iret   

0010182b <isr0A>:
  10182b:	1e                   	push   %ds
  10182c:	06                   	push   %es
  10182d:	0f a0                	push   %fs
  10182f:	0f a8                	push   %gs
  101831:	60                   	pusha  
  101832:	54                   	push   %esp
  101833:	68 0a 00 00 00       	push   $0xa
  101838:	e8 98 f2 ff ff       	call   100ad5 <interrupt_handler>
  10183d:	81 c4 08 00 00 00    	add    $0x8,%esp
  101843:	61                   	popa   
  101844:	1f                   	pop    %ds
  101845:	07                   	pop    %es
  101846:	0f a1                	pop    %fs
  101848:	0f a9                	pop    %gs
  10184a:	81 c4 04 00 00 00    	add    $0x4,%esp
  101850:	cf                   	iret   

00101851 <isr0B>:
  101851:	1e                   	push   %ds
  101852:	06                   	push   %es
  101853:	0f a0                	push   %fs
  101855:	0f a8                	push   %gs
  101857:	60                   	pusha  
  101858:	54                   	push   %esp
  101859:	68 0b 00 00 00       	push   $0xb
  10185e:	e8 72 f2 ff ff       	call   100ad5 <interrupt_handler>
  101863:	81 c4 08 00 00 00    	add    $0x8,%esp
  101869:	61                   	popa   
  10186a:	1f                   	pop    %ds
  10186b:	07                   	pop    %es
  10186c:	0f a1                	pop    %fs
  10186e:	0f a9                	pop    %gs
  101870:	81 c4 04 00 00 00    	add    $0x4,%esp
  101876:	cf                   	iret   

00101877 <isr0C>:
  101877:	1e                   	push   %ds
  101878:	06                   	push   %es
  101879:	0f a0                	push   %fs
  10187b:	0f a8                	push   %gs
  10187d:	60                   	pusha  
  10187e:	54                   	push   %esp
  10187f:	68 0c 00 00 00       	push   $0xc
  101884:	e8 4c f2 ff ff       	call   100ad5 <interrupt_handler>
  101889:	81 c4 08 00 00 00    	add    $0x8,%esp
  10188f:	61                   	popa   
  101890:	1f                   	pop    %ds
  101891:	07                   	pop    %es
  101892:	0f a1                	pop    %fs
  101894:	0f a9                	pop    %gs
  101896:	81 c4 04 00 00 00    	add    $0x4,%esp
  10189c:	cf                   	iret   

0010189d <isr0D>:
  10189d:	1e                   	push   %ds
  10189e:	06                   	push   %es
  10189f:	0f a0                	push   %fs
  1018a1:	0f a8                	push   %gs
  1018a3:	60                   	pusha  
  1018a4:	54                   	push   %esp
  1018a5:	68 0d 00 00 00       	push   $0xd
  1018aa:	e8 26 f2 ff ff       	call   100ad5 <interrupt_handler>
  1018af:	81 c4 08 00 00 00    	add    $0x8,%esp
  1018b5:	61                   	popa   
  1018b6:	1f                   	pop    %ds
  1018b7:	07                   	pop    %es
  1018b8:	0f a1                	pop    %fs
  1018ba:	0f a9                	pop    %gs
  1018bc:	81 c4 04 00 00 00    	add    $0x4,%esp
  1018c2:	cf                   	iret   

001018c3 <isr0E>:
  1018c3:	1e                   	push   %ds
  1018c4:	06                   	push   %es
  1018c5:	0f a0                	push   %fs
  1018c7:	0f a8                	push   %gs
  1018c9:	60                   	pusha  
  1018ca:	54                   	push   %esp
  1018cb:	68 0e 00 00 00       	push   $0xe
  1018d0:	e8 00 f2 ff ff       	call   100ad5 <interrupt_handler>
  1018d5:	81 c4 08 00 00 00    	add    $0x8,%esp
  1018db:	61                   	popa   
  1018dc:	1f                   	pop    %ds
  1018dd:	07                   	pop    %es
  1018de:	0f a1                	pop    %fs
  1018e0:	0f a9                	pop    %gs
  1018e2:	81 c4 04 00 00 00    	add    $0x4,%esp
  1018e8:	cf                   	iret   

001018e9 <isr0F>:
  1018e9:	68 00 00 00 00       	push   $0x0
  1018ee:	1e                   	push   %ds
  1018ef:	06                   	push   %es
  1018f0:	0f a0                	push   %fs
  1018f2:	0f a8                	push   %gs
  1018f4:	60                   	pusha  
  1018f5:	54                   	push   %esp
  1018f6:	68 0f 00 00 00       	push   $0xf
  1018fb:	e8 d5 f1 ff ff       	call   100ad5 <interrupt_handler>
  101900:	81 c4 08 00 00 00    	add    $0x8,%esp
  101906:	61                   	popa   
  101907:	1f                   	pop    %ds
  101908:	07                   	pop    %es
  101909:	0f a1                	pop    %fs
  10190b:	0f a9                	pop    %gs
  10190d:	81 c4 04 00 00 00    	add    $0x4,%esp
  101913:	cf                   	iret   

00101914 <isr10>:
  101914:	68 00 00 00 00       	push   $0x0
  101919:	1e                   	push   %ds
  10191a:	06                   	push   %es
  10191b:	0f a0                	push   %fs
  10191d:	0f a8                	push   %gs
  10191f:	60                   	pusha  
  101920:	54                   	push   %esp
  101921:	68 10 00 00 00       	push   $0x10
  101926:	e8 aa f1 ff ff       	call   100ad5 <interrupt_handler>
  10192b:	81 c4 08 00 00 00    	add    $0x8,%esp
  101931:	61                   	popa   
  101932:	1f                   	pop    %ds
  101933:	07                   	pop    %es
  101934:	0f a1                	pop    %fs
  101936:	0f a9                	pop    %gs
  101938:	81 c4 04 00 00 00    	add    $0x4,%esp
  10193e:	cf                   	iret   

0010193f <isr11>:
  10193f:	68 00 00 00 00       	push   $0x0
  101944:	1e                   	push   %ds
  101945:	06                   	push   %es
  101946:	0f a0                	push   %fs
  101948:	0f a8                	push   %gs
  10194a:	60                   	pusha  
  10194b:	54                   	push   %esp
  10194c:	68 11 00 00 00       	push   $0x11
  101951:	e8 7f f1 ff ff       	call   100ad5 <interrupt_handler>
  101956:	81 c4 08 00 00 00    	add    $0x8,%esp
  10195c:	61                   	popa   
  10195d:	1f                   	pop    %ds
  10195e:	07                   	pop    %es
  10195f:	0f a1                	pop    %fs
  101961:	0f a9                	pop    %gs
  101963:	81 c4 04 00 00 00    	add    $0x4,%esp
  101969:	cf                   	iret   

0010196a <isr12>:
  10196a:	68 00 00 00 00       	push   $0x0
  10196f:	1e                   	push   %ds
  101970:	06                   	push   %es
  101971:	0f a0                	push   %fs
  101973:	0f a8                	push   %gs
  101975:	60                   	pusha  
  101976:	54                   	push   %esp
  101977:	68 12 00 00 00       	push   $0x12
  10197c:	e8 54 f1 ff ff       	call   100ad5 <interrupt_handler>
  101981:	81 c4 08 00 00 00    	add    $0x8,%esp
  101987:	61                   	popa   
  101988:	1f                   	pop    %ds
  101989:	07                   	pop    %es
  10198a:	0f a1                	pop    %fs
  10198c:	0f a9                	pop    %gs
  10198e:	81 c4 04 00 00 00    	add    $0x4,%esp
  101994:	cf                   	iret   

00101995 <isr13>:
  101995:	68 00 00 00 00       	push   $0x0
  10199a:	1e                   	push   %ds
  10199b:	06                   	push   %es
  10199c:	0f a0                	push   %fs
  10199e:	0f a8                	push   %gs
  1019a0:	60                   	pusha  
  1019a1:	54                   	push   %esp
  1019a2:	68 13 00 00 00       	push   $0x13
  1019a7:	e8 29 f1 ff ff       	call   100ad5 <interrupt_handler>
  1019ac:	81 c4 08 00 00 00    	add    $0x8,%esp
  1019b2:	61                   	popa   
  1019b3:	1f                   	pop    %ds
  1019b4:	07                   	pop    %es
  1019b5:	0f a1                	pop    %fs
  1019b7:	0f a9                	pop    %gs
  1019b9:	81 c4 04 00 00 00    	add    $0x4,%esp
  1019bf:	cf                   	iret   

001019c0 <isr14>:
  1019c0:	68 00 00 00 00       	push   $0x0
  1019c5:	1e                   	push   %ds
  1019c6:	06                   	push   %es
  1019c7:	0f a0                	push   %fs
  1019c9:	0f a8                	push   %gs
  1019cb:	60                   	pusha  
  1019cc:	54                   	push   %esp
  1019cd:	68 14 00 00 00       	push   $0x14
  1019d2:	e8 fe f0 ff ff       	call   100ad5 <interrupt_handler>
  1019d7:	81 c4 08 00 00 00    	add    $0x8,%esp
  1019dd:	61                   	popa   
  1019de:	1f                   	pop    %ds
  1019df:	07                   	pop    %es
  1019e0:	0f a1                	pop    %fs
  1019e2:	0f a9                	pop    %gs
  1019e4:	81 c4 04 00 00 00    	add    $0x4,%esp
  1019ea:	cf                   	iret   

001019eb <isr15>:
  1019eb:	68 00 00 00 00       	push   $0x0
  1019f0:	1e                   	push   %ds
  1019f1:	06                   	push   %es
  1019f2:	0f a0                	push   %fs
  1019f4:	0f a8                	push   %gs
  1019f6:	60                   	pusha  
  1019f7:	54                   	push   %esp
  1019f8:	68 15 00 00 00       	push   $0x15
  1019fd:	e8 d3 f0 ff ff       	call   100ad5 <interrupt_handler>
  101a02:	81 c4 08 00 00 00    	add    $0x8,%esp
  101a08:	61                   	popa   
  101a09:	1f                   	pop    %ds
  101a0a:	07                   	pop    %es
  101a0b:	0f a1                	pop    %fs
  101a0d:	0f a9                	pop    %gs
  101a0f:	81 c4 04 00 00 00    	add    $0x4,%esp
  101a15:	cf                   	iret   

00101a16 <isr16>:
  101a16:	68 00 00 00 00       	push   $0x0
  101a1b:	1e                   	push   %ds
  101a1c:	06                   	push   %es
  101a1d:	0f a0                	push   %fs
  101a1f:	0f a8                	push   %gs
  101a21:	60                   	pusha  
  101a22:	54                   	push   %esp
  101a23:	68 16 00 00 00       	push   $0x16
  101a28:	e8 a8 f0 ff ff       	call   100ad5 <interrupt_handler>
  101a2d:	81 c4 08 00 00 00    	add    $0x8,%esp
  101a33:	61                   	popa   
  101a34:	1f                   	pop    %ds
  101a35:	07                   	pop    %es
  101a36:	0f a1                	pop    %fs
  101a38:	0f a9                	pop    %gs
  101a3a:	81 c4 04 00 00 00    	add    $0x4,%esp
  101a40:	cf                   	iret   

00101a41 <isr17>:
  101a41:	68 00 00 00 00       	push   $0x0
  101a46:	1e                   	push   %ds
  101a47:	06                   	push   %es
  101a48:	0f a0                	push   %fs
  101a4a:	0f a8                	push   %gs
  101a4c:	60                   	pusha  
  101a4d:	54                   	push   %esp
  101a4e:	68 17 00 00 00       	push   $0x17
  101a53:	e8 7d f0 ff ff       	call   100ad5 <interrupt_handler>
  101a58:	81 c4 08 00 00 00    	add    $0x8,%esp
  101a5e:	61                   	popa   
  101a5f:	1f                   	pop    %ds
  101a60:	07                   	pop    %es
  101a61:	0f a1                	pop    %fs
  101a63:	0f a9                	pop    %gs
  101a65:	81 c4 04 00 00 00    	add    $0x4,%esp
  101a6b:	cf                   	iret   

00101a6c <isr18>:
  101a6c:	68 00 00 00 00       	push   $0x0
  101a71:	1e                   	push   %ds
  101a72:	06                   	push   %es
  101a73:	0f a0                	push   %fs
  101a75:	0f a8                	push   %gs
  101a77:	60                   	pusha  
  101a78:	54                   	push   %esp
  101a79:	68 18 00 00 00       	push   $0x18
  101a7e:	e8 52 f0 ff ff       	call   100ad5 <interrupt_handler>
  101a83:	81 c4 08 00 00 00    	add    $0x8,%esp
  101a89:	61                   	popa   
  101a8a:	1f                   	pop    %ds
  101a8b:	07                   	pop    %es
  101a8c:	0f a1                	pop    %fs
  101a8e:	0f a9                	pop    %gs
  101a90:	81 c4 04 00 00 00    	add    $0x4,%esp
  101a96:	cf                   	iret   

00101a97 <isr19>:
  101a97:	68 00 00 00 00       	push   $0x0
  101a9c:	1e                   	push   %ds
  101a9d:	06                   	push   %es
  101a9e:	0f a0                	push   %fs
  101aa0:	0f a8                	push   %gs
  101aa2:	60                   	pusha  
  101aa3:	54                   	push   %esp
  101aa4:	68 19 00 00 00       	push   $0x19
  101aa9:	e8 27 f0 ff ff       	call   100ad5 <interrupt_handler>
  101aae:	81 c4 08 00 00 00    	add    $0x8,%esp
  101ab4:	61                   	popa   
  101ab5:	1f                   	pop    %ds
  101ab6:	07                   	pop    %es
  101ab7:	0f a1                	pop    %fs
  101ab9:	0f a9                	pop    %gs
  101abb:	81 c4 04 00 00 00    	add    $0x4,%esp
  101ac1:	cf                   	iret   

00101ac2 <isr1A>:
  101ac2:	68 00 00 00 00       	push   $0x0
  101ac7:	1e                   	push   %ds
  101ac8:	06                   	push   %es
  101ac9:	0f a0                	push   %fs
  101acb:	0f a8                	push   %gs
  101acd:	60                   	pusha  
  101ace:	54                   	push   %esp
  101acf:	68 1a 00 00 00       	push   $0x1a
  101ad4:	e8 fc ef ff ff       	call   100ad5 <interrupt_handler>
  101ad9:	81 c4 08 00 00 00    	add    $0x8,%esp
  101adf:	61                   	popa   
  101ae0:	1f                   	pop    %ds
  101ae1:	07                   	pop    %es
  101ae2:	0f a1                	pop    %fs
  101ae4:	0f a9                	pop    %gs
  101ae6:	81 c4 04 00 00 00    	add    $0x4,%esp
  101aec:	cf                   	iret   

00101aed <isr1B>:
  101aed:	68 00 00 00 00       	push   $0x0
  101af2:	1e                   	push   %ds
  101af3:	06                   	push   %es
  101af4:	0f a0                	push   %fs
  101af6:	0f a8                	push   %gs
  101af8:	60                   	pusha  
  101af9:	54                   	push   %esp
  101afa:	68 1b 00 00 00       	push   $0x1b
  101aff:	e8 d1 ef ff ff       	call   100ad5 <interrupt_handler>
  101b04:	81 c4 08 00 00 00    	add    $0x8,%esp
  101b0a:	61                   	popa   
  101b0b:	1f                   	pop    %ds
  101b0c:	07                   	pop    %es
  101b0d:	0f a1                	pop    %fs
  101b0f:	0f a9                	pop    %gs
  101b11:	81 c4 04 00 00 00    	add    $0x4,%esp
  101b17:	cf                   	iret   

00101b18 <isr1C>:
  101b18:	68 00 00 00 00       	push   $0x0
  101b1d:	1e                   	push   %ds
  101b1e:	06                   	push   %es
  101b1f:	0f a0                	push   %fs
  101b21:	0f a8                	push   %gs
  101b23:	60                   	pusha  
  101b24:	54                   	push   %esp
  101b25:	68 1c 00 00 00       	push   $0x1c
  101b2a:	e8 a6 ef ff ff       	call   100ad5 <interrupt_handler>
  101b2f:	81 c4 08 00 00 00    	add    $0x8,%esp
  101b35:	61                   	popa   
  101b36:	1f                   	pop    %ds
  101b37:	07                   	pop    %es
  101b38:	0f a1                	pop    %fs
  101b3a:	0f a9                	pop    %gs
  101b3c:	81 c4 04 00 00 00    	add    $0x4,%esp
  101b42:	cf                   	iret   

00101b43 <isr1D>:
  101b43:	68 00 00 00 00       	push   $0x0
  101b48:	1e                   	push   %ds
  101b49:	06                   	push   %es
  101b4a:	0f a0                	push   %fs
  101b4c:	0f a8                	push   %gs
  101b4e:	60                   	pusha  
  101b4f:	54                   	push   %esp
  101b50:	68 1d 00 00 00       	push   $0x1d
  101b55:	e8 7b ef ff ff       	call   100ad5 <interrupt_handler>
  101b5a:	81 c4 08 00 00 00    	add    $0x8,%esp
  101b60:	61                   	popa   
  101b61:	1f                   	pop    %ds
  101b62:	07                   	pop    %es
  101b63:	0f a1                	pop    %fs
  101b65:	0f a9                	pop    %gs
  101b67:	81 c4 04 00 00 00    	add    $0x4,%esp
  101b6d:	cf                   	iret   

00101b6e <isr1E>:
  101b6e:	68 00 00 00 00       	push   $0x0
  101b73:	1e                   	push   %ds
  101b74:	06                   	push   %es
  101b75:	0f a0                	push   %fs
  101b77:	0f a8                	push   %gs
  101b79:	60                   	pusha  
  101b7a:	54                   	push   %esp
  101b7b:	68 1e 00 00 00       	push   $0x1e
  101b80:	e8 50 ef ff ff       	call   100ad5 <interrupt_handler>
  101b85:	81 c4 08 00 00 00    	add    $0x8,%esp
  101b8b:	61                   	popa   
  101b8c:	1f                   	pop    %ds
  101b8d:	07                   	pop    %es
  101b8e:	0f a1                	pop    %fs
  101b90:	0f a9                	pop    %gs
  101b92:	81 c4 04 00 00 00    	add    $0x4,%esp
  101b98:	cf                   	iret   

00101b99 <isr1F>:
  101b99:	68 00 00 00 00       	push   $0x0
  101b9e:	1e                   	push   %ds
  101b9f:	06                   	push   %es
  101ba0:	0f a0                	push   %fs
  101ba2:	0f a8                	push   %gs
  101ba4:	60                   	pusha  
  101ba5:	54                   	push   %esp
  101ba6:	68 1f 00 00 00       	push   $0x1f
  101bab:	e8 25 ef ff ff       	call   100ad5 <interrupt_handler>
  101bb0:	81 c4 08 00 00 00    	add    $0x8,%esp
  101bb6:	61                   	popa   
  101bb7:	1f                   	pop    %ds
  101bb8:	07                   	pop    %es
  101bb9:	0f a1                	pop    %fs
  101bbb:	0f a9                	pop    %gs
  101bbd:	81 c4 04 00 00 00    	add    $0x4,%esp
  101bc3:	cf                   	iret   

00101bc4 <isr20>:
  101bc4:	60                   	pusha  
  101bc5:	a1 9a 15 10 00       	mov    0x10159a,%eax
  101bca:	85 c0                	test   %eax,%eax
  101bcc:	74 07                	je     101bd5 <isr20.usepic>
  101bce:	e8 dd 08 00 00       	call   1024b0 <lapic_timer_calibrate>
  101bd3:	61                   	popa   
  101bd4:	cf                   	iret   

00101bd5 <isr20.usepic>:
  101bd5:	61                   	popa   
  101bd6:	e9 85 02 00 00       	jmp    101e60 <isr30>

00101bdb <isr21>:
  101bdb:	68 00 00 00 00       	push   $0x0
  101be0:	1e                   	push   %ds
  101be1:	06                   	push   %es
  101be2:	0f a0                	push   %fs
  101be4:	0f a8                	push   %gs
  101be6:	60                   	pusha  
  101be7:	54                   	push   %esp
  101be8:	68 21 00 00 00       	push   $0x21
  101bed:	e8 e3 ee ff ff       	call   100ad5 <interrupt_handler>
  101bf2:	81 c4 08 00 00 00    	add    $0x8,%esp
  101bf8:	61                   	popa   
  101bf9:	1f                   	pop    %ds
  101bfa:	07                   	pop    %es
  101bfb:	0f a1                	pop    %fs
  101bfd:	0f a9                	pop    %gs
  101bff:	81 c4 04 00 00 00    	add    $0x4,%esp
  101c05:	cf                   	iret   

00101c06 <isr22>:
  101c06:	68 00 00 00 00       	push   $0x0
  101c0b:	1e                   	push   %ds
  101c0c:	06                   	push   %es
  101c0d:	0f a0                	push   %fs
  101c0f:	0f a8                	push   %gs
  101c11:	60                   	pusha  
  101c12:	54                   	push   %esp
  101c13:	68 22 00 00 00       	push   $0x22
  101c18:	e8 b8 ee ff ff       	call   100ad5 <interrupt_handler>
  101c1d:	81 c4 08 00 00 00    	add    $0x8,%esp
  101c23:	61                   	popa   
  101c24:	1f                   	pop    %ds
  101c25:	07                   	pop    %es
  101c26:	0f a1                	pop    %fs
  101c28:	0f a9                	pop    %gs
  101c2a:	81 c4 04 00 00 00    	add    $0x4,%esp
  101c30:	cf                   	iret   

00101c31 <isr23>:
  101c31:	68 00 00 00 00       	push   $0x0
  101c36:	1e                   	push   %ds
  101c37:	06                   	push   %es
  101c38:	0f a0                	push   %fs
  101c3a:	0f a8                	push   %gs
  101c3c:	60                   	pusha  
  101c3d:	54                   	push   %esp
  101c3e:	68 23 00 00 00       	push   $0x23
  101c43:	e8 8d ee ff ff       	call   100ad5 <interrupt_handler>
  101c48:	81 c4 08 00 00 00    	add    $0x8,%esp
  101c4e:	61                   	popa   
  101c4f:	1f                   	pop    %ds
  101c50:	07                   	pop    %es
  101c51:	0f a1                	pop    %fs
  101c53:	0f a9                	pop    %gs
  101c55:	81 c4 04 00 00 00    	add    $0x4,%esp
  101c5b:	cf                   	iret   

00101c5c <isr24>:
  101c5c:	68 00 00 00 00       	push   $0x0
  101c61:	1e                   	push   %ds
  101c62:	06                   	push   %es
  101c63:	0f a0                	push   %fs
  101c65:	0f a8                	push   %gs
  101c67:	60                   	pusha  
  101c68:	54                   	push   %esp
  101c69:	68 24 00 00 00       	push   $0x24
  101c6e:	e8 62 ee ff ff       	call   100ad5 <interrupt_handler>
  101c73:	81 c4 08 00 00 00    	add    $0x8,%esp
  101c79:	61                   	popa   
  101c7a:	1f                   	pop    %ds
  101c7b:	07                   	pop    %es
  101c7c:	0f a1                	pop    %fs
  101c7e:	0f a9                	pop    %gs
  101c80:	81 c4 04 00 00 00    	add    $0x4,%esp
  101c86:	cf                   	iret   

00101c87 <isr25>:
  101c87:	68 00 00 00 00       	push   $0x0
  101c8c:	1e                   	push   %ds
  101c8d:	06                   	push   %es
  101c8e:	0f a0                	push   %fs
  101c90:	0f a8                	push   %gs
  101c92:	60                   	pusha  
  101c93:	54                   	push   %esp
  101c94:	68 25 00 00 00       	push   $0x25
  101c99:	e8 37 ee ff ff       	call   100ad5 <interrupt_handler>
  101c9e:	81 c4 08 00 00 00    	add    $0x8,%esp
  101ca4:	61                   	popa   
  101ca5:	1f                   	pop    %ds
  101ca6:	07                   	pop    %es
  101ca7:	0f a1                	pop    %fs
  101ca9:	0f a9                	pop    %gs
  101cab:	81 c4 04 00 00 00    	add    $0x4,%esp
  101cb1:	cf                   	iret   

00101cb2 <isr26>:
  101cb2:	68 00 00 00 00       	push   $0x0
  101cb7:	1e                   	push   %ds
  101cb8:	06                   	push   %es
  101cb9:	0f a0                	push   %fs
  101cbb:	0f a8                	push   %gs
  101cbd:	60                   	pusha  
  101cbe:	54                   	push   %esp
  101cbf:	68 26 00 00 00       	push   $0x26
  101cc4:	e8 0c ee ff ff       	call   100ad5 <interrupt_handler>
  101cc9:	81 c4 08 00 00 00    	add    $0x8,%esp
  101ccf:	61                   	popa   
  101cd0:	1f                   	pop    %ds
  101cd1:	07                   	pop    %es
  101cd2:	0f a1                	pop    %fs
  101cd4:	0f a9                	pop    %gs
  101cd6:	81 c4 04 00 00 00    	add    $0x4,%esp
  101cdc:	cf                   	iret   

00101cdd <isr27>:
  101cdd:	68 00 00 00 00       	push   $0x0
  101ce2:	1e                   	push   %ds
  101ce3:	06                   	push   %es
  101ce4:	0f a0                	push   %fs
  101ce6:	0f a8                	push   %gs
  101ce8:	60                   	pusha  
  101ce9:	54                   	push   %esp
  101cea:	68 27 00 00 00       	push   $0x27
  101cef:	e8 e1 ed ff ff       	call   100ad5 <interrupt_handler>
  101cf4:	81 c4 08 00 00 00    	add    $0x8,%esp
  101cfa:	61                   	popa   
  101cfb:	1f                   	pop    %ds
  101cfc:	07                   	pop    %es
  101cfd:	0f a1                	pop    %fs
  101cff:	0f a9                	pop    %gs
  101d01:	81 c4 04 00 00 00    	add    $0x4,%esp
  101d07:	cf                   	iret   

00101d08 <isr28>:
  101d08:	68 00 00 00 00       	push   $0x0
  101d0d:	1e                   	push   %ds
  101d0e:	06                   	push   %es
  101d0f:	0f a0                	push   %fs
  101d11:	0f a8                	push   %gs
  101d13:	60                   	pusha  
  101d14:	54                   	push   %esp
  101d15:	68 28 00 00 00       	push   $0x28
  101d1a:	e8 b6 ed ff ff       	call   100ad5 <interrupt_handler>
  101d1f:	81 c4 08 00 00 00    	add    $0x8,%esp
  101d25:	61                   	popa   
  101d26:	1f                   	pop    %ds
  101d27:	07                   	pop    %es
  101d28:	0f a1                	pop    %fs
  101d2a:	0f a9                	pop    %gs
  101d2c:	81 c4 04 00 00 00    	add    $0x4,%esp
  101d32:	cf                   	iret   

00101d33 <isr29>:
  101d33:	68 00 00 00 00       	push   $0x0
  101d38:	1e                   	push   %ds
  101d39:	06                   	push   %es
  101d3a:	0f a0                	push   %fs
  101d3c:	0f a8                	push   %gs
  101d3e:	60                   	pusha  
  101d3f:	54                   	push   %esp
  101d40:	68 29 00 00 00       	push   $0x29
  101d45:	e8 8b ed ff ff       	call   100ad5 <interrupt_handler>
  101d4a:	81 c4 08 00 00 00    	add    $0x8,%esp
  101d50:	61                   	popa   
  101d51:	1f                   	pop    %ds
  101d52:	07                   	pop    %es
  101d53:	0f a1                	pop    %fs
  101d55:	0f a9                	pop    %gs
  101d57:	81 c4 04 00 00 00    	add    $0x4,%esp
  101d5d:	cf                   	iret   

00101d5e <isr2A>:
  101d5e:	68 00 00 00 00       	push   $0x0
  101d63:	1e                   	push   %ds
  101d64:	06                   	push   %es
  101d65:	0f a0                	push   %fs
  101d67:	0f a8                	push   %gs
  101d69:	60                   	pusha  
  101d6a:	54                   	push   %esp
  101d6b:	68 2a 00 00 00       	push   $0x2a
  101d70:	e8 60 ed ff ff       	call   100ad5 <interrupt_handler>
  101d75:	81 c4 08 00 00 00    	add    $0x8,%esp
  101d7b:	61                   	popa   
  101d7c:	1f                   	pop    %ds
  101d7d:	07                   	pop    %es
  101d7e:	0f a1                	pop    %fs
  101d80:	0f a9                	pop    %gs
  101d82:	81 c4 04 00 00 00    	add    $0x4,%esp
  101d88:	cf                   	iret   

00101d89 <isr2B>:
  101d89:	68 00 00 00 00       	push   $0x0
  101d8e:	1e                   	push   %ds
  101d8f:	06                   	push   %es
  101d90:	0f a0                	push   %fs
  101d92:	0f a8                	push   %gs
  101d94:	60                   	pusha  
  101d95:	54                   	push   %esp
  101d96:	68 2b 00 00 00       	push   $0x2b
  101d9b:	e8 35 ed ff ff       	call   100ad5 <interrupt_handler>
  101da0:	81 c4 08 00 00 00    	add    $0x8,%esp
  101da6:	61                   	popa   
  101da7:	1f                   	pop    %ds
  101da8:	07                   	pop    %es
  101da9:	0f a1                	pop    %fs
  101dab:	0f a9                	pop    %gs
  101dad:	81 c4 04 00 00 00    	add    $0x4,%esp
  101db3:	cf                   	iret   

00101db4 <isr2C>:
  101db4:	68 00 00 00 00       	push   $0x0
  101db9:	1e                   	push   %ds
  101dba:	06                   	push   %es
  101dbb:	0f a0                	push   %fs
  101dbd:	0f a8                	push   %gs
  101dbf:	60                   	pusha  
  101dc0:	54                   	push   %esp
  101dc1:	68 2c 00 00 00       	push   $0x2c
  101dc6:	e8 0a ed ff ff       	call   100ad5 <interrupt_handler>
  101dcb:	81 c4 08 00 00 00    	add    $0x8,%esp
  101dd1:	61                   	popa   
  101dd2:	1f                   	pop    %ds
  101dd3:	07                   	pop    %es
  101dd4:	0f a1                	pop    %fs
  101dd6:	0f a9                	pop    %gs
  101dd8:	81 c4 04 00 00 00    	add    $0x4,%esp
  101dde:	cf                   	iret   

00101ddf <isr2D>:
  101ddf:	68 00 00 00 00       	push   $0x0
  101de4:	1e                   	push   %ds
  101de5:	06                   	push   %es
  101de6:	0f a0                	push   %fs
  101de8:	0f a8                	push   %gs
  101dea:	60                   	pusha  
  101deb:	54                   	push   %esp
  101dec:	68 2d 00 00 00       	push   $0x2d
  101df1:	e8 df ec ff ff       	call   100ad5 <interrupt_handler>
  101df6:	81 c4 08 00 00 00    	add    $0x8,%esp
  101dfc:	61                   	popa   
  101dfd:	1f                   	pop    %ds
  101dfe:	07                   	pop    %es
  101dff:	0f a1                	pop    %fs
  101e01:	0f a9                	pop    %gs
  101e03:	81 c4 04 00 00 00    	add    $0x4,%esp
  101e09:	cf                   	iret   

00101e0a <isr2E>:
  101e0a:	68 00 00 00 00       	push   $0x0
  101e0f:	1e                   	push   %ds
  101e10:	06                   	push   %es
  101e11:	0f a0                	push   %fs
  101e13:	0f a8                	push   %gs
  101e15:	60                   	pusha  
  101e16:	54                   	push   %esp
  101e17:	68 2e 00 00 00       	push   $0x2e
  101e1c:	e8 b4 ec ff ff       	call   100ad5 <interrupt_handler>
  101e21:	81 c4 08 00 00 00    	add    $0x8,%esp
  101e27:	61                   	popa   
  101e28:	1f                   	pop    %ds
  101e29:	07                   	pop    %es
  101e2a:	0f a1                	pop    %fs
  101e2c:	0f a9                	pop    %gs
  101e2e:	81 c4 04 00 00 00    	add    $0x4,%esp
  101e34:	cf                   	iret   

00101e35 <isr2F>:
  101e35:	68 00 00 00 00       	push   $0x0
  101e3a:	1e                   	push   %ds
  101e3b:	06                   	push   %es
  101e3c:	0f a0                	push   %fs
  101e3e:	0f a8                	push   %gs
  101e40:	60                   	pusha  
  101e41:	54                   	push   %esp
  101e42:	68 2f 00 00 00       	push   $0x2f
  101e47:	e8 89 ec ff ff       	call   100ad5 <interrupt_handler>
  101e4c:	81 c4 08 00 00 00    	add    $0x8,%esp
  101e52:	61                   	popa   
  101e53:	1f                   	pop    %ds
  101e54:	07                   	pop    %es
  101e55:	0f a1                	pop    %fs
  101e57:	0f a9                	pop    %gs
  101e59:	81 c4 04 00 00 00    	add    $0x4,%esp
  101e5f:	cf                   	iret   

00101e60 <isr30>:
  101e60:	68 00 00 00 00       	push   $0x0
  101e65:	1e                   	push   %ds
  101e66:	06                   	push   %es
  101e67:	0f a0                	push   %fs
  101e69:	0f a8                	push   %gs
  101e6b:	60                   	pusha  
  101e6c:	54                   	push   %esp
  101e6d:	68 30 00 00 00       	push   $0x30
  101e72:	e8 5e ec ff ff       	call   100ad5 <interrupt_handler>
  101e77:	81 c4 08 00 00 00    	add    $0x8,%esp
  101e7d:	61                   	popa   
  101e7e:	1f                   	pop    %ds
  101e7f:	07                   	pop    %es
  101e80:	0f a1                	pop    %fs
  101e82:	0f a9                	pop    %gs
  101e84:	81 c4 04 00 00 00    	add    $0x4,%esp
  101e8a:	cf                   	iret   

00101e8b <isr31>:
  101e8b:	68 00 00 00 00       	push   $0x0
  101e90:	1e                   	push   %ds
  101e91:	06                   	push   %es
  101e92:	0f a0                	push   %fs
  101e94:	0f a8                	push   %gs
  101e96:	60                   	pusha  
  101e97:	54                   	push   %esp
  101e98:	68 31 00 00 00       	push   $0x31
  101e9d:	e8 33 ec ff ff       	call   100ad5 <interrupt_handler>
  101ea2:	81 c4 08 00 00 00    	add    $0x8,%esp
  101ea8:	61                   	popa   
  101ea9:	1f                   	pop    %ds
  101eaa:	07                   	pop    %es
  101eab:	0f a1                	pop    %fs
  101ead:	0f a9                	pop    %gs
  101eaf:	81 c4 04 00 00 00    	add    $0x4,%esp
  101eb5:	cf                   	iret   

00101eb6 <isr32>:
  101eb6:	68 00 00 00 00       	push   $0x0
  101ebb:	1e                   	push   %ds
  101ebc:	06                   	push   %es
  101ebd:	0f a0                	push   %fs
  101ebf:	0f a8                	push   %gs
  101ec1:	60                   	pusha  
  101ec2:	54                   	push   %esp
  101ec3:	68 32 00 00 00       	push   $0x32
  101ec8:	e8 08 ec ff ff       	call   100ad5 <interrupt_handler>
  101ecd:	81 c4 08 00 00 00    	add    $0x8,%esp
  101ed3:	61                   	popa   
  101ed4:	1f                   	pop    %ds
  101ed5:	07                   	pop    %es
  101ed6:	0f a1                	pop    %fs
  101ed8:	0f a9                	pop    %gs
  101eda:	81 c4 04 00 00 00    	add    $0x4,%esp
  101ee0:	cf                   	iret   

00101ee1 <isr33>:
  101ee1:	68 00 00 00 00       	push   $0x0
  101ee6:	1e                   	push   %ds
  101ee7:	06                   	push   %es
  101ee8:	0f a0                	push   %fs
  101eea:	0f a8                	push   %gs
  101eec:	60                   	pusha  
  101eed:	54                   	push   %esp
  101eee:	68 33 00 00 00       	push   $0x33
  101ef3:	e8 dd eb ff ff       	call   100ad5 <interrupt_handler>
  101ef8:	81 c4 08 00 00 00    	add    $0x8,%esp
  101efe:	61                   	popa   
  101eff:	1f                   	pop    %ds
  101f00:	07                   	pop    %es
  101f01:	0f a1                	pop    %fs
  101f03:	0f a9                	pop    %gs
  101f05:	81 c4 04 00 00 00    	add    $0x4,%esp
  101f0b:	cf                   	iret   

00101f0c <isr34>:
  101f0c:	68 00 00 00 00       	push   $0x0
  101f11:	1e                   	push   %ds
  101f12:	06                   	push   %es
  101f13:	0f a0                	push   %fs
  101f15:	0f a8                	push   %gs
  101f17:	60                   	pusha  
  101f18:	54                   	push   %esp
  101f19:	68 34 00 00 00       	push   $0x34
  101f1e:	e8 b2 eb ff ff       	call   100ad5 <interrupt_handler>
  101f23:	81 c4 08 00 00 00    	add    $0x8,%esp
  101f29:	61                   	popa   
  101f2a:	1f                   	pop    %ds
  101f2b:	07                   	pop    %es
  101f2c:	0f a1                	pop    %fs
  101f2e:	0f a9                	pop    %gs
  101f30:	81 c4 04 00 00 00    	add    $0x4,%esp
  101f36:	cf                   	iret   

00101f37 <isr35>:
  101f37:	68 00 00 00 00       	push   $0x0
  101f3c:	1e                   	push   %ds
  101f3d:	06                   	push   %es
  101f3e:	0f a0                	push   %fs
  101f40:	0f a8                	push   %gs
  101f42:	60                   	pusha  
  101f43:	54                   	push   %esp
  101f44:	68 35 00 00 00       	push   $0x35
  101f49:	e8 87 eb ff ff       	call   100ad5 <interrupt_handler>
  101f4e:	81 c4 08 00 00 00    	add    $0x8,%esp
  101f54:	61                   	popa   
  101f55:	1f                   	pop    %ds
  101f56:	07                   	pop    %es
  101f57:	0f a1                	pop    %fs
  101f59:	0f a9                	pop    %gs
  101f5b:	81 c4 04 00 00 00    	add    $0x4,%esp
  101f61:	cf                   	iret   

00101f62 <isr36>:
  101f62:	68 00 00 00 00       	push   $0x0
  101f67:	1e                   	push   %ds
  101f68:	06                   	push   %es
  101f69:	0f a0                	push   %fs
  101f6b:	0f a8                	push   %gs
  101f6d:	60                   	pusha  
  101f6e:	54                   	push   %esp
  101f6f:	68 36 00 00 00       	push   $0x36
  101f74:	e8 5c eb ff ff       	call   100ad5 <interrupt_handler>
  101f79:	81 c4 08 00 00 00    	add    $0x8,%esp
  101f7f:	61                   	popa   
  101f80:	1f                   	pop    %ds
  101f81:	07                   	pop    %es
  101f82:	0f a1                	pop    %fs
  101f84:	0f a9                	pop    %gs
  101f86:	81 c4 04 00 00 00    	add    $0x4,%esp
  101f8c:	cf                   	iret   

00101f8d <isr37>:
  101f8d:	68 00 00 00 00       	push   $0x0
  101f92:	1e                   	push   %ds
  101f93:	06                   	push   %es
  101f94:	0f a0                	push   %fs
  101f96:	0f a8                	push   %gs
  101f98:	60                   	pusha  
  101f99:	66 8c d8             	mov    %ds,%ax
  101f9c:	66 50                	push   %ax
  101f9e:	66 8c d0             	mov    %ss,%ax
  101fa1:	8e d8                	mov    %eax,%ds
  101fa3:	66 58                	pop    %ax
  101fa5:	66 a3 92 15 10 00    	mov    %ax,0x101592
  101fab:	54                   	push   %esp
  101fac:	e8 d8 7d 00 00       	call   109d89 <syscall_handler>
  101fb1:	81 c4 04 00 00 00    	add    $0x4,%esp
  101fb7:	61                   	popa   
  101fb8:	1f                   	pop    %ds
  101fb9:	07                   	pop    %es
  101fba:	0f a1                	pop    %fs
  101fbc:	0f a9                	pop    %gs
  101fbe:	81 c4 04 00 00 00    	add    $0x4,%esp
  101fc4:	66 8b 15 92 15 10 00 	mov    0x101592,%dx
  101fcb:	8e da                	mov    %edx,%ds
  101fcd:	cf                   	iret   
	...

00101fd0 <divmod>:
#include <stdarg.h>
#include <vga.h>
#include <cpu.h>
#include <interrupt.h>

unsigned long long divmod(unsigned long long dividend,unsigned int divisor,unsigned int *remainder) {
  101fd0:	55                   	push   %ebp
  101fd1:	89 e5                	mov    %esp,%ebp
  101fd3:	53                   	push   %ebx
  101fd4:	83 ec 34             	sub    $0x34,%esp
  101fd7:	8b 45 08             	mov    0x8(%ebp),%eax
  101fda:	89 45 e0             	mov    %eax,-0x20(%ebp)
  101fdd:	8b 45 0c             	mov    0xc(%ebp),%eax
  101fe0:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  unsigned long long quotient;
  unsigned int rem;

  quotient = dividend / divisor;
  101fe3:	8b 45 10             	mov    0x10(%ebp),%eax
  101fe6:	ba 00 00 00 00       	mov    $0x0,%edx
  101feb:	89 44 24 08          	mov    %eax,0x8(%esp)
  101fef:	89 54 24 0c          	mov    %edx,0xc(%esp)
  101ff3:	8b 45 e0             	mov    -0x20(%ebp),%eax
  101ff6:	8b 55 e4             	mov    -0x1c(%ebp),%edx
  101ff9:	89 04 24             	mov    %eax,(%esp)
  101ffc:	89 54 24 04          	mov    %edx,0x4(%esp)
  102000:	e8 eb 85 00 00       	call   10a5f0 <__udivdi3>
  102005:	89 45 e8             	mov    %eax,-0x18(%ebp)
  102008:	89 55 ec             	mov    %edx,-0x14(%ebp)
  rem = dividend % divisor;
  10200b:	8b 45 10             	mov    0x10(%ebp),%eax
  10200e:	ba 00 00 00 00       	mov    $0x0,%edx
  102013:	8b 4d e0             	mov    -0x20(%ebp),%ecx
  102016:	8b 5d e4             	mov    -0x1c(%ebp),%ebx
  102019:	89 44 24 08          	mov    %eax,0x8(%esp)
  10201d:	89 54 24 0c          	mov    %edx,0xc(%esp)
  102021:	89 0c 24             	mov    %ecx,(%esp)
  102024:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  102028:	e8 e3 86 00 00       	call   10a710 <__umoddi3>
  10202d:	89 45 f4             	mov    %eax,-0xc(%ebp)

  if (remainder) *remainder = rem;
  102030:	83 7d 14 00          	cmpl   $0x0,0x14(%ebp)
  102034:	74 08                	je     10203e <divmod+0x6e>
  102036:	8b 55 14             	mov    0x14(%ebp),%edx
  102039:	8b 45 f4             	mov    -0xc(%ebp),%eax
  10203c:	89 02                	mov    %eax,(%edx)
  return quotient;
  10203e:	8b 45 e8             	mov    -0x18(%ebp),%eax
  102041:	8b 55 ec             	mov    -0x14(%ebp),%edx
}
  102044:	83 c4 34             	add    $0x34,%esp
  102047:	5b                   	pop    %ebx
  102048:	5d                   	pop    %ebp
  102049:	c3                   	ret    

0010204a <kprintchar>:

void kprintchar(char chr) {
  10204a:	55                   	push   %ebp
  10204b:	89 e5                	mov    %esp,%ebp
  10204d:	83 ec 08             	sub    $0x8,%esp
  102050:	8b 45 08             	mov    0x8(%ebp),%eax
  102053:	88 45 fc             	mov    %al,-0x4(%ebp)
  vga_text_printchar(chr);
  102056:	0f be 45 fc          	movsbl -0x4(%ebp),%eax
  10205a:	89 04 24             	mov    %eax,(%esp)
  10205d:	e8 7a 80 00 00       	call   10a0dc <vga_text_printchar>
}
  102062:	c9                   	leave  
  102063:	c3                   	ret    

00102064 <kprintstr>:

void kprintstr(char *str) {
  102064:	55                   	push   %ebp
  102065:	89 e5                	mov    %esp,%ebp
  102067:	83 ec 08             	sub    $0x8,%esp
  if (str==NULL) str = "(null)";
  10206a:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
  10206e:	75 1e                	jne    10208e <kprintstr+0x2a>
  102070:	c7 45 08 e4 d3 10 00 	movl   $0x10d3e4,0x8(%ebp)
  102077:	eb 15                	jmp    10208e <kprintstr+0x2a>
  while (*str) kprintchar(*str++);
  102079:	8b 45 08             	mov    0x8(%ebp),%eax
  10207c:	0f b6 00             	movzbl (%eax),%eax
  10207f:	0f be c0             	movsbl %al,%eax
  102082:	83 45 08 01          	addl   $0x1,0x8(%ebp)
  102086:	89 04 24             	mov    %eax,(%esp)
  102089:	e8 bc ff ff ff       	call   10204a <kprintchar>
  10208e:	8b 45 08             	mov    0x8(%ebp),%eax
  102091:	0f b6 00             	movzbl (%eax),%eax
  102094:	84 c0                	test   %al,%al
  102096:	75 e1                	jne    102079 <kprintstr+0x15>
}
  102098:	c9                   	leave  
  102099:	c3                   	ret    

0010209a <kprintnum>:

void kprintnum(long long value,unsigned int radix,unsigned int uppercase,int sign) {
  10209a:	55                   	push   %ebp
  10209b:	89 e5                	mov    %esp,%ebp
  10209d:	81 ec 88 00 00 00    	sub    $0x88,%esp
  1020a3:	8b 45 08             	mov    0x8(%ebp),%eax
  1020a6:	89 45 98             	mov    %eax,-0x68(%ebp)
  1020a9:	8b 45 0c             	mov    0xc(%ebp),%eax
  1020ac:	89 45 9c             	mov    %eax,-0x64(%ebp)
  char buf[65];
  char *p = buf;
  1020af:	8d 45 a7             	lea    -0x59(%ebp),%eax
  1020b2:	89 45 e8             	mov    %eax,-0x18(%ebp)
  const char * const chars = uppercase ? "0123456789ABCDEFGHIJKLMOPQRSTUVWXYZ" : "0123456789abcdefghijklmopqrstuvwxyz";
  1020b5:	83 7d 14 00          	cmpl   $0x0,0x14(%ebp)
  1020b9:	74 09                	je     1020c4 <kprintnum+0x2a>
  1020bb:	c7 45 94 ec d3 10 00 	movl   $0x10d3ec,-0x6c(%ebp)
  1020c2:	eb 07                	jmp    1020cb <kprintnum+0x31>
  1020c4:	c7 45 94 10 d4 10 00 	movl   $0x10d410,-0x6c(%ebp)
  1020cb:	8b 45 94             	mov    -0x6c(%ebp),%eax
  1020ce:	89 45 ec             	mov    %eax,-0x14(%ebp)
  unsigned long long temp;
  unsigned int digits;
  unsigned int remainder;

  if (value<0 && sign) {
  1020d1:	83 7d 9c 00          	cmpl   $0x0,-0x64(%ebp)
  1020d5:	79 1c                	jns    1020f3 <kprintnum+0x59>
  1020d7:	83 7d 18 00          	cmpl   $0x0,0x18(%ebp)
  1020db:	74 16                	je     1020f3 <kprintnum+0x59>
    kprintchar('-');
  1020dd:	c7 04 24 2d 00 00 00 	movl   $0x2d,(%esp)
  1020e4:	e8 61 ff ff ff       	call   10204a <kprintchar>
    value = -value;
  1020e9:	f7 5d 98             	negl   -0x68(%ebp)
  1020ec:	83 55 9c 00          	adcl   $0x0,-0x64(%ebp)
  1020f0:	f7 5d 9c             	negl   -0x64(%ebp)
  }

  // Es werden nur Basen zwischen 2 und 36 unterstuezt
  if(radix < 2 || radix > 36) return;
  1020f3:	83 7d 10 01          	cmpl   $0x1,0x10(%ebp)
  1020f7:	0f 86 b9 00 00 00    	jbe    1021b6 <kprintnum+0x11c>
  1020fd:	83 7d 10 24          	cmpl   $0x24,0x10(%ebp)
  102101:	0f 87 af 00 00 00    	ja     1021b6 <kprintnum+0x11c>

  // Anzahl der Ziffern zaehlen
  temp = value;
  102107:	8b 45 98             	mov    -0x68(%ebp),%eax
  10210a:	8b 55 9c             	mov    -0x64(%ebp),%edx
  10210d:	89 45 f0             	mov    %eax,-0x10(%ebp)
  102110:	89 55 f4             	mov    %edx,-0xc(%ebp)
  digits = 0;
  102113:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
  do {
    digits++;
  10211a:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
    temp = divmod(temp, radix, 0);
  10211e:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
  102125:	00 
  102126:	8b 45 10             	mov    0x10(%ebp),%eax
  102129:	89 44 24 08          	mov    %eax,0x8(%esp)
  10212d:	8b 45 f0             	mov    -0x10(%ebp),%eax
  102130:	8b 55 f4             	mov    -0xc(%ebp),%edx
  102133:	89 04 24             	mov    %eax,(%esp)
  102136:	89 54 24 04          	mov    %edx,0x4(%esp)
  10213a:	e8 91 fe ff ff       	call   101fd0 <divmod>
  10213f:	89 45 f0             	mov    %eax,-0x10(%ebp)
  102142:	89 55 f4             	mov    %edx,-0xc(%ebp)
  }
  while (temp>0);
  102145:	8b 55 f0             	mov    -0x10(%ebp),%edx
  102148:	8b 45 f4             	mov    -0xc(%ebp),%eax
  10214b:	09 d0                	or     %edx,%eax
  10214d:	85 c0                	test   %eax,%eax
  10214f:	75 c9                	jne    10211a <kprintnum+0x80>

  // Zeiger auf das Ende der Zahl setzen und Nullterminierung einfuegen
  p += digits;
  102151:	8b 45 fc             	mov    -0x4(%ebp),%eax
  102154:	01 45 e8             	add    %eax,-0x18(%ebp)
  *p = 0;
  102157:	8b 45 e8             	mov    -0x18(%ebp),%eax
  10215a:	c6 00 00             	movb   $0x0,(%eax)

  // Ziffern rckw�ts in den Puffer schreiben
  temp = value;
  10215d:	8b 45 98             	mov    -0x68(%ebp),%eax
  102160:	8b 55 9c             	mov    -0x64(%ebp),%edx
  102163:	89 45 f0             	mov    %eax,-0x10(%ebp)
  102166:	89 55 f4             	mov    %edx,-0xc(%ebp)
  do {
    temp = divmod(temp, radix, &remainder);
  102169:	8d 45 a0             	lea    -0x60(%ebp),%eax
  10216c:	89 44 24 0c          	mov    %eax,0xc(%esp)
  102170:	8b 45 10             	mov    0x10(%ebp),%eax
  102173:	89 44 24 08          	mov    %eax,0x8(%esp)
  102177:	8b 45 f0             	mov    -0x10(%ebp),%eax
  10217a:	8b 55 f4             	mov    -0xc(%ebp),%edx
  10217d:	89 04 24             	mov    %eax,(%esp)
  102180:	89 54 24 04          	mov    %edx,0x4(%esp)
  102184:	e8 47 fe ff ff       	call   101fd0 <divmod>
  102189:	89 45 f0             	mov    %eax,-0x10(%ebp)
  10218c:	89 55 f4             	mov    %edx,-0xc(%ebp)
    *--p = chars[remainder];
  10218f:	83 6d e8 01          	subl   $0x1,-0x18(%ebp)
  102193:	8b 45 a0             	mov    -0x60(%ebp),%eax
  102196:	03 45 ec             	add    -0x14(%ebp),%eax
  102199:	0f b6 10             	movzbl (%eax),%edx
  10219c:	8b 45 e8             	mov    -0x18(%ebp),%eax
  10219f:	88 10                	mov    %dl,(%eax)
  }
  while (--digits);
  1021a1:	83 6d fc 01          	subl   $0x1,-0x4(%ebp)
  1021a5:	83 7d fc 00          	cmpl   $0x0,-0x4(%ebp)
  1021a9:	75 be                	jne    102169 <kprintnum+0xcf>

  kprintstr(buf);
  1021ab:	8d 45 a7             	lea    -0x59(%ebp),%eax
  1021ae:	89 04 24             	mov    %eax,(%esp)
  1021b1:	e8 ae fe ff ff       	call   102064 <kprintstr>
}
  1021b6:	c9                   	leave  
  1021b7:	c3                   	ret    

001021b8 <vakprintf>:

void vakprintf(char *format,va_list args) {
  1021b8:	55                   	push   %ebp
  1021b9:	89 e5                	mov    %esp,%ebp
  1021bb:	83 ec 18             	sub    $0x18,%esp
  1021be:	e9 c8 01 00 00       	jmp    10238b <vakprintf+0x1d3>
  while (*format) {
    if (*format=='%') {
  1021c3:	8b 45 08             	mov    0x8(%ebp),%eax
  1021c6:	0f b6 00             	movzbl (%eax),%eax
  1021c9:	3c 25                	cmp    $0x25,%al
  1021cb:	0f 85 a5 01 00 00    	jne    102376 <vakprintf+0x1be>
      format++;
  1021d1:	83 45 08 01          	addl   $0x1,0x8(%ebp)
      if (!*format) return;
  1021d5:	8b 45 08             	mov    0x8(%ebp),%eax
  1021d8:	0f b6 00             	movzbl (%eax),%eax
  1021db:	84 c0                	test   %al,%al
  1021dd:	0f 84 b6 01 00 00    	je     102399 <vakprintf+0x1e1>
      else if (*format=='%') kprintchar('%');
  1021e3:	8b 45 08             	mov    0x8(%ebp),%eax
  1021e6:	0f b6 00             	movzbl (%eax),%eax
  1021e9:	3c 25                	cmp    $0x25,%al
  1021eb:	75 11                	jne    1021fe <vakprintf+0x46>
  1021ed:	c7 04 24 25 00 00 00 	movl   $0x25,(%esp)
  1021f4:	e8 51 fe ff ff       	call   10204a <kprintchar>
  1021f9:	e9 89 01 00 00       	jmp    102387 <vakprintf+0x1cf>
      else if (*format=='b') kprintnum(va_arg(args,unsigned int),2,1,0);
  1021fe:	8b 45 08             	mov    0x8(%ebp),%eax
  102201:	0f b6 00             	movzbl (%eax),%eax
  102204:	3c 62                	cmp    $0x62,%al
  102206:	75 3b                	jne    102243 <vakprintf+0x8b>
  102208:	8b 55 0c             	mov    0xc(%ebp),%edx
  10220b:	8d 42 04             	lea    0x4(%edx),%eax
  10220e:	89 45 0c             	mov    %eax,0xc(%ebp)
  102211:	89 d0                	mov    %edx,%eax
  102213:	8b 00                	mov    (%eax),%eax
  102215:	ba 00 00 00 00       	mov    $0x0,%edx
  10221a:	c7 44 24 10 00 00 00 	movl   $0x0,0x10(%esp)
  102221:	00 
  102222:	c7 44 24 0c 01 00 00 	movl   $0x1,0xc(%esp)
  102229:	00 
  10222a:	c7 44 24 08 02 00 00 	movl   $0x2,0x8(%esp)
  102231:	00 
  102232:	89 04 24             	mov    %eax,(%esp)
  102235:	89 54 24 04          	mov    %edx,0x4(%esp)
  102239:	e8 5c fe ff ff       	call   10209a <kprintnum>
  10223e:	e9 44 01 00 00       	jmp    102387 <vakprintf+0x1cf>
      else if (*format=='c') kprintchar(va_arg(args,unsigned int));
  102243:	8b 45 08             	mov    0x8(%ebp),%eax
  102246:	0f b6 00             	movzbl (%eax),%eax
  102249:	3c 63                	cmp    $0x63,%al
  10224b:	75 1d                	jne    10226a <vakprintf+0xb2>
  10224d:	8b 55 0c             	mov    0xc(%ebp),%edx
  102250:	8d 42 04             	lea    0x4(%edx),%eax
  102253:	89 45 0c             	mov    %eax,0xc(%ebp)
  102256:	89 d0                	mov    %edx,%eax
  102258:	8b 00                	mov    (%eax),%eax
  10225a:	0f be c0             	movsbl %al,%eax
  10225d:	89 04 24             	mov    %eax,(%esp)
  102260:	e8 e5 fd ff ff       	call   10204a <kprintchar>
  102265:	e9 1d 01 00 00       	jmp    102387 <vakprintf+0x1cf>
      else if (*format=='o') kprintnum(va_arg(args,unsigned int),8,1,0);
  10226a:	8b 45 08             	mov    0x8(%ebp),%eax
  10226d:	0f b6 00             	movzbl (%eax),%eax
  102270:	3c 6f                	cmp    $0x6f,%al
  102272:	75 3b                	jne    1022af <vakprintf+0xf7>
  102274:	8b 55 0c             	mov    0xc(%ebp),%edx
  102277:	8d 42 04             	lea    0x4(%edx),%eax
  10227a:	89 45 0c             	mov    %eax,0xc(%ebp)
  10227d:	89 d0                	mov    %edx,%eax
  10227f:	8b 00                	mov    (%eax),%eax
  102281:	ba 00 00 00 00       	mov    $0x0,%edx
  102286:	c7 44 24 10 00 00 00 	movl   $0x0,0x10(%esp)
  10228d:	00 
  10228e:	c7 44 24 0c 01 00 00 	movl   $0x1,0xc(%esp)
  102295:	00 
  102296:	c7 44 24 08 08 00 00 	movl   $0x8,0x8(%esp)
  10229d:	00 
  10229e:	89 04 24             	mov    %eax,(%esp)
  1022a1:	89 54 24 04          	mov    %edx,0x4(%esp)
  1022a5:	e8 f0 fd ff ff       	call   10209a <kprintnum>
  1022aa:	e9 d8 00 00 00       	jmp    102387 <vakprintf+0x1cf>
      else if (*format=='d') kprintnum(va_arg(args,int),10,1,1);
  1022af:	8b 45 08             	mov    0x8(%ebp),%eax
  1022b2:	0f b6 00             	movzbl (%eax),%eax
  1022b5:	3c 64                	cmp    $0x64,%al
  1022b7:	75 3b                	jne    1022f4 <vakprintf+0x13c>
  1022b9:	8b 55 0c             	mov    0xc(%ebp),%edx
  1022bc:	8d 42 04             	lea    0x4(%edx),%eax
  1022bf:	89 45 0c             	mov    %eax,0xc(%ebp)
  1022c2:	89 d0                	mov    %edx,%eax
  1022c4:	8b 00                	mov    (%eax),%eax
  1022c6:	89 c2                	mov    %eax,%edx
  1022c8:	c1 fa 1f             	sar    $0x1f,%edx
  1022cb:	c7 44 24 10 01 00 00 	movl   $0x1,0x10(%esp)
  1022d2:	00 
  1022d3:	c7 44 24 0c 01 00 00 	movl   $0x1,0xc(%esp)
  1022da:	00 
  1022db:	c7 44 24 08 0a 00 00 	movl   $0xa,0x8(%esp)
  1022e2:	00 
  1022e3:	89 04 24             	mov    %eax,(%esp)
  1022e6:	89 54 24 04          	mov    %edx,0x4(%esp)
  1022ea:	e8 ab fd ff ff       	call   10209a <kprintnum>
  1022ef:	e9 93 00 00 00       	jmp    102387 <vakprintf+0x1cf>
      else if (*format=='x') kprintnum(va_arg(args,unsigned int),16,1,0);
  1022f4:	8b 45 08             	mov    0x8(%ebp),%eax
  1022f7:	0f b6 00             	movzbl (%eax),%eax
  1022fa:	3c 78                	cmp    $0x78,%al
  1022fc:	75 38                	jne    102336 <vakprintf+0x17e>
  1022fe:	8b 55 0c             	mov    0xc(%ebp),%edx
  102301:	8d 42 04             	lea    0x4(%edx),%eax
  102304:	89 45 0c             	mov    %eax,0xc(%ebp)
  102307:	89 d0                	mov    %edx,%eax
  102309:	8b 00                	mov    (%eax),%eax
  10230b:	ba 00 00 00 00       	mov    $0x0,%edx
  102310:	c7 44 24 10 00 00 00 	movl   $0x0,0x10(%esp)
  102317:	00 
  102318:	c7 44 24 0c 01 00 00 	movl   $0x1,0xc(%esp)
  10231f:	00 
  102320:	c7 44 24 08 10 00 00 	movl   $0x10,0x8(%esp)
  102327:	00 
  102328:	89 04 24             	mov    %eax,(%esp)
  10232b:	89 54 24 04          	mov    %edx,0x4(%esp)
  10232f:	e8 66 fd ff ff       	call   10209a <kprintnum>
  102334:	eb 51                	jmp    102387 <vakprintf+0x1cf>
      else if (*format=='s') kprintstr(va_arg(args,char*));
  102336:	8b 45 08             	mov    0x8(%ebp),%eax
  102339:	0f b6 00             	movzbl (%eax),%eax
  10233c:	3c 73                	cmp    $0x73,%al
  10233e:	75 17                	jne    102357 <vakprintf+0x19f>
  102340:	8b 55 0c             	mov    0xc(%ebp),%edx
  102343:	8d 42 04             	lea    0x4(%edx),%eax
  102346:	89 45 0c             	mov    %eax,0xc(%ebp)
  102349:	89 d0                	mov    %edx,%eax
  10234b:	8b 00                	mov    (%eax),%eax
  10234d:	89 04 24             	mov    %eax,(%esp)
  102350:	e8 0f fd ff ff       	call   102064 <kprintstr>
  102355:	eb 30                	jmp    102387 <vakprintf+0x1cf>
      else {
        kprintchar('%');
  102357:	c7 04 24 25 00 00 00 	movl   $0x25,(%esp)
  10235e:	e8 e7 fc ff ff       	call   10204a <kprintchar>
        kprintchar(*format);
  102363:	8b 45 08             	mov    0x8(%ebp),%eax
  102366:	0f b6 00             	movzbl (%eax),%eax
  102369:	0f be c0             	movsbl %al,%eax
  10236c:	89 04 24             	mov    %eax,(%esp)
  10236f:	e8 d6 fc ff ff       	call   10204a <kprintchar>
  102374:	eb 11                	jmp    102387 <vakprintf+0x1cf>
      }
    }
    else kprintchar(*format);
  102376:	8b 45 08             	mov    0x8(%ebp),%eax
  102379:	0f b6 00             	movzbl (%eax),%eax
  10237c:	0f be c0             	movsbl %al,%eax
  10237f:	89 04 24             	mov    %eax,(%esp)
  102382:	e8 c3 fc ff ff       	call   10204a <kprintchar>
    format++;
  102387:	83 45 08 01          	addl   $0x1,0x8(%ebp)

  kprintstr(buf);
}

void vakprintf(char *format,va_list args) {
  while (*format) {
  10238b:	8b 45 08             	mov    0x8(%ebp),%eax
  10238e:	0f b6 00             	movzbl (%eax),%eax
  102391:	84 c0                	test   %al,%al
  102393:	0f 85 2a fe ff ff    	jne    1021c3 <vakprintf+0xb>
      }
    }
    else kprintchar(*format);
    format++;
  }
}
  102399:	c9                   	leave  
  10239a:	c3                   	ret    

0010239b <kprintf>:

void kprintf(char *format,...) {
  10239b:	55                   	push   %ebp
  10239c:	89 e5                	mov    %esp,%ebp
  10239e:	83 ec 18             	sub    $0x18,%esp
  va_list args;

  va_start(args,format);
  1023a1:	8d 45 0c             	lea    0xc(%ebp),%eax
  1023a4:	89 45 fc             	mov    %eax,-0x4(%ebp)
  vakprintf(format,args);
  1023a7:	8b 45 fc             	mov    -0x4(%ebp),%eax
  1023aa:	89 44 24 04          	mov    %eax,0x4(%esp)
  1023ae:	8b 45 08             	mov    0x8(%ebp),%eax
  1023b1:	89 04 24             	mov    %eax,(%esp)
  1023b4:	e8 ff fd ff ff       	call   1021b8 <vakprintf>
  va_end(args);
}
  1023b9:	c9                   	leave  
  1023ba:	c3                   	ret    

001023bb <panic>:

void panic(char *fmt,...) {
  1023bb:	55                   	push   %ebp
  1023bc:	89 e5                	mov    %esp,%ebp
  1023be:	83 ec 18             	sub    $0x18,%esp
  va_list args;

  va_start(args,fmt);
  1023c1:	8d 45 0c             	lea    0xc(%ebp),%eax
  1023c4:	89 45 fc             	mov    %eax,-0x4(%ebp)
  vga_text_setcolor(VGA_TEXT_COLOR_RED_BLACK);
  1023c7:	c7 04 24 0c 00 00 00 	movl   $0xc,(%esp)
  1023ce:	e8 fc 7c 00 00       	call   10a0cf <vga_text_setcolor>
  kprintstr(" *PANIC* ");
  1023d3:	c7 04 24 34 d4 10 00 	movl   $0x10d434,(%esp)
  1023da:	e8 85 fc ff ff       	call   102064 <kprintstr>
  vakprintf(fmt,args);
  1023df:	8b 45 fc             	mov    -0x4(%ebp),%eax
  1023e2:	89 44 24 04          	mov    %eax,0x4(%esp)
  1023e6:	8b 45 08             	mov    0x8(%ebp),%eax
  1023e9:	89 04 24             	mov    %eax,(%esp)
  1023ec:	e8 c7 fd ff ff       	call   1021b8 <vakprintf>
  interrupt_enable(0);
  1023f1:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  1023f8:	e8 ce eb ff ff       	call   100fcb <interrupt_enable>
  cpu_halt();
  1023fd:	e8 02 00 00 00       	call   102404 <cpu_halt>
}
  102402:	c9                   	leave  
  102403:	c3                   	ret    

00102404 <cpu_halt>:
  clock_t ticks;
} cpu_t;

llist_t cpus;

static inline void cpu_halt() {
  102404:	55                   	push   %ebp
  102405:	89 e5                	mov    %esp,%ebp
  asm("hlt");
  102407:	f4                   	hlt    
}
  102408:	5d                   	pop    %ebp
  102409:	c3                   	ret    
	...

0010240c <lapic_init>:
/**
 * Initializes LAPIC
 *  @return 0=Success; -1=Failure
 */
#include <stddef.h>
int lapic_init() {
  10240c:	55                   	push   %ebp
  10240d:	89 e5                	mov    %esp,%ebp
  10240f:	83 ec 28             	sub    $0x28,%esp
  uint32_t edx = 0;
  102412:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
  cpu_t *cpu = cpu_this;
  102419:	a1 54 e4 10 00       	mov    0x10e454,%eax
  10241e:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  102425:	00 
  102426:	89 04 24             	mov    %eax,(%esp)
  102429:	e8 59 86 00 00       	call   10aa87 <llist_get>
  10242e:	89 45 fc             	mov    %eax,-0x4(%ebp)

  pic_init();
  102431:	e8 e6 36 00 00       	call   105b1c <pic_init>

  cpu_id(1,NULL,NULL,NULL,&edx);
  102436:	8d 45 f8             	lea    -0x8(%ebp),%eax
  102439:	89 44 24 10          	mov    %eax,0x10(%esp)
  10243d:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
  102444:	00 
  102445:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  10244c:	00 
  10244d:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  102454:	00 
  102455:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
  10245c:	e8 6a df ff ff       	call   1003cb <cpu_id>
    pic_pit_setinterval(0,LAPIC_PIT_CALIBRATE_INTERVAL);

    return 0;
  }
  else {
    isr_uselapic = 0;
  102461:	c7 05 9a 15 10 00 00 	movl   $0x0,0x10159a
  102468:	00 00 00 
    cpu->uselapic = 0;
  10246b:	8b 45 fc             	mov    -0x4(%ebp),%eax
  10246e:	c7 40 54 00 00 00 00 	movl   $0x0,0x54(%eax)
    cpu->interval = 10; // IRQ0 all 10 ms
  102475:	8b 45 fc             	mov    -0x4(%ebp),%eax
  102478:	c7 40 58 0a 00 00 00 	movl   $0xa,0x58(%eax)
    pic_pit_setinterval(0,cpu->interval);
  10247f:	8b 45 fc             	mov    -0x4(%ebp),%eax
  102482:	8b 40 58             	mov    0x58(%eax),%eax
  102485:	89 44 24 04          	mov    %eax,0x4(%esp)
  102489:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  102490:	e8 6a 38 00 00       	call   105cff <pic_pit_setinterval>
    return -1;
  102495:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  }
}
  10249a:	c9                   	leave  
  10249b:	c3                   	ret    

0010249c <lapic_eoi>:

/**
 * Sends EOI
 */
void lapic_eoi() {
  10249c:	55                   	push   %ebp
  10249d:	89 e5                	mov    %esp,%ebp
  lapic->eoi = 0;
  10249f:	a1 20 e9 10 00       	mov    0x10e920,%eax
  1024a4:	c7 80 b0 00 00 00 00 	movl   $0x0,0xb0(%eax)
  1024ab:	00 00 00 
}
  1024ae:	5d                   	pop    %ebp
  1024af:	c3                   	ret    

001024b0 <lapic_timer_calibrate>:

void lapic_timer_calibrate() {
  1024b0:	55                   	push   %ebp
  1024b1:	89 e5                	mov    %esp,%ebp
  1024b3:	83 ec 18             	sub    $0x18,%esp
  static unsigned int ticks = 0;
  static unsigned int start = 0;
  static unsigned int end = 0;
  kprintf("LAPIC timer calibration: ticks=%u; start=%u; end=%u\n",ticks,start,end);
  1024b6:	a1 58 f9 10 00       	mov    0x10f958,%eax
  1024bb:	8b 15 5c f9 10 00    	mov    0x10f95c,%edx
  1024c1:	8b 0d 60 f9 10 00    	mov    0x10f960,%ecx
  1024c7:	89 44 24 0c          	mov    %eax,0xc(%esp)
  1024cb:	89 54 24 08          	mov    %edx,0x8(%esp)
  1024cf:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  1024d3:	c7 04 24 40 d4 10 00 	movl   $0x10d440,(%esp)
  1024da:	e8 bc fe ff ff       	call   10239b <kprintf>
  1024df:	c9                   	leave  
  1024e0:	c3                   	ret    
  1024e1:	00 00                	add    %al,(%eax)
	...

001024e4 <basename>:
#include <signal.h>
#include <ioport.h>
#include <biosint.h>
#include <perm.h>

char *basename(char *path) {
  1024e4:	55                   	push   %ebp
  1024e5:	89 e5                	mov    %esp,%ebp
  1024e7:	83 ec 14             	sub    $0x14,%esp
  size_t i;
  char *basename = path;
  1024ea:	8b 45 08             	mov    0x8(%ebp),%eax
  1024ed:	89 45 fc             	mov    %eax,-0x4(%ebp)
  for (i=0;path[i];i++) {
  1024f0:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
  1024f7:	eb 1f                	jmp    102518 <basename+0x34>
    if (path[i]=='/') basename = path+i;
  1024f9:	8b 55 f8             	mov    -0x8(%ebp),%edx
  1024fc:	8b 45 08             	mov    0x8(%ebp),%eax
  1024ff:	01 d0                	add    %edx,%eax
  102501:	0f b6 00             	movzbl (%eax),%eax
  102504:	3c 2f                	cmp    $0x2f,%al
  102506:	75 0c                	jne    102514 <basename+0x30>
  102508:	8b 45 f8             	mov    -0x8(%ebp),%eax
  10250b:	8b 55 08             	mov    0x8(%ebp),%edx
  10250e:	8d 04 02             	lea    (%edx,%eax,1),%eax
  102511:	89 45 fc             	mov    %eax,-0x4(%ebp)
#include <perm.h>

char *basename(char *path) {
  size_t i;
  char *basename = path;
  for (i=0;path[i];i++) {
  102514:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
  102518:	8b 55 f8             	mov    -0x8(%ebp),%edx
  10251b:	8b 45 08             	mov    0x8(%ebp),%eax
  10251e:	01 d0                	add    %edx,%eax
  102520:	0f b6 00             	movzbl (%eax),%eax
  102523:	84 c0                	test   %al,%al
  102525:	75 d2                	jne    1024f9 <basename+0x15>
    if (path[i]=='/') basename = path+i;
  }
  if (*basename==0) return basename;
  102527:	8b 45 fc             	mov    -0x4(%ebp),%eax
  10252a:	0f b6 00             	movzbl (%eax),%eax
  10252d:	84 c0                	test   %al,%al
  10252f:	75 08                	jne    102539 <basename+0x55>
  102531:	8b 45 fc             	mov    -0x4(%ebp),%eax
  102534:	89 45 ec             	mov    %eax,-0x14(%ebp)
  102537:	eb 09                	jmp    102542 <basename+0x5e>
  else return basename+1;
  102539:	8b 45 fc             	mov    -0x4(%ebp),%eax
  10253c:	83 c0 01             	add    $0x1,%eax
  10253f:	89 45 ec             	mov    %eax,-0x14(%ebp)
  102542:	8b 45 ec             	mov    -0x14(%ebp),%eax
}
  102545:	c9                   	leave  
  102546:	c3                   	ret    

00102547 <fourtytwo>:

int fourtytwo() {
  102547:	55                   	push   %ebp
  102548:	89 e5                	mov    %esp,%ebp
  return 42;
  10254a:	b8 2a 00 00 00       	mov    $0x2a,%eax
}
  10254f:	5d                   	pop    %ebp
  102550:	c3                   	ret    

00102551 <putsn>:

int putsn(int out,char *buf,size_t maxlen) {
  102551:	55                   	push   %ebp
  102552:	89 e5                	mov    %esp,%ebp
  102554:	83 ec 18             	sub    $0x18,%esp
  size_t i;
  for (i=0;buf[i]!=0 && i<maxlen;i++) {
  102557:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
  10255e:	eb 38                	jmp    102598 <putsn+0x47>
    if (out==0) kprintchar(buf[i]);
  102560:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
  102564:	75 18                	jne    10257e <putsn+0x2d>
  102566:	8b 55 fc             	mov    -0x4(%ebp),%edx
  102569:	8b 45 0c             	mov    0xc(%ebp),%eax
  10256c:	01 d0                	add    %edx,%eax
  10256e:	0f b6 00             	movzbl (%eax),%eax
  102571:	0f be c0             	movsbl %al,%eax
  102574:	89 04 24             	mov    %eax,(%esp)
  102577:	e8 ce fa ff ff       	call   10204a <kprintchar>
  10257c:	eb 16                	jmp    102594 <putsn+0x43>
    else com_send(buf[i]);
  10257e:	8b 55 fc             	mov    -0x4(%ebp),%edx
  102581:	8b 45 0c             	mov    0xc(%ebp),%eax
  102584:	01 d0                	add    %edx,%eax
  102586:	0f b6 00             	movzbl (%eax),%eax
  102589:	0f be c0             	movsbl %al,%eax
  10258c:	89 04 24             	mov    %eax,(%esp)
  10258f:	e8 fb 7d 00 00       	call   10a38f <com_send>
  return 42;
}

int putsn(int out,char *buf,size_t maxlen) {
  size_t i;
  for (i=0;buf[i]!=0 && i<maxlen;i++) {
  102594:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
  102598:	8b 55 fc             	mov    -0x4(%ebp),%edx
  10259b:	8b 45 0c             	mov    0xc(%ebp),%eax
  10259e:	01 d0                	add    %edx,%eax
  1025a0:	0f b6 00             	movzbl (%eax),%eax
  1025a3:	84 c0                	test   %al,%al
  1025a5:	74 08                	je     1025af <putsn+0x5e>
  1025a7:	8b 45 fc             	mov    -0x4(%ebp),%eax
  1025aa:	3b 45 10             	cmp    0x10(%ebp),%eax
  1025ad:	72 b1                	jb     102560 <putsn+0xf>
    if (out==0) kprintchar(buf[i]);
    else com_send(buf[i]);
  }
  return i;
  1025af:	8b 45 fc             	mov    -0x4(%ebp),%eax
}
  1025b2:	c9                   	leave  
  1025b3:	c3                   	ret    

001025b4 <main>:
 * Initializes and runs kernel
 *  @param mbi Multiboot Info
 *  @param magic Multiboot magic number
 *  @return Should not return
 */
int main(multiboot_info_t *mbi,uint32_t magic) {
  1025b4:	8d 4c 24 04          	lea    0x4(%esp),%ecx
  1025b8:	83 e4 f0             	and    $0xfffffff0,%esp
  1025bb:	ff 71 fc             	pushl  -0x4(%ecx)
  1025be:	55                   	push   %ebp
  1025bf:	89 e5                	mov    %esp,%ebp
  1025c1:	51                   	push   %ecx
  1025c2:	81 ec 94 00 00 00    	sub    $0x94,%esp
  1025c8:	89 4d 84             	mov    %ecx,-0x7c(%ebp)
  vga_init();
  1025cb:	e8 e8 79 00 00       	call   109fb8 <vga_init>

  kprintf("meinOS\n\n");
  1025d0:	c7 04 24 78 d4 10 00 	movl   $0x10d478,(%esp)
  1025d7:	e8 bf fd ff ff       	call   10239b <kprintf>

  if (magic!=MULTIBOOT_MAGIC) panic("Not booted with a multiboot bootloader.\n");
  1025dc:	8b 45 84             	mov    -0x7c(%ebp),%eax
  1025df:	81 78 04 02 b0 ad 2b 	cmpl   $0x2badb002,0x4(%eax)
  1025e6:	74 0c                	je     1025f4 <main+0x40>
  1025e8:	c7 04 24 84 d4 10 00 	movl   $0x10d484,(%esp)
  1025ef:	e8 c7 fd ff ff       	call   1023bb <panic>

  memuser_inited = 0;
  1025f4:	c7 05 88 e1 10 00 00 	movl   $0x0,0x10e188
  1025fb:	00 00 00 
  test(multiboot_init(mbi));
  1025fe:	c7 44 24 04 ad d4 10 	movl   $0x10d4ad,0x4(%esp)
  102605:	00 
  102606:	c7 04 24 c1 d4 10 00 	movl   $0x10d4c1,(%esp)
  10260d:	e8 89 fd ff ff       	call   10239b <kprintf>
  102612:	8b 55 84             	mov    -0x7c(%ebp),%edx
  102615:	8b 02                	mov    (%edx),%eax
  102617:	89 04 24             	mov    %eax,(%esp)
  10261a:	e8 65 27 00 00       	call   104d84 <multiboot_init>
  10261f:	85 c0                	test   %eax,%eax
  102621:	75 09                	jne    10262c <main+0x78>
  102623:	c7 45 88 c7 d4 10 00 	movl   $0x10d4c7,-0x78(%ebp)
  10262a:	eb 07                	jmp    102633 <main+0x7f>
  10262c:	c7 45 88 cc d4 10 00 	movl   $0x10d4cc,-0x78(%ebp)
  102633:	8b 45 88             	mov    -0x78(%ebp),%eax
  102636:	89 44 24 04          	mov    %eax,0x4(%esp)
  10263a:	c7 04 24 d3 d4 10 00 	movl   $0x10d4d3,(%esp)
  102641:	e8 55 fd ff ff       	call   10239b <kprintf>
  test(paging_init());
  102646:	c7 44 24 04 d7 d4 10 	movl   $0x10d4d7,0x4(%esp)
  10264d:	00 
  10264e:	c7 04 24 c1 d4 10 00 	movl   $0x10d4c1,(%esp)
  102655:	e8 41 fd ff ff       	call   10239b <kprintf>
  10265a:	e8 a1 28 00 00       	call   104f00 <paging_init>
  10265f:	85 c0                	test   %eax,%eax
  102661:	75 09                	jne    10266c <main+0xb8>
  102663:	c7 45 8c c7 d4 10 00 	movl   $0x10d4c7,-0x74(%ebp)
  10266a:	eb 07                	jmp    102673 <main+0xbf>
  10266c:	c7 45 8c cc d4 10 00 	movl   $0x10d4cc,-0x74(%ebp)
  102673:	8b 55 8c             	mov    -0x74(%ebp),%edx
  102676:	89 54 24 04          	mov    %edx,0x4(%esp)
  10267a:	c7 04 24 d3 d4 10 00 	movl   $0x10d4d3,(%esp)
  102681:	e8 15 fd ff ff       	call   10239b <kprintf>
  test(memphys_init());
  102686:	c7 44 24 04 e5 d4 10 	movl   $0x10d4e5,0x4(%esp)
  10268d:	00 
  10268e:	c7 04 24 c1 d4 10 00 	movl   $0x10d4c1,(%esp)
  102695:	e8 01 fd ff ff       	call   10239b <kprintf>
  10269a:	e8 b9 0c 00 00       	call   103358 <memphys_init>
  10269f:	85 c0                	test   %eax,%eax
  1026a1:	75 09                	jne    1026ac <main+0xf8>
  1026a3:	c7 45 90 c7 d4 10 00 	movl   $0x10d4c7,-0x70(%ebp)
  1026aa:	eb 07                	jmp    1026b3 <main+0xff>
  1026ac:	c7 45 90 cc d4 10 00 	movl   $0x10d4cc,-0x70(%ebp)
  1026b3:	8b 45 90             	mov    -0x70(%ebp),%eax
  1026b6:	89 44 24 04          	mov    %eax,0x4(%esp)
  1026ba:	c7 04 24 d3 d4 10 00 	movl   $0x10d4d3,(%esp)
  1026c1:	e8 d5 fc ff ff       	call   10239b <kprintf>
  test(memkernel_init());
  1026c6:	c7 44 24 04 f4 d4 10 	movl   $0x10d4f4,0x4(%esp)
  1026cd:	00 
  1026ce:	c7 04 24 c1 d4 10 00 	movl   $0x10d4c1,(%esp)
  1026d5:	e8 c1 fc ff ff       	call   10239b <kprintf>
  1026da:	e8 c5 0a 00 00       	call   1031a4 <memkernel_init>
  1026df:	85 c0                	test   %eax,%eax
  1026e1:	75 09                	jne    1026ec <main+0x138>
  1026e3:	c7 45 94 c7 d4 10 00 	movl   $0x10d4c7,-0x6c(%ebp)
  1026ea:	eb 07                	jmp    1026f3 <main+0x13f>
  1026ec:	c7 45 94 cc d4 10 00 	movl   $0x10d4cc,-0x6c(%ebp)
  1026f3:	8b 55 94             	mov    -0x6c(%ebp),%edx
  1026f6:	89 54 24 04          	mov    %edx,0x4(%esp)
  1026fa:	c7 04 24 d3 d4 10 00 	movl   $0x10d4d3,(%esp)
  102701:	e8 95 fc ff ff       	call   10239b <kprintf>
  test(syscall_init());
  102706:	c7 44 24 04 05 d5 10 	movl   $0x10d505,0x4(%esp)
  10270d:	00 
  10270e:	c7 04 24 c1 d4 10 00 	movl   $0x10d4c1,(%esp)
  102715:	e8 81 fc ff ff       	call   10239b <kprintf>
  10271a:	e8 41 76 00 00       	call   109d60 <syscall_init>
  10271f:	85 c0                	test   %eax,%eax
  102721:	75 09                	jne    10272c <main+0x178>
  102723:	c7 45 98 c7 d4 10 00 	movl   $0x10d4c7,-0x68(%ebp)
  10272a:	eb 07                	jmp    102733 <main+0x17f>
  10272c:	c7 45 98 cc d4 10 00 	movl   $0x10d4cc,-0x68(%ebp)
  102733:	8b 45 98             	mov    -0x68(%ebp),%eax
  102736:	89 44 24 04          	mov    %eax,0x4(%esp)
  10273a:	c7 04 24 d3 d4 10 00 	movl   $0x10d4d3,(%esp)
  102741:	e8 55 fc ff ff       	call   10239b <kprintf>
  test(cpu_init());
  102746:	c7 44 24 04 14 d5 10 	movl   $0x10d514,0x4(%esp)
  10274d:	00 
  10274e:	c7 04 24 c1 d4 10 00 	movl   $0x10d4c1,(%esp)
  102755:	e8 41 fc ff ff       	call   10239b <kprintf>
  10275a:	e8 a1 db ff ff       	call   100300 <cpu_init>
  10275f:	85 c0                	test   %eax,%eax
  102761:	75 09                	jne    10276c <main+0x1b8>
  102763:	c7 45 9c c7 d4 10 00 	movl   $0x10d4c7,-0x64(%ebp)
  10276a:	eb 07                	jmp    102773 <main+0x1bf>
  10276c:	c7 45 9c cc d4 10 00 	movl   $0x10d4cc,-0x64(%ebp)
  102773:	8b 55 9c             	mov    -0x64(%ebp),%edx
  102776:	89 54 24 04          	mov    %edx,0x4(%esp)
  10277a:	c7 04 24 d3 d4 10 00 	movl   $0x10d4d3,(%esp)
  102781:	e8 15 fc ff ff       	call   10239b <kprintf>
  test(gdt_init());
  102786:	c7 44 24 04 1f d5 10 	movl   $0x10d51f,0x4(%esp)
  10278d:	00 
  10278e:	c7 04 24 c1 d4 10 00 	movl   $0x10d4c1,(%esp)
  102795:	e8 01 fc ff ff       	call   10239b <kprintf>
  10279a:	e8 8c df ff ff       	call   10072b <gdt_init>
  10279f:	85 c0                	test   %eax,%eax
  1027a1:	75 09                	jne    1027ac <main+0x1f8>
  1027a3:	c7 45 a0 c7 d4 10 00 	movl   $0x10d4c7,-0x60(%ebp)
  1027aa:	eb 07                	jmp    1027b3 <main+0x1ff>
  1027ac:	c7 45 a0 cc d4 10 00 	movl   $0x10d4cc,-0x60(%ebp)
  1027b3:	8b 45 a0             	mov    -0x60(%ebp),%eax
  1027b6:	89 44 24 04          	mov    %eax,0x4(%esp)
  1027ba:	c7 04 24 d3 d4 10 00 	movl   $0x10d4d3,(%esp)
  1027c1:	e8 d5 fb ff ff       	call   10239b <kprintf>
  test(idt_init());
  1027c6:	c7 44 24 04 2a d5 10 	movl   $0x10d52a,0x4(%esp)
  1027cd:	00 
  1027ce:	c7 04 24 c1 d4 10 00 	movl   $0x10d4c1,(%esp)
  1027d5:	e8 c1 fb ff ff       	call   10239b <kprintf>
  1027da:	e8 b9 e0 ff ff       	call   100898 <idt_init>
  1027df:	85 c0                	test   %eax,%eax
  1027e1:	75 09                	jne    1027ec <main+0x238>
  1027e3:	c7 45 a4 c7 d4 10 00 	movl   $0x10d4c7,-0x5c(%ebp)
  1027ea:	eb 07                	jmp    1027f3 <main+0x23f>
  1027ec:	c7 45 a4 cc d4 10 00 	movl   $0x10d4cc,-0x5c(%ebp)
  1027f3:	8b 55 a4             	mov    -0x5c(%ebp),%edx
  1027f6:	89 54 24 04          	mov    %edx,0x4(%esp)
  1027fa:	c7 04 24 d3 d4 10 00 	movl   $0x10d4d3,(%esp)
  102801:	e8 95 fb ff ff       	call   10239b <kprintf>
  test(interrupt_init());
  102806:	c7 44 24 04 35 d5 10 	movl   $0x10d535,0x4(%esp)
  10280d:	00 
  10280e:	c7 04 24 c1 d4 10 00 	movl   $0x10d4c1,(%esp)
  102815:	e8 81 fb ff ff       	call   10239b <kprintf>
  10281a:	e8 91 e1 ff ff       	call   1009b0 <interrupt_init>
  10281f:	85 c0                	test   %eax,%eax
  102821:	75 09                	jne    10282c <main+0x278>
  102823:	c7 45 a8 c7 d4 10 00 	movl   $0x10d4c7,-0x58(%ebp)
  10282a:	eb 07                	jmp    102833 <main+0x27f>
  10282c:	c7 45 a8 cc d4 10 00 	movl   $0x10d4cc,-0x58(%ebp)
  102833:	8b 45 a8             	mov    -0x58(%ebp),%eax
  102836:	89 44 24 04          	mov    %eax,0x4(%esp)
  10283a:	c7 04 24 d3 d4 10 00 	movl   $0x10d4d3,(%esp)
  102841:	e8 55 fb ff ff       	call   10239b <kprintf>
  test(lapic_init());
  102846:	c7 44 24 04 46 d5 10 	movl   $0x10d546,0x4(%esp)
  10284d:	00 
  10284e:	c7 04 24 c1 d4 10 00 	movl   $0x10d4c1,(%esp)
  102855:	e8 41 fb ff ff       	call   10239b <kprintf>
  10285a:	e8 ad fb ff ff       	call   10240c <lapic_init>
  10285f:	85 c0                	test   %eax,%eax
  102861:	75 09                	jne    10286c <main+0x2b8>
  102863:	c7 45 ac c7 d4 10 00 	movl   $0x10d4c7,-0x54(%ebp)
  10286a:	eb 07                	jmp    102873 <main+0x2bf>
  10286c:	c7 45 ac cc d4 10 00 	movl   $0x10d4cc,-0x54(%ebp)
  102873:	8b 55 ac             	mov    -0x54(%ebp),%edx
  102876:	89 54 24 04          	mov    %edx,0x4(%esp)
  10287a:	c7 04 24 d3 d4 10 00 	movl   $0x10d4d3,(%esp)
  102881:	e8 15 fb ff ff       	call   10239b <kprintf>
  test(tss_init());
  102886:	c7 44 24 04 53 d5 10 	movl   $0x10d553,0x4(%esp)
  10288d:	00 
  10288e:	c7 04 24 c1 d4 10 00 	movl   $0x10d4c1,(%esp)
  102895:	e8 01 fb ff ff       	call   10239b <kprintf>
  10289a:	e8 fd 75 00 00       	call   109e9c <tss_init>
  10289f:	85 c0                	test   %eax,%eax
  1028a1:	75 09                	jne    1028ac <main+0x2f8>
  1028a3:	c7 45 b0 c7 d4 10 00 	movl   $0x10d4c7,-0x50(%ebp)
  1028aa:	eb 07                	jmp    1028b3 <main+0x2ff>
  1028ac:	c7 45 b0 cc d4 10 00 	movl   $0x10d4cc,-0x50(%ebp)
  1028b3:	8b 45 b0             	mov    -0x50(%ebp),%eax
  1028b6:	89 44 24 04          	mov    %eax,0x4(%esp)
  1028ba:	c7 04 24 d3 d4 10 00 	movl   $0x10d4d3,(%esp)
  1028c1:	e8 d5 fa ff ff       	call   10239b <kprintf>
  test(ioport_init());
  1028c6:	c7 44 24 04 5e d5 10 	movl   $0x10d55e,0x4(%esp)
  1028cd:	00 
  1028ce:	c7 04 24 c1 d4 10 00 	movl   $0x10d4c1,(%esp)
  1028d5:	e8 c1 fa ff ff       	call   10239b <kprintf>
  1028da:	e8 41 eb ff ff       	call   101420 <ioport_init>
  1028df:	85 c0                	test   %eax,%eax
  1028e1:	75 09                	jne    1028ec <main+0x338>
  1028e3:	c7 45 b4 c7 d4 10 00 	movl   $0x10d4c7,-0x4c(%ebp)
  1028ea:	eb 07                	jmp    1028f3 <main+0x33f>
  1028ec:	c7 45 b4 cc d4 10 00 	movl   $0x10d4cc,-0x4c(%ebp)
  1028f3:	8b 55 b4             	mov    -0x4c(%ebp),%edx
  1028f6:	89 54 24 04          	mov    %edx,0x4(%esp)
  1028fa:	c7 04 24 d3 d4 10 00 	movl   $0x10d4d3,(%esp)
  102901:	e8 95 fa ff ff       	call   10239b <kprintf>
  test(ipc_init());
  102906:	c7 44 24 04 6c d5 10 	movl   $0x10d56c,0x4(%esp)
  10290d:	00 
  10290e:	c7 04 24 c1 d4 10 00 	movl   $0x10d4c1,(%esp)
  102915:	e8 81 fa ff ff       	call   10239b <kprintf>
  10291a:	e8 8d eb ff ff       	call   1014ac <ipc_init>
  10291f:	85 c0                	test   %eax,%eax
  102921:	75 09                	jne    10292c <main+0x378>
  102923:	c7 45 b8 c7 d4 10 00 	movl   $0x10d4c7,-0x48(%ebp)
  10292a:	eb 07                	jmp    102933 <main+0x37f>
  10292c:	c7 45 b8 cc d4 10 00 	movl   $0x10d4cc,-0x48(%ebp)
  102933:	8b 45 b8             	mov    -0x48(%ebp),%eax
  102936:	89 44 24 04          	mov    %eax,0x4(%esp)
  10293a:	c7 04 24 d3 d4 10 00 	movl   $0x10d4d3,(%esp)
  102941:	e8 55 fa ff ff       	call   10239b <kprintf>
  test(rpc_init());
  102946:	c7 44 24 04 77 d5 10 	movl   $0x10d577,0x4(%esp)
  10294d:	00 
  10294e:	c7 04 24 c1 d4 10 00 	movl   $0x10d4c1,(%esp)
  102955:	e8 41 fa ff ff       	call   10239b <kprintf>
  10295a:	e8 e9 4e 00 00       	call   107848 <rpc_init>
  10295f:	85 c0                	test   %eax,%eax
  102961:	75 09                	jne    10296c <main+0x3b8>
  102963:	c7 45 bc c7 d4 10 00 	movl   $0x10d4c7,-0x44(%ebp)
  10296a:	eb 07                	jmp    102973 <main+0x3bf>
  10296c:	c7 45 bc cc d4 10 00 	movl   $0x10d4cc,-0x44(%ebp)
  102973:	8b 55 bc             	mov    -0x44(%ebp),%edx
  102976:	89 54 24 04          	mov    %edx,0x4(%esp)
  10297a:	c7 04 24 d3 d4 10 00 	movl   $0x10d4d3,(%esp)
  102981:	e8 15 fa ff ff       	call   10239b <kprintf>
  test(signal_init());
  102986:	c7 44 24 04 82 d5 10 	movl   $0x10d582,0x4(%esp)
  10298d:	00 
  10298e:	c7 04 24 c1 d4 10 00 	movl   $0x10d4c1,(%esp)
  102995:	e8 01 fa ff ff       	call   10239b <kprintf>
  10299a:	e8 b9 6f 00 00       	call   109958 <signal_init>
  10299f:	85 c0                	test   %eax,%eax
  1029a1:	75 09                	jne    1029ac <main+0x3f8>
  1029a3:	c7 45 c0 c7 d4 10 00 	movl   $0x10d4c7,-0x40(%ebp)
  1029aa:	eb 07                	jmp    1029b3 <main+0x3ff>
  1029ac:	c7 45 c0 cc d4 10 00 	movl   $0x10d4cc,-0x40(%ebp)
  1029b3:	8b 45 c0             	mov    -0x40(%ebp),%eax
  1029b6:	89 44 24 04          	mov    %eax,0x4(%esp)
  1029ba:	c7 04 24 d3 d4 10 00 	movl   $0x10d4d3,(%esp)
  1029c1:	e8 d5 f9 ff ff       	call   10239b <kprintf>
  test(memuser_init());
  1029c6:	c7 44 24 04 90 d5 10 	movl   $0x10d590,0x4(%esp)
  1029cd:	00 
  1029ce:	c7 04 24 c1 d4 10 00 	movl   $0x10d4c1,(%esp)
  1029d5:	e8 c1 f9 ff ff       	call   10239b <kprintf>
  1029da:	e8 1d 0d 00 00       	call   1036fc <memuser_init>
  1029df:	85 c0                	test   %eax,%eax
  1029e1:	75 09                	jne    1029ec <main+0x438>
  1029e3:	c7 45 c4 c7 d4 10 00 	movl   $0x10d4c7,-0x3c(%ebp)
  1029ea:	eb 07                	jmp    1029f3 <main+0x43f>
  1029ec:	c7 45 c4 cc d4 10 00 	movl   $0x10d4cc,-0x3c(%ebp)
  1029f3:	8b 55 c4             	mov    -0x3c(%ebp),%edx
  1029f6:	89 54 24 04          	mov    %edx,0x4(%esp)
  1029fa:	c7 04 24 d3 d4 10 00 	movl   $0x10d4d3,(%esp)
  102a01:	e8 95 f9 ff ff       	call   10239b <kprintf>
  test(proc_init());
  102a06:	c7 44 24 04 9f d5 10 	movl   $0x10d59f,0x4(%esp)
  102a0d:	00 
  102a0e:	c7 04 24 c1 d4 10 00 	movl   $0x10d4c1,(%esp)
  102a15:	e8 81 f9 ff ff       	call   10239b <kprintf>
  102a1a:	e8 59 33 00 00       	call   105d78 <proc_init>
  102a1f:	85 c0                	test   %eax,%eax
  102a21:	75 09                	jne    102a2c <main+0x478>
  102a23:	c7 45 c8 c7 d4 10 00 	movl   $0x10d4c7,-0x38(%ebp)
  102a2a:	eb 07                	jmp    102a33 <main+0x47f>
  102a2c:	c7 45 c8 cc d4 10 00 	movl   $0x10d4cc,-0x38(%ebp)
  102a33:	8b 45 c8             	mov    -0x38(%ebp),%eax
  102a36:	89 44 24 04          	mov    %eax,0x4(%esp)
  102a3a:	c7 04 24 d3 d4 10 00 	movl   $0x10d4d3,(%esp)
  102a41:	e8 55 f9 ff ff       	call   10239b <kprintf>
  test(biosint_init());
  102a46:	c7 44 24 04 ab d5 10 	movl   $0x10d5ab,0x4(%esp)
  102a4d:	00 
  102a4e:	c7 04 24 c1 d4 10 00 	movl   $0x10d4c1,(%esp)
  102a55:	e8 41 f9 ff ff       	call   10239b <kprintf>
  102a5a:	e8 e9 d5 ff ff       	call   100048 <biosint_init>
  102a5f:	85 c0                	test   %eax,%eax
  102a61:	75 09                	jne    102a6c <main+0x4b8>
  102a63:	c7 45 cc c7 d4 10 00 	movl   $0x10d4c7,-0x34(%ebp)
  102a6a:	eb 07                	jmp    102a73 <main+0x4bf>
  102a6c:	c7 45 cc cc d4 10 00 	movl   $0x10d4cc,-0x34(%ebp)
  102a73:	8b 55 cc             	mov    -0x34(%ebp),%edx
  102a76:	89 54 24 04          	mov    %edx,0x4(%esp)
  102a7a:	c7 04 24 d3 d4 10 00 	movl   $0x10d4d3,(%esp)
  102a81:	e8 15 f9 ff ff       	call   10239b <kprintf>

  /// @deprecated Only for debugging
  syscall_create(SYSCALL_PUTSN,putsn,3);
  102a86:	c7 44 24 08 03 00 00 	movl   $0x3,0x8(%esp)
  102a8d:	00 
  102a8e:	c7 44 24 04 51 25 10 	movl   $0x102551,0x4(%esp)
  102a95:	00 
  102a96:	c7 04 24 4f 00 00 00 	movl   $0x4f,(%esp)
  102a9d:	e8 98 73 00 00       	call   109e3a <syscall_create>
  syscall_create(SYSCALL_FOURTYTWO,fourtytwo,0);
  102aa2:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  102aa9:	00 
  102aaa:	c7 44 24 04 47 25 10 	movl   $0x102547,0x4(%esp)
  102ab1:	00 
  102ab2:	c7 04 24 50 00 00 00 	movl   $0x50,(%esp)
  102ab9:	e8 7c 73 00 00       	call   109e3a <syscall_create>

  // load initial programs
  kprintf("Loading initial programs...\n");
  102abe:	c7 04 24 ba d5 10 00 	movl   $0x10d5ba,(%esp)
  102ac5:	e8 d1 f8 ff ff       	call   10239b <kprintf>
  void *addr;
  char *file;
  char *name;
  proc_t *proc_init;

  for (i=0;(addr = multiboot_get_mod(i,&file,&size));i++) {
  102aca:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
  102ad1:	e9 20 01 00 00       	jmp    102bf6 <main+0x642>
    name = basename(file);
  102ad6:	8b 45 dc             	mov    -0x24(%ebp),%eax
  102ad9:	89 04 24             	mov    %eax,(%esp)
  102adc:	e8 03 fa ff ff       	call   1024e4 <basename>
  102ae1:	89 45 ec             	mov    %eax,-0x14(%ebp)
    kprintf("    %s:\t%s:\t0x%x / 0x%x...",name,file,addr,size);
  102ae4:	8b 45 e0             	mov    -0x20(%ebp),%eax
  102ae7:	8b 55 dc             	mov    -0x24(%ebp),%edx
  102aea:	89 44 24 10          	mov    %eax,0x10(%esp)
  102aee:	8b 45 e8             	mov    -0x18(%ebp),%eax
  102af1:	89 44 24 0c          	mov    %eax,0xc(%esp)
  102af5:	89 54 24 08          	mov    %edx,0x8(%esp)
  102af9:	8b 45 ec             	mov    -0x14(%ebp),%eax
  102afc:	89 44 24 04          	mov    %eax,0x4(%esp)
  102b00:	c7 04 24 d7 d5 10 00 	movl   $0x10d5d7,(%esp)
  102b07:	e8 8f f8 ff ff       	call   10239b <kprintf>
    proc_t *new = proc_create(name,PERM_ROOTUID,PERM_ROOTGID,i==0?NULL:proc_init,(i==0),(i==0));
  102b0c:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
  102b10:	0f 94 c0             	sete   %al
  102b13:	0f b6 c0             	movzbl %al,%eax
  102b16:	89 45 d0             	mov    %eax,-0x30(%ebp)
  102b19:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
  102b1d:	0f 94 c0             	sete   %al
  102b20:	0f b6 c0             	movzbl %al,%eax
  102b23:	89 45 d4             	mov    %eax,-0x2c(%ebp)
  102b26:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
  102b2a:	74 08                	je     102b34 <main+0x580>
  102b2c:	8b 45 f0             	mov    -0x10(%ebp),%eax
  102b2f:	89 45 d8             	mov    %eax,-0x28(%ebp)
  102b32:	eb 07                	jmp    102b3b <main+0x587>
  102b34:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%ebp)
  102b3b:	8b 55 d0             	mov    -0x30(%ebp),%edx
  102b3e:	89 54 24 14          	mov    %edx,0x14(%esp)
  102b42:	8b 45 d4             	mov    -0x2c(%ebp),%eax
  102b45:	89 44 24 10          	mov    %eax,0x10(%esp)
  102b49:	8b 55 d8             	mov    -0x28(%ebp),%edx
  102b4c:	89 54 24 0c          	mov    %edx,0xc(%esp)
  102b50:	c7 44 24 08 01 00 00 	movl   $0x1,0x8(%esp)
  102b57:	00 
  102b58:	c7 44 24 04 01 00 00 	movl   $0x1,0x4(%esp)
  102b5f:	00 
  102b60:	8b 45 ec             	mov    -0x14(%ebp),%eax
  102b63:	89 04 24             	mov    %eax,(%esp)
  102b66:	e8 07 37 00 00       	call   106272 <proc_create>
  102b6b:	89 45 f4             	mov    %eax,-0xc(%ebp)
    if (i==0) proc_init = new;
  102b6e:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
  102b72:	75 06                	jne    102b7a <main+0x5c6>
  102b74:	8b 45 f4             	mov    -0xc(%ebp),%eax
  102b77:	89 45 f0             	mov    %eax,-0x10(%ebp)
    if (new!=NULL) {
  102b7a:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
  102b7e:	74 66                	je     102be6 <main+0x632>
      void *entrypoint = elf_load(new->addrspace,addr,size);
  102b80:	8b 55 e0             	mov    -0x20(%ebp),%edx
  102b83:	8b 45 f4             	mov    -0xc(%ebp),%eax
  102b86:	8b 48 6c             	mov    0x6c(%eax),%ecx
  102b89:	89 54 24 08          	mov    %edx,0x8(%esp)
  102b8d:	8b 45 e8             	mov    -0x18(%ebp),%eax
  102b90:	89 44 24 04          	mov    %eax,0x4(%esp)
  102b94:	89 0c 24             	mov    %ecx,(%esp)
  102b97:	e8 4e da ff ff       	call   1005ea <elf_load>
  102b9c:	89 45 f8             	mov    %eax,-0x8(%ebp)
      if (entrypoint!=NULL) {
  102b9f:	83 7d f8 00          	cmpl   $0x0,-0x8(%ebp)
  102ba3:	74 36                	je     102bdb <main+0x627>
        new->registers.eip = (uint32_t)entrypoint;
  102ba5:	8b 55 f8             	mov    -0x8(%ebp),%edx
  102ba8:	8b 45 f4             	mov    -0xc(%ebp),%eax
  102bab:	89 50 4c             	mov    %edx,0x4c(%eax)
        new->registers.esp = (uint32_t)memuser_create_stack(new->addrspace);
  102bae:	8b 45 f4             	mov    -0xc(%ebp),%eax
  102bb1:	8b 40 6c             	mov    0x6c(%eax),%eax
  102bb4:	89 04 24             	mov    %eax,(%esp)
  102bb7:	e8 c7 13 00 00       	call   103f83 <memuser_create_stack>
  102bbc:	89 c2                	mov    %eax,%edx
  102bbe:	8b 45 f4             	mov    -0xc(%ebp),%eax
  102bc1:	89 50 48             	mov    %edx,0x48(%eax)
        kprintf("(pid=%d) done\n",new->pid);
  102bc4:	8b 45 f4             	mov    -0xc(%ebp),%eax
  102bc7:	8b 00                	mov    (%eax),%eax
  102bc9:	89 44 24 04          	mov    %eax,0x4(%esp)
  102bcd:	c7 04 24 f2 d5 10 00 	movl   $0x10d5f2,(%esp)
  102bd4:	e8 c2 f7 ff ff       	call   10239b <kprintf>
  102bd9:	eb 17                	jmp    102bf2 <main+0x63e>
        continue;
      }
      else proc_destroy(new);
  102bdb:	8b 45 f4             	mov    -0xc(%ebp),%eax
  102bde:	89 04 24             	mov    %eax,(%esp)
  102be1:	e8 57 38 00 00       	call   10643d <proc_destroy>
    }
    kprintf("failed\n");
  102be6:	c7 04 24 01 d6 10 00 	movl   $0x10d601,(%esp)
  102bed:	e8 a9 f7 ff ff       	call   10239b <kprintf>
  void *addr;
  char *file;
  char *name;
  proc_t *proc_init;

  for (i=0;(addr = multiboot_get_mod(i,&file,&size));i++) {
  102bf2:	83 45 e4 01          	addl   $0x1,-0x1c(%ebp)
  102bf6:	8d 45 e0             	lea    -0x20(%ebp),%eax
  102bf9:	89 44 24 08          	mov    %eax,0x8(%esp)
  102bfd:	8d 45 dc             	lea    -0x24(%ebp),%eax
  102c00:	89 44 24 04          	mov    %eax,0x4(%esp)
  102c04:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  102c07:	89 04 24             	mov    %eax,(%esp)
  102c0a:	e8 c3 21 00 00       	call   104dd2 <multiboot_get_mod>
  102c0f:	89 45 e8             	mov    %eax,-0x18(%ebp)
  102c12:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
  102c16:	0f 85 ba fe ff ff    	jne    102ad6 <main+0x522>
      else proc_destroy(new);
    }
    kprintf("failed\n");
  }

  proc_idle();
  102c1c:	e8 ff 44 00 00       	call   107120 <proc_idle>
  return 0;
  102c21:	b8 00 00 00 00       	mov    $0x0,%eax
}
  102c26:	81 c4 94 00 00 00    	add    $0x94,%esp
  102c2c:	59                   	pop    %ecx
  102c2d:	5d                   	pop    %ebp
  102c2e:	8d 61 fc             	lea    -0x4(%ecx),%esp
  102c31:	c3                   	ret    
	...

00102c34 <malloc_init>:
/**
 * Initializes memory allocator
 *  @param getpage Pointer to page allocator
 *  @param freepage Pointer to page free'r
 */
void malloc_init(void *(*getpage)(size_t size),void (*freepage)(void *addr)) {
  102c34:	55                   	push   %ebp
  102c35:	89 e5                	mov    %esp,%ebp
  _malloc_getpage = getpage;
  102c37:	8b 45 08             	mov    0x8(%ebp),%eax
  102c3a:	a3 40 e9 10 00       	mov    %eax,0x10e940
  _malloc_freepage = freepage;
  102c3f:	8b 45 0c             	mov    0xc(%ebp),%eax
  102c42:	a3 3c e9 10 00       	mov    %eax,0x10e93c
  _malloc_firstfree = NULL;
  102c47:	c7 05 38 e9 10 00 00 	movl   $0x0,0x10e938
  102c4e:	00 00 00 
}
  102c51:	5d                   	pop    %ebp
  102c52:	c3                   	ret    

00102c53 <_malloc_insertlist>:

/**
 * Insert a new free block in free block list
 *  @param header Pointer to new block
 */
void _malloc_insertlist(struct _malloc_header *header) {
  102c53:	55                   	push   %ebp
  102c54:	89 e5                	mov    %esp,%ebp
  102c56:	83 ec 10             	sub    $0x10,%esp
  struct _malloc_header *cur = _malloc_firstfree;
  102c59:	a1 38 e9 10 00       	mov    0x10e938,%eax
  102c5e:	89 45 fc             	mov    %eax,-0x4(%ebp)

  if (_malloc_firstfree==NULL) {
  102c61:	a1 38 e9 10 00       	mov    0x10e938,%eax
  102c66:	85 c0                	test   %eax,%eax
  102c68:	75 17                	jne    102c81 <_malloc_insertlist+0x2e>
    _malloc_firstfree = header;
  102c6a:	8b 45 08             	mov    0x8(%ebp),%eax
  102c6d:	a3 38 e9 10 00       	mov    %eax,0x10e938
    header->nextfree = NULL;
  102c72:	8b 45 08             	mov    0x8(%ebp),%eax
  102c75:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
  102c7c:	e9 86 00 00 00       	jmp    102d07 <_malloc_insertlist+0xb4>
  }
  else if (header<(struct _malloc_header*)_malloc_firstfree) {
  102c81:	a1 38 e9 10 00       	mov    0x10e938,%eax
  102c86:	39 45 08             	cmp    %eax,0x8(%ebp)
  102c89:	73 76                	jae    102d01 <_malloc_insertlist+0xae>
    header->nextfree = _malloc_firstfree;
  102c8b:	a1 38 e9 10 00       	mov    0x10e938,%eax
  102c90:	8b 55 08             	mov    0x8(%ebp),%edx
  102c93:	89 42 08             	mov    %eax,0x8(%edx)
    _malloc_firstfree = header;
  102c96:	8b 45 08             	mov    0x8(%ebp),%eax
  102c99:	a3 38 e9 10 00       	mov    %eax,0x10e938
  102c9e:	eb 67                	jmp    102d07 <_malloc_insertlist+0xb4>
  }
  else {
    while (cur!=NULL) {
      if (cur<header && (cur->nextfree>header || cur->nextfree==NULL)) {
  102ca0:	8b 45 fc             	mov    -0x4(%ebp),%eax
  102ca3:	3b 45 08             	cmp    0x8(%ebp),%eax
  102ca6:	73 50                	jae    102cf8 <_malloc_insertlist+0xa5>
  102ca8:	8b 45 fc             	mov    -0x4(%ebp),%eax
  102cab:	8b 40 08             	mov    0x8(%eax),%eax
  102cae:	3b 45 08             	cmp    0x8(%ebp),%eax
  102cb1:	77 0a                	ja     102cbd <_malloc_insertlist+0x6a>
  102cb3:	8b 45 fc             	mov    -0x4(%ebp),%eax
  102cb6:	8b 40 08             	mov    0x8(%eax),%eax
  102cb9:	85 c0                	test   %eax,%eax
  102cbb:	75 3b                	jne    102cf8 <_malloc_insertlist+0xa5>
        if (((uint32_t)cur)+cur->size==(uint32_t)header) { ///< join last block and new one
  102cbd:	8b 45 fc             	mov    -0x4(%ebp),%eax
  102cc0:	8b 40 04             	mov    0x4(%eax),%eax
  102cc3:	03 45 fc             	add    -0x4(%ebp),%eax
  102cc6:	3b 45 08             	cmp    0x8(%ebp),%eax
  102cc9:	75 16                	jne    102ce1 <_malloc_insertlist+0x8e>
          cur->size += header->size;
  102ccb:	8b 45 fc             	mov    -0x4(%ebp),%eax
  102cce:	8b 50 04             	mov    0x4(%eax),%edx
  102cd1:	8b 45 08             	mov    0x8(%ebp),%eax
  102cd4:	8b 40 04             	mov    0x4(%eax),%eax
  102cd7:	01 c2                	add    %eax,%edx
  102cd9:	8b 45 fc             	mov    -0x4(%ebp),%eax
  102cdc:	89 50 04             	mov    %edx,0x4(%eax)
  102cdf:	eb 26                	jmp    102d07 <_malloc_insertlist+0xb4>
        }
        else {
          header->nextfree = cur->nextfree;
  102ce1:	8b 45 fc             	mov    -0x4(%ebp),%eax
  102ce4:	8b 50 08             	mov    0x8(%eax),%edx
  102ce7:	8b 45 08             	mov    0x8(%ebp),%eax
  102cea:	89 50 08             	mov    %edx,0x8(%eax)
          cur->nextfree = header;
  102ced:	8b 55 fc             	mov    -0x4(%ebp),%edx
  102cf0:	8b 45 08             	mov    0x8(%ebp),%eax
  102cf3:	89 42 08             	mov    %eax,0x8(%edx)
  102cf6:	eb 0f                	jmp    102d07 <_malloc_insertlist+0xb4>
        }
        break;
      }
      cur = cur->nextfree;
  102cf8:	8b 45 fc             	mov    -0x4(%ebp),%eax
  102cfb:	8b 40 08             	mov    0x8(%eax),%eax
  102cfe:	89 45 fc             	mov    %eax,-0x4(%ebp)
  else if (header<(struct _malloc_header*)_malloc_firstfree) {
    header->nextfree = _malloc_firstfree;
    _malloc_firstfree = header;
  }
  else {
    while (cur!=NULL) {
  102d01:	83 7d fc 00          	cmpl   $0x0,-0x4(%ebp)
  102d05:	75 99                	jne    102ca0 <_malloc_insertlist+0x4d>
      }
      cur = cur->nextfree;
    }
  }

  if (((uint32_t)header)+header->size==((uint32_t)header->nextfree)) { ///< join next block and new one
  102d07:	8b 45 08             	mov    0x8(%ebp),%eax
  102d0a:	8b 40 04             	mov    0x4(%eax),%eax
  102d0d:	89 c2                	mov    %eax,%edx
  102d0f:	03 55 08             	add    0x8(%ebp),%edx
  102d12:	8b 45 08             	mov    0x8(%ebp),%eax
  102d15:	8b 40 08             	mov    0x8(%eax),%eax
  102d18:	39 c2                	cmp    %eax,%edx
  102d1a:	75 26                	jne    102d42 <_malloc_insertlist+0xef>
    header->size += header->nextfree->size;
  102d1c:	8b 45 08             	mov    0x8(%ebp),%eax
  102d1f:	8b 50 04             	mov    0x4(%eax),%edx
  102d22:	8b 45 08             	mov    0x8(%ebp),%eax
  102d25:	8b 40 08             	mov    0x8(%eax),%eax
  102d28:	8b 40 04             	mov    0x4(%eax),%eax
  102d2b:	01 c2                	add    %eax,%edx
  102d2d:	8b 45 08             	mov    0x8(%ebp),%eax
  102d30:	89 50 04             	mov    %edx,0x4(%eax)
    header->nextfree = header->nextfree->nextfree;
  102d33:	8b 45 08             	mov    0x8(%ebp),%eax
  102d36:	8b 40 08             	mov    0x8(%eax),%eax
  102d39:	8b 50 08             	mov    0x8(%eax),%edx
  102d3c:	8b 45 08             	mov    0x8(%ebp),%eax
  102d3f:	89 50 08             	mov    %edx,0x8(%eax)
  }
}
  102d42:	c9                   	leave  
  102d43:	c3                   	ret    

00102d44 <malloc_donatemem>:
/**
 * Donates memory for a free block
 *  @param addr Address of free memory
 *  @param size Size of free memory
 */
void malloc_donatemem(void *addr,size_t size) {
  102d44:	55                   	push   %ebp
  102d45:	89 e5                	mov    %esp,%ebp
  102d47:	83 ec 14             	sub    $0x14,%esp
  if (addr!=NULL) {
  102d4a:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
  102d4e:	74 23                	je     102d73 <malloc_donatemem+0x2f>
    struct _malloc_header *header = (struct _malloc_header*)addr;
  102d50:	8b 45 08             	mov    0x8(%ebp),%eax
  102d53:	89 45 fc             	mov    %eax,-0x4(%ebp)
    header->flags = 0;
  102d56:	8b 45 fc             	mov    -0x4(%ebp),%eax
  102d59:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
    header->size = size;
  102d5f:	8b 55 fc             	mov    -0x4(%ebp),%edx
  102d62:	8b 45 0c             	mov    0xc(%ebp),%eax
  102d65:	89 42 04             	mov    %eax,0x4(%edx)
    _malloc_insertlist(header);
  102d68:	8b 45 fc             	mov    -0x4(%ebp),%eax
  102d6b:	89 04 24             	mov    %eax,(%esp)
  102d6e:	e8 e0 fe ff ff       	call   102c53 <_malloc_insertlist>
  }
}
  102d73:	c9                   	leave  
  102d74:	c3                   	ret    

00102d75 <_malloc_getmem>:

/**
 * Adds a new free block of the size of a page to list
 *  @return Address of new memory block
 */
void *_malloc_getmem() {
  102d75:	55                   	push   %ebp
  102d76:	89 e5                	mov    %esp,%ebp
  102d78:	83 ec 18             	sub    $0x18,%esp
  void *addr = _malloc_getpage(PAGE_SIZE);
  102d7b:	a1 40 e9 10 00       	mov    0x10e940,%eax
  102d80:	c7 04 24 00 10 00 00 	movl   $0x1000,(%esp)
  102d87:	ff d0                	call   *%eax
  102d89:	89 45 fc             	mov    %eax,-0x4(%ebp)
  malloc_donatemem(addr,PAGE_SIZE);
  102d8c:	c7 44 24 04 00 10 00 	movl   $0x1000,0x4(%esp)
  102d93:	00 
  102d94:	8b 45 fc             	mov    -0x4(%ebp),%eax
  102d97:	89 04 24             	mov    %eax,(%esp)
  102d9a:	e8 a5 ff ff ff       	call   102d44 <malloc_donatemem>
  return addr;
  102d9f:	8b 45 fc             	mov    -0x4(%ebp),%eax
}
  102da2:	c9                   	leave  
  102da3:	c3                   	ret    

00102da4 <_malloc_getfree>:
/**
 * Gets a free block and marks it as used
 *  @param size Needed block's size
 *  @return Pointer to block
 */
struct _malloc_header *_malloc_getfree(size_t size) {
  102da4:	55                   	push   %ebp
  102da5:	89 e5                	mov    %esp,%ebp
  102da7:	83 ec 18             	sub    $0x18,%esp
  while (1) {
    struct _malloc_header *cur = _malloc_firstfree;
  102daa:	a1 38 e9 10 00       	mov    0x10e938,%eax
  102daf:	89 45 f4             	mov    %eax,-0xc(%ebp)
    struct _malloc_header *last = NULL;
  102db2:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
  102db9:	e9 cd 00 00 00       	jmp    102e8b <_malloc_getfree+0xe7>

    while (cur!=NULL) {
      //if (size>=cur->size && size<=cur->size+sizeof(struct _malloc_header)) { ///< I want this block!
      if (size==cur->size) {
  102dbe:	8b 45 f4             	mov    -0xc(%ebp),%eax
  102dc1:	8b 40 04             	mov    0x4(%eax),%eax
  102dc4:	3b 45 08             	cmp    0x8(%ebp),%eax
  102dc7:	75 39                	jne    102e02 <_malloc_getfree+0x5e>
        cur->flags |= 1;
  102dc9:	8b 45 f4             	mov    -0xc(%ebp),%eax
  102dcc:	8b 00                	mov    (%eax),%eax
  102dce:	89 c2                	mov    %eax,%edx
  102dd0:	83 ca 01             	or     $0x1,%edx
  102dd3:	8b 45 f4             	mov    -0xc(%ebp),%eax
  102dd6:	89 10                	mov    %edx,(%eax)
        if (last==NULL) _malloc_firstfree = cur->nextfree;
  102dd8:	83 7d f8 00          	cmpl   $0x0,-0x8(%ebp)
  102ddc:	75 0d                	jne    102deb <_malloc_getfree+0x47>
  102dde:	8b 45 f4             	mov    -0xc(%ebp),%eax
  102de1:	8b 40 08             	mov    0x8(%eax),%eax
  102de4:	a3 38 e9 10 00       	mov    %eax,0x10e938
  102de9:	eb 0c                	jmp    102df7 <_malloc_getfree+0x53>
        else last->nextfree = cur->nextfree;
  102deb:	8b 45 f4             	mov    -0xc(%ebp),%eax
  102dee:	8b 50 08             	mov    0x8(%eax),%edx
  102df1:	8b 45 f8             	mov    -0x8(%ebp),%eax
  102df4:	89 50 08             	mov    %edx,0x8(%eax)
        return cur;
  102df7:	8b 45 f4             	mov    -0xc(%ebp),%eax
  102dfa:	89 45 ec             	mov    %eax,-0x14(%ebp)
  102dfd:	e9 9d 00 00 00       	jmp    102e9f <_malloc_getfree+0xfb>
      }
      else if (cur->size>=size+sizeof(struct _malloc_header)) { ///< Just split it
  102e02:	8b 45 f4             	mov    -0xc(%ebp),%eax
  102e05:	8b 50 04             	mov    0x4(%eax),%edx
  102e08:	8b 45 08             	mov    0x8(%ebp),%eax
  102e0b:	83 c0 0c             	add    $0xc,%eax
  102e0e:	39 c2                	cmp    %eax,%edx
  102e10:	72 6a                	jb     102e7c <_malloc_getfree+0xd8>
        struct _malloc_header *new = (struct _malloc_header*)(((uint8_t*)cur)+size);
  102e12:	8b 55 08             	mov    0x8(%ebp),%edx
  102e15:	8b 45 f4             	mov    -0xc(%ebp),%eax
  102e18:	01 d0                	add    %edx,%eax
  102e1a:	89 45 fc             	mov    %eax,-0x4(%ebp)
        new->flags = 0;
  102e1d:	8b 45 fc             	mov    -0x4(%ebp),%eax
  102e20:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
        new->size = cur->size-size;
  102e26:	8b 45 f4             	mov    -0xc(%ebp),%eax
  102e29:	8b 40 04             	mov    0x4(%eax),%eax
  102e2c:	89 c2                	mov    %eax,%edx
  102e2e:	2b 55 08             	sub    0x8(%ebp),%edx
  102e31:	8b 45 fc             	mov    -0x4(%ebp),%eax
  102e34:	89 50 04             	mov    %edx,0x4(%eax)
        new->nextfree = cur->nextfree;
  102e37:	8b 45 f4             	mov    -0xc(%ebp),%eax
  102e3a:	8b 50 08             	mov    0x8(%eax),%edx
  102e3d:	8b 45 fc             	mov    -0x4(%ebp),%eax
  102e40:	89 50 08             	mov    %edx,0x8(%eax)
        cur->size = size;
  102e43:	8b 55 f4             	mov    -0xc(%ebp),%edx
  102e46:	8b 45 08             	mov    0x8(%ebp),%eax
  102e49:	89 42 04             	mov    %eax,0x4(%edx)
        cur->flags |= 1;
  102e4c:	8b 45 f4             	mov    -0xc(%ebp),%eax
  102e4f:	8b 00                	mov    (%eax),%eax
  102e51:	89 c2                	mov    %eax,%edx
  102e53:	83 ca 01             	or     $0x1,%edx
  102e56:	8b 45 f4             	mov    -0xc(%ebp),%eax
  102e59:	89 10                	mov    %edx,(%eax)
        if (last==NULL) _malloc_firstfree = new;
  102e5b:	83 7d f8 00          	cmpl   $0x0,-0x8(%ebp)
  102e5f:	75 0a                	jne    102e6b <_malloc_getfree+0xc7>
  102e61:	8b 45 fc             	mov    -0x4(%ebp),%eax
  102e64:	a3 38 e9 10 00       	mov    %eax,0x10e938
  102e69:	eb 09                	jmp    102e74 <_malloc_getfree+0xd0>
        else last->nextfree = new;
  102e6b:	8b 55 f8             	mov    -0x8(%ebp),%edx
  102e6e:	8b 45 fc             	mov    -0x4(%ebp),%eax
  102e71:	89 42 08             	mov    %eax,0x8(%edx)
        return cur;
  102e74:	8b 45 f4             	mov    -0xc(%ebp),%eax
  102e77:	89 45 ec             	mov    %eax,-0x14(%ebp)
  102e7a:	eb 23                	jmp    102e9f <_malloc_getfree+0xfb>
      }
      last = cur;
  102e7c:	8b 45 f4             	mov    -0xc(%ebp),%eax
  102e7f:	89 45 f8             	mov    %eax,-0x8(%ebp)
      cur = cur->nextfree;
  102e82:	8b 45 f4             	mov    -0xc(%ebp),%eax
  102e85:	8b 40 08             	mov    0x8(%eax),%eax
  102e88:	89 45 f4             	mov    %eax,-0xc(%ebp)
struct _malloc_header *_malloc_getfree(size_t size) {
  while (1) {
    struct _malloc_header *cur = _malloc_firstfree;
    struct _malloc_header *last = NULL;

    while (cur!=NULL) {
  102e8b:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
  102e8f:	0f 85 29 ff ff ff    	jne    102dbe <_malloc_getfree+0x1a>
        return cur;
      }
      last = cur;
      cur = cur->nextfree;
    }
    _malloc_getmem();
  102e95:	e8 db fe ff ff       	call   102d75 <_malloc_getmem>
  102e9a:	e9 0b ff ff ff       	jmp    102daa <_malloc_getfree+0x6>
  }
  102e9f:	8b 45 ec             	mov    -0x14(%ebp),%eax
}
  102ea2:	c9                   	leave  
  102ea3:	c3                   	ret    

00102ea4 <_malloc_checkforfree>:

/**
 * Checks for a free page and frees it
 */
void _malloc_checkforfree() {
  102ea4:	55                   	push   %ebp
  102ea5:	89 e5                	mov    %esp,%ebp
  102ea7:	83 ec 18             	sub    $0x18,%esp
  struct _malloc_header *cur = _malloc_firstfree;
  102eaa:	a1 38 e9 10 00       	mov    0x10e938,%eax
  102eaf:	89 45 f8             	mov    %eax,-0x8(%ebp)
  struct _malloc_header *last = NULL;
  102eb2:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
  102eb9:	e9 9f 00 00 00       	jmp    102f5d <_malloc_checkforfree+0xb9>

  while (cur!=NULL) {
    if (cur->size==PAGE_SIZE && ((uint32_t)cur)%PAGE_SIZE==0) { ///< We can just free it
  102ebe:	8b 45 f8             	mov    -0x8(%ebp),%eax
  102ec1:	8b 40 04             	mov    0x4(%eax),%eax
  102ec4:	3d 00 10 00 00       	cmp    $0x1000,%eax
  102ec9:	75 3b                	jne    102f06 <_malloc_checkforfree+0x62>
  102ecb:	8b 45 f8             	mov    -0x8(%ebp),%eax
  102ece:	25 ff 0f 00 00       	and    $0xfff,%eax
  102ed3:	85 c0                	test   %eax,%eax
  102ed5:	75 2f                	jne    102f06 <_malloc_checkforfree+0x62>
      if (last==NULL) _malloc_firstfree = cur->nextfree;
  102ed7:	83 7d fc 00          	cmpl   $0x0,-0x4(%ebp)
  102edb:	75 0d                	jne    102eea <_malloc_checkforfree+0x46>
  102edd:	8b 45 f8             	mov    -0x8(%ebp),%eax
  102ee0:	8b 40 08             	mov    0x8(%eax),%eax
  102ee3:	a3 38 e9 10 00       	mov    %eax,0x10e938
  102ee8:	eb 0c                	jmp    102ef6 <_malloc_checkforfree+0x52>
      else last->nextfree = cur->nextfree;
  102eea:	8b 45 f8             	mov    -0x8(%ebp),%eax
  102eed:	8b 50 08             	mov    0x8(%eax),%edx
  102ef0:	8b 45 fc             	mov    -0x4(%ebp),%eax
  102ef3:	89 50 08             	mov    %edx,0x8(%eax)
      _malloc_freepage(cur);
  102ef6:	8b 15 3c e9 10 00    	mov    0x10e93c,%edx
  102efc:	8b 45 f8             	mov    -0x8(%ebp),%eax
  102eff:	89 04 24             	mov    %eax,(%esp)
  102f02:	ff d2                	call   *%edx
  102f04:	eb 48                	jmp    102f4e <_malloc_checkforfree+0xaa>
    }
    else if (cur->size-(((uint32_t)cur)%PAGE_SIZE)>=PAGE_SIZE && (((uint32_t)cur)%PAGE_SIZE)>=sizeof(struct _malloc_header)) { ///< Split it and free it
  102f06:	8b 45 f8             	mov    -0x8(%ebp),%eax
  102f09:	8b 50 04             	mov    0x4(%eax),%edx
  102f0c:	8b 45 f8             	mov    -0x8(%ebp),%eax
  102f0f:	25 ff 0f 00 00       	and    $0xfff,%eax
  102f14:	89 d1                	mov    %edx,%ecx
  102f16:	29 c1                	sub    %eax,%ecx
  102f18:	89 c8                	mov    %ecx,%eax
  102f1a:	3d ff 0f 00 00       	cmp    $0xfff,%eax
  102f1f:	76 2d                	jbe    102f4e <_malloc_checkforfree+0xaa>
  102f21:	8b 45 f8             	mov    -0x8(%ebp),%eax
  102f24:	25 ff 0f 00 00       	and    $0xfff,%eax
  102f29:	83 f8 0b             	cmp    $0xb,%eax
  102f2c:	76 20                	jbe    102f4e <_malloc_checkforfree+0xaa>
      cur->size -= PAGE_SIZE;
  102f2e:	8b 45 f8             	mov    -0x8(%ebp),%eax
  102f31:	8b 40 04             	mov    0x4(%eax),%eax
  102f34:	8d 90 00 f0 ff ff    	lea    -0x1000(%eax),%edx
  102f3a:	8b 45 f8             	mov    -0x8(%ebp),%eax
  102f3d:	89 50 04             	mov    %edx,0x4(%eax)
      /**
       * Die If-Abfrage gilt im Moment nur wenn der Block an einer Pagegrenze aufhört.
       * Der Block muss (manchmal) in _mehrere_ (2) Blöcke gespalten werden. Der 1te muss
       * dann auch auf den 2ten zeigen.
       */
       _malloc_freepage(0/** @todo **/);
  102f40:	a1 3c e9 10 00       	mov    0x10e93c,%eax
  102f45:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  102f4c:	ff d0                	call   *%eax
    }
    last = cur;
  102f4e:	8b 45 f8             	mov    -0x8(%ebp),%eax
  102f51:	89 45 fc             	mov    %eax,-0x4(%ebp)
    cur = cur->nextfree;
  102f54:	8b 45 f8             	mov    -0x8(%ebp),%eax
  102f57:	8b 40 08             	mov    0x8(%eax),%eax
  102f5a:	89 45 f8             	mov    %eax,-0x8(%ebp)
 */
void _malloc_checkforfree() {
  struct _malloc_header *cur = _malloc_firstfree;
  struct _malloc_header *last = NULL;

  while (cur!=NULL) {
  102f5d:	83 7d f8 00          	cmpl   $0x0,-0x8(%ebp)
  102f61:	0f 85 57 ff ff ff    	jne    102ebe <_malloc_checkforfree+0x1a>
       _malloc_freepage(0/** @todo **/);
    }
    last = cur;
    cur = cur->nextfree;
  }
}
  102f67:	c9                   	leave  
  102f68:	c3                   	ret    

00102f69 <malloc>:
/**
 * Allocates memory
 *  @param size How many bytes
 *  @return Pointer to allocated memory
 */
void *malloc(size_t size) {
  102f69:	55                   	push   %ebp
  102f6a:	89 e5                	mov    %esp,%ebp
  102f6c:	83 ec 18             	sub    $0x18,%esp
  struct _malloc_header *mem = _malloc_getfree(size+sizeof(struct _malloc_header));
  102f6f:	8b 45 08             	mov    0x8(%ebp),%eax
  102f72:	83 c0 0c             	add    $0xc,%eax
  102f75:	89 04 24             	mov    %eax,(%esp)
  102f78:	e8 27 fe ff ff       	call   102da4 <_malloc_getfree>
  102f7d:	89 45 fc             	mov    %eax,-0x4(%ebp)
  if (mem==NULL) return NULL;
  102f80:	83 7d fc 00          	cmpl   $0x0,-0x4(%ebp)
  102f84:	75 09                	jne    102f8f <malloc+0x26>
  102f86:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
  102f8d:	eb 09                	jmp    102f98 <malloc+0x2f>
  else return mem+1;
  102f8f:	8b 45 fc             	mov    -0x4(%ebp),%eax
  102f92:	83 c0 0c             	add    $0xc,%eax
  102f95:	89 45 ec             	mov    %eax,-0x14(%ebp)
  102f98:	8b 45 ec             	mov    -0x14(%ebp),%eax
}
  102f9b:	c9                   	leave  
  102f9c:	c3                   	ret    

00102f9d <free>:
/**
 * Frees memory
 *  @param address Pointer to memory to free
 *  @todo free free pages
 */
void free(void* address) {
  102f9d:	55                   	push   %ebp
  102f9e:	89 e5                	mov    %esp,%ebp
  102fa0:	83 ec 14             	sub    $0x14,%esp
  struct _malloc_header *header = ((struct _malloc_header*)address)-1;
  102fa3:	8b 45 08             	mov    0x8(%ebp),%eax
  102fa6:	83 e8 0c             	sub    $0xc,%eax
  102fa9:	89 45 fc             	mov    %eax,-0x4(%ebp)
  header->flags = 0; ///< mark block as free
  102fac:	8b 45 fc             	mov    -0x4(%ebp),%eax
  102faf:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
  _malloc_insertlist(header);
  102fb5:	8b 45 fc             	mov    -0x4(%ebp),%eax
  102fb8:	89 04 24             	mov    %eax,(%esp)
  102fbb:	e8 93 fc ff ff       	call   102c53 <_malloc_insertlist>

  //_malloc_checkforfree();
}
  102fc0:	c9                   	leave  
  102fc1:	c3                   	ret    

00102fc2 <realloc>:
 * Reallocates block
 *  @param address Address of block
 *  @param size New block size
 *  @return Pointer to new block
 */
void* realloc(void* address, size_t size) {
  102fc2:	55                   	push   %ebp
  102fc3:	89 e5                	mov    %esp,%ebp
  102fc5:	83 ec 38             	sub    $0x38,%esp
  struct _malloc_header *header = ((struct _malloc_header*)address)-1;
  102fc8:	8b 45 08             	mov    0x8(%ebp),%eax
  102fcb:	83 e8 0c             	sub    $0xc,%eax
  102fce:	89 45 ec             	mov    %eax,-0x14(%ebp)
  if (size==0) {
  102fd1:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
  102fd5:	75 17                	jne    102fee <realloc+0x2c>
    free(address);
  102fd7:	8b 45 08             	mov    0x8(%ebp),%eax
  102fda:	89 04 24             	mov    %eax,(%esp)
  102fdd:	e8 bb ff ff ff       	call   102f9d <free>
    address = NULL;
  102fe2:	c7 45 08 00 00 00 00 	movl   $0x0,0x8(%ebp)
  102fe9:	e9 5a 01 00 00       	jmp    103148 <realloc+0x186>
  }
  else if (size<header->size) { // make block smaller (split)
  102fee:	8b 45 ec             	mov    -0x14(%ebp),%eax
  102ff1:	8b 40 04             	mov    0x4(%eax),%eax
  102ff4:	3b 45 0c             	cmp    0xc(%ebp),%eax
  102ff7:	76 50                	jbe    103049 <realloc+0x87>
    if (header->size-size<sizeof(struct _malloc_header)); /// @todo what to do?
  102ff9:	8b 45 ec             	mov    -0x14(%ebp),%eax
  102ffc:	8b 40 04             	mov    0x4(%eax),%eax
  102fff:	2b 45 0c             	sub    0xc(%ebp),%eax
  103002:	83 f8 0b             	cmp    $0xb,%eax
  103005:	0f 86 3d 01 00 00    	jbe    103148 <realloc+0x186>
    else {
      struct _malloc_header *new = (struct _malloc_header*)(((uint8_t*)header)+size);
  10300b:	8b 55 0c             	mov    0xc(%ebp),%edx
  10300e:	8b 45 ec             	mov    -0x14(%ebp),%eax
  103011:	01 d0                	add    %edx,%eax
  103013:	89 45 f0             	mov    %eax,-0x10(%ebp)
      new->flags = 0;
  103016:	8b 45 f0             	mov    -0x10(%ebp),%eax
  103019:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
      new->size = header->size-size;
  10301f:	8b 45 ec             	mov    -0x14(%ebp),%eax
  103022:	8b 40 04             	mov    0x4(%eax),%eax
  103025:	89 c2                	mov    %eax,%edx
  103027:	2b 55 0c             	sub    0xc(%ebp),%edx
  10302a:	8b 45 f0             	mov    -0x10(%ebp),%eax
  10302d:	89 50 04             	mov    %edx,0x4(%eax)
      _malloc_insertlist(new);
  103030:	8b 45 f0             	mov    -0x10(%ebp),%eax
  103033:	89 04 24             	mov    %eax,(%esp)
  103036:	e8 18 fc ff ff       	call   102c53 <_malloc_insertlist>
      header->size = size;
  10303b:	8b 55 ec             	mov    -0x14(%ebp),%edx
  10303e:	8b 45 0c             	mov    0xc(%ebp),%eax
  103041:	89 42 04             	mov    %eax,0x4(%edx)
  103044:	e9 ff 00 00 00       	jmp    103148 <realloc+0x186>
    }
  }
  else if (size>header->size) {
  103049:	8b 45 ec             	mov    -0x14(%ebp),%eax
  10304c:	8b 40 04             	mov    0x4(%eax),%eax
  10304f:	3b 45 0c             	cmp    0xc(%ebp),%eax
  103052:	0f 83 f0 00 00 00    	jae    103148 <realloc+0x186>
    struct _malloc_header *cur = _malloc_firstfree;
  103058:	a1 38 e9 10 00       	mov    0x10e938,%eax
  10305d:	89 45 f4             	mov    %eax,-0xc(%ebp)
  103060:	e9 93 00 00 00       	jmp    1030f8 <realloc+0x136>
    while (cur!=NULL) {
      if (cur==header+header->size && cur->size>=size-header->size) { // use next block
  103065:	8b 45 ec             	mov    -0x14(%ebp),%eax
  103068:	8b 50 04             	mov    0x4(%eax),%edx
  10306b:	89 d0                	mov    %edx,%eax
  10306d:	01 c0                	add    %eax,%eax
  10306f:	01 d0                	add    %edx,%eax
  103071:	c1 e0 02             	shl    $0x2,%eax
  103074:	03 45 ec             	add    -0x14(%ebp),%eax
  103077:	3b 45 f4             	cmp    -0xc(%ebp),%eax
  10307a:	75 73                	jne    1030ef <realloc+0x12d>
  10307c:	8b 45 f4             	mov    -0xc(%ebp),%eax
  10307f:	8b 48 04             	mov    0x4(%eax),%ecx
  103082:	8b 45 ec             	mov    -0x14(%ebp),%eax
  103085:	8b 50 04             	mov    0x4(%eax),%edx
  103088:	8b 45 0c             	mov    0xc(%ebp),%eax
  10308b:	29 d0                	sub    %edx,%eax
  10308d:	39 c1                	cmp    %eax,%ecx
  10308f:	72 5e                	jb     1030ef <realloc+0x12d>
        if (cur->size-(size-header->size)<sizeof(struct _malloc_header)); /// @todo what to do?
  103091:	8b 45 f4             	mov    -0xc(%ebp),%eax
  103094:	8b 50 04             	mov    0x4(%eax),%edx
  103097:	8b 45 ec             	mov    -0x14(%ebp),%eax
  10309a:	8b 40 04             	mov    0x4(%eax),%eax
  10309d:	2b 45 0c             	sub    0xc(%ebp),%eax
  1030a0:	8d 04 02             	lea    (%edx,%eax,1),%eax
  1030a3:	83 f8 0b             	cmp    $0xb,%eax
  1030a6:	76 5a                	jbe    103102 <realloc+0x140>
        else {
          struct _malloc_header *new = (struct _malloc_header*)(((uint8_t*)cur)+size-header->size);
  1030a8:	8b 45 ec             	mov    -0x14(%ebp),%eax
  1030ab:	8b 50 04             	mov    0x4(%eax),%edx
  1030ae:	8b 45 0c             	mov    0xc(%ebp),%eax
  1030b1:	29 d0                	sub    %edx,%eax
  1030b3:	03 45 f4             	add    -0xc(%ebp),%eax
  1030b6:	89 45 f8             	mov    %eax,-0x8(%ebp)
          new->flags = 0;
  1030b9:	8b 45 f8             	mov    -0x8(%ebp),%eax
  1030bc:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
          new->size = cur->size-(size-header->size);
  1030c2:	8b 45 f4             	mov    -0xc(%ebp),%eax
  1030c5:	8b 50 04             	mov    0x4(%eax),%edx
  1030c8:	8b 45 ec             	mov    -0x14(%ebp),%eax
  1030cb:	8b 40 04             	mov    0x4(%eax),%eax
  1030ce:	2b 45 0c             	sub    0xc(%ebp),%eax
  1030d1:	01 c2                	add    %eax,%edx
  1030d3:	8b 45 f8             	mov    -0x8(%ebp),%eax
  1030d6:	89 50 04             	mov    %edx,0x4(%eax)
          _malloc_insertlist(new);
  1030d9:	8b 45 f8             	mov    -0x8(%ebp),%eax
  1030dc:	89 04 24             	mov    %eax,(%esp)
  1030df:	e8 6f fb ff ff       	call   102c53 <_malloc_insertlist>
          header->size = size;
  1030e4:	8b 55 ec             	mov    -0x14(%ebp),%edx
  1030e7:	8b 45 0c             	mov    0xc(%ebp),%eax
  1030ea:	89 42 04             	mov    %eax,0x4(%edx)
  1030ed:	eb 13                	jmp    103102 <realloc+0x140>
        }
        break;
      }
      cur = cur->nextfree;
  1030ef:	8b 45 f4             	mov    -0xc(%ebp),%eax
  1030f2:	8b 40 08             	mov    0x8(%eax),%eax
  1030f5:	89 45 f4             	mov    %eax,-0xc(%ebp)
      header->size = size;
    }
  }
  else if (size>header->size) {
    struct _malloc_header *cur = _malloc_firstfree;
    while (cur!=NULL) {
  1030f8:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
  1030fc:	0f 85 63 ff ff ff    	jne    103065 <realloc+0xa3>
        }
        break;
      }
      cur = cur->nextfree;
    }
    if (header->size!=size) { // no space: malloc, memcpy, free
  103102:	8b 45 ec             	mov    -0x14(%ebp),%eax
  103105:	8b 40 04             	mov    0x4(%eax),%eax
  103108:	3b 45 0c             	cmp    0xc(%ebp),%eax
  10310b:	74 3b                	je     103148 <realloc+0x186>
      void *new = malloc(size);
  10310d:	8b 45 0c             	mov    0xc(%ebp),%eax
  103110:	89 04 24             	mov    %eax,(%esp)
  103113:	e8 51 fe ff ff       	call   102f69 <malloc>
  103118:	89 45 fc             	mov    %eax,-0x4(%ebp)
      memcpy(new,address,header->size);
  10311b:	8b 45 ec             	mov    -0x14(%ebp),%eax
  10311e:	8b 40 04             	mov    0x4(%eax),%eax
  103121:	89 44 24 08          	mov    %eax,0x8(%esp)
  103125:	8b 45 08             	mov    0x8(%ebp),%eax
  103128:	89 44 24 04          	mov    %eax,0x4(%esp)
  10312c:	8b 45 fc             	mov    -0x4(%ebp),%eax
  10312f:	89 04 24             	mov    %eax,(%esp)
  103132:	e8 4d 8a 00 00       	call   10bb84 <memcpy>
      free(address);
  103137:	8b 45 08             	mov    0x8(%ebp),%eax
  10313a:	89 04 24             	mov    %eax,(%esp)
  10313d:	e8 5b fe ff ff       	call   102f9d <free>
      address = new;
  103142:	8b 45 fc             	mov    -0x4(%ebp),%eax
  103145:	89 45 08             	mov    %eax,0x8(%ebp)
    }
  }
  return address;
  103148:	8b 45 08             	mov    0x8(%ebp),%eax
}
  10314b:	c9                   	leave  
  10314c:	c3                   	ret    

0010314d <calloc>:
/**
 * Allocates memory for an array of n elements where each element is elsize bytes large.
 *  @param n Number of elements
 *  @param elsize Size of each element
 */
void* calloc(size_t n,size_t elsize) {
  10314d:	55                   	push   %ebp
  10314e:	89 e5                	mov    %esp,%ebp
  103150:	83 ec 28             	sub    $0x28,%esp
  if (n==0 || elsize==0) return NULL;
  103153:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
  103157:	74 06                	je     10315f <calloc+0x12>
  103159:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
  10315d:	75 09                	jne    103168 <calloc+0x1b>
  10315f:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
  103166:	eb 36                	jmp    10319e <calloc+0x51>
  void *mem = malloc(n*elsize);
  103168:	8b 45 08             	mov    0x8(%ebp),%eax
  10316b:	0f af 45 0c          	imul   0xc(%ebp),%eax
  10316f:	89 04 24             	mov    %eax,(%esp)
  103172:	e8 f2 fd ff ff       	call   102f69 <malloc>
  103177:	89 45 fc             	mov    %eax,-0x4(%ebp)
  memset(mem,0,n*elsize);
  10317a:	8b 45 08             	mov    0x8(%ebp),%eax
  10317d:	0f af 45 0c          	imul   0xc(%ebp),%eax
  103181:	89 44 24 08          	mov    %eax,0x8(%esp)
  103185:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  10318c:	00 
  10318d:	8b 45 fc             	mov    -0x4(%ebp),%eax
  103190:	89 04 24             	mov    %eax,(%esp)
  103193:	e8 c9 8b 00 00       	call   10bd61 <memset>
  return mem;
  103198:	8b 45 fc             	mov    -0x4(%ebp),%eax
  10319b:	89 45 ec             	mov    %eax,-0x14(%ebp)
  10319e:	8b 45 ec             	mov    -0x14(%ebp),%eax
}
  1031a1:	c9                   	leave  
  1031a2:	c3                   	ret    
	...

001031a4 <memkernel_init>:
 */
void *init_stack;
size_t init_stacksize;
void malloc_init(void *(*getpage)(size_t size),void (*freepage)(void *addr));
void malloc_donatemem(void *addr,size_t size);
int memkernel_init() {
  1031a4:	55                   	push   %ebp
  1031a5:	89 e5                	mov    %esp,%ebp
  1031a7:	83 ec 08             	sub    $0x8,%esp
  malloc_init(memkernel_alloc,memkernel_free);
  1031aa:	c7 44 24 04 3a 33 10 	movl   $0x10333a,0x4(%esp)
  1031b1:	00 
  1031b2:	c7 04 24 9e 32 10 00 	movl   $0x10329e,(%esp)
  1031b9:	e8 76 fa ff ff       	call   102c34 <malloc_init>
  malloc_donatemem(init_stack,init_stacksize); // donate initial stack to memory allocator
  1031be:	a1 44 00 10 00       	mov    0x100044,%eax
  1031c3:	8b 15 58 e9 10 00    	mov    0x10e958,%edx
  1031c9:	89 44 24 04          	mov    %eax,0x4(%esp)
  1031cd:	89 14 24             	mov    %edx,(%esp)
  1031d0:	e8 6f fb ff ff       	call   102d44 <malloc_donatemem>
  return 0;
  1031d5:	b8 00 00 00 00       	mov    $0x0,%eax
}
  1031da:	c9                   	leave  
  1031db:	c3                   	ret    

001031dc <memkernel_findvirt>:
/**
 * Finds free virtual pages
 *  @param pages How many pages wanted
 *  @return Address of first page
 */
void *memkernel_findvirt(size_t pages) {
  1031dc:	55                   	push   %ebp
  1031dd:	89 e5                	mov    %esp,%ebp
  1031df:	83 ec 28             	sub    $0x28,%esp
  void *virt;
  size_t found = 0;
  1031e2:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)

  for (virt = (void*)KERNELDATA_ADDRESS;virt<(void*)KERNELDATA_ADDRESS+KERNELDATA_SIZE;virt+=PAGE_SIZE) {
  1031e9:	c7 45 f8 00 00 70 00 	movl   $0x700000,-0x8(%ebp)
  1031f0:	e9 90 00 00 00       	jmp    103285 <memkernel_findvirt+0xa9>
    // check if enough pages are found
    if (found>=pages) return virt-found*PAGE_SIZE;
  1031f5:	8b 45 fc             	mov    -0x4(%ebp),%eax
  1031f8:	3b 45 08             	cmp    0x8(%ebp),%eax
  1031fb:	72 15                	jb     103212 <memkernel_findvirt+0x36>
  1031fd:	8b 45 fc             	mov    -0x4(%ebp),%eax
  103200:	c1 e0 0c             	shl    $0xc,%eax
  103203:	f7 d8                	neg    %eax
  103205:	8b 55 f8             	mov    -0x8(%ebp),%edx
  103208:	01 c2                	add    %eax,%edx
  10320a:	89 55 ec             	mov    %edx,-0x14(%ebp)
  10320d:	e9 87 00 00 00       	jmp    103299 <memkernel_findvirt+0xbd>
    if (ADDR2PTE(virt)==0) {
  103212:	8b 45 f8             	mov    -0x8(%ebp),%eax
  103215:	c1 e8 0c             	shr    $0xc,%eax
  103218:	25 ff 03 00 00       	and    $0x3ff,%eax
  10321d:	85 c0                	test   %eax,%eax
  10321f:	75 30                	jne    103251 <memkernel_findvirt+0x75>
      // check for PDE
      if (!paging_getpde(virt).exists) {
  103221:	8d 55 f0             	lea    -0x10(%ebp),%edx
  103224:	8b 45 f8             	mov    -0x8(%ebp),%eax
  103227:	89 44 24 04          	mov    %eax,0x4(%esp)
  10322b:	89 14 24             	mov    %edx,(%esp)
  10322e:	e8 10 22 00 00       	call   105443 <paging_getpde>
  103233:	83 ec 04             	sub    $0x4,%esp
  103236:	0f b6 45 f0          	movzbl -0x10(%ebp),%eax
  10323a:	83 e0 01             	and    $0x1,%eax
  10323d:	84 c0                	test   %al,%al
  10323f:	75 10                	jne    103251 <memkernel_findvirt+0x75>
        found += 1024;
  103241:	81 45 fc 00 04 00 00 	addl   $0x400,-0x4(%ebp)
        virt += 1024*(PAGE_SIZE-1);
  103248:	81 45 f8 00 fc 3f 00 	addl   $0x3ffc00,-0x8(%ebp)
  10324f:	eb 2d                	jmp    10327e <memkernel_findvirt+0xa2>
        continue;
      }
    }
    // check for PTE
    if (paging_getpte(virt).exists) found = 0;
  103251:	8d 55 f4             	lea    -0xc(%ebp),%edx
  103254:	8b 45 f8             	mov    -0x8(%ebp),%eax
  103257:	89 44 24 04          	mov    %eax,0x4(%esp)
  10325b:	89 14 24             	mov    %edx,(%esp)
  10325e:	e8 80 22 00 00       	call   1054e3 <paging_getpte>
  103263:	83 ec 04             	sub    $0x4,%esp
  103266:	0f b6 45 f5          	movzbl -0xb(%ebp),%eax
  10326a:	83 e0 02             	and    $0x2,%eax
  10326d:	84 c0                	test   %al,%al
  10326f:	74 09                	je     10327a <memkernel_findvirt+0x9e>
  103271:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
  103278:	eb 04                	jmp    10327e <memkernel_findvirt+0xa2>
    else found++;
  10327a:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
 */
void *memkernel_findvirt(size_t pages) {
  void *virt;
  size_t found = 0;

  for (virt = (void*)KERNELDATA_ADDRESS;virt<(void*)KERNELDATA_ADDRESS+KERNELDATA_SIZE;virt+=PAGE_SIZE) {
  10327e:	81 45 f8 00 10 00 00 	addl   $0x1000,-0x8(%ebp)
  103285:	81 7d f8 ff ff ff 3f 	cmpl   $0x3fffffff,-0x8(%ebp)
  10328c:	0f 86 63 ff ff ff    	jbe    1031f5 <memkernel_findvirt+0x19>
    // check for PTE
    if (paging_getpte(virt).exists) found = 0;
    else found++;
  }

  return NULL;
  103292:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
  103299:	8b 45 ec             	mov    -0x14(%ebp),%eax
}
  10329c:	c9                   	leave  
  10329d:	c3                   	ret    

0010329e <memkernel_alloc>:
/**
 * Allocates memory for kernel allocator
 *  @param size How many memory to allocate (should be devidable by PAGE_SIZE)
 *  @return Address of allocated memory
 */
void *memkernel_alloc(size_t size) {
  10329e:	55                   	push   %ebp
  10329f:	89 e5                	mov    %esp,%ebp
  1032a1:	53                   	push   %ebx
  1032a2:	83 ec 34             	sub    $0x34,%esp
  size_t pages = ADDR2PAGE(size);
  1032a5:	8b 45 08             	mov    0x8(%ebp),%eax
  1032a8:	c1 e8 0c             	shr    $0xc,%eax
  1032ab:	89 45 f0             	mov    %eax,-0x10(%ebp)
  size_t i;
  void *virt = memkernel_findvirt(pages);
  1032ae:	8b 45 f0             	mov    -0x10(%ebp),%eax
  1032b1:	89 04 24             	mov    %eax,(%esp)
  1032b4:	e8 23 ff ff ff       	call   1031dc <memkernel_findvirt>
  1032b9:	89 45 f8             	mov    %eax,-0x8(%ebp)

  for (i=0;i<pages;i++) {
  1032bc:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  1032c3:	eb 64                	jmp    103329 <memkernel_alloc+0x8b>
    paging_map(virt+i*PAGE_SIZE,memphys_alloc(),0,1);
  1032c5:	8b 1d 74 e4 10 00    	mov    0x10e474,%ebx
  1032cb:	e8 e5 01 00 00       	call   1034b5 <memphys_pop>
  1032d0:	89 c2                	mov    %eax,%edx
  1032d2:	8b 45 f4             	mov    -0xc(%ebp),%eax
  1032d5:	c1 e0 0c             	shl    $0xc,%eax
  1032d8:	03 45 f8             	add    -0x8(%ebp),%eax
  1032db:	89 5c 24 18          	mov    %ebx,0x18(%esp)
  1032df:	c7 44 24 14 00 00 00 	movl   $0x0,0x14(%esp)
  1032e6:	00 
  1032e7:	c7 44 24 10 00 00 00 	movl   $0x0,0x10(%esp)
  1032ee:	00 
  1032ef:	c7 44 24 0c 01 00 00 	movl   $0x1,0xc(%esp)
  1032f6:	00 
  1032f7:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  1032fe:	00 
  1032ff:	89 54 24 04          	mov    %edx,0x4(%esp)
  103303:	89 04 24             	mov    %eax,(%esp)
  103306:	e8 32 25 00 00       	call   10583d <paging_map_pd>
    if (memuser_inited) memuser_syncpds(virt+i);
  10330b:	a1 88 e1 10 00       	mov    0x10e188,%eax
  103310:	85 c0                	test   %eax,%eax
  103312:	74 11                	je     103325 <memkernel_alloc+0x87>
  103314:	8b 45 f4             	mov    -0xc(%ebp),%eax
  103317:	8b 55 f8             	mov    -0x8(%ebp),%edx
  10331a:	8d 04 02             	lea    (%edx,%eax,1),%eax
  10331d:	89 04 24             	mov    %eax,(%esp)
  103320:	e8 17 10 00 00       	call   10433c <memuser_syncpds>
void *memkernel_alloc(size_t size) {
  size_t pages = ADDR2PAGE(size);
  size_t i;
  void *virt = memkernel_findvirt(pages);

  for (i=0;i<pages;i++) {
  103325:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
  103329:	8b 45 f4             	mov    -0xc(%ebp),%eax
  10332c:	3b 45 f0             	cmp    -0x10(%ebp),%eax
  10332f:	72 94                	jb     1032c5 <memkernel_alloc+0x27>
    paging_map(virt+i*PAGE_SIZE,memphys_alloc(),0,1);
    if (memuser_inited) memuser_syncpds(virt+i);
  }
  return virt;
  103331:	8b 45 f8             	mov    -0x8(%ebp),%eax
}
  103334:	83 c4 34             	add    $0x34,%esp
  103337:	5b                   	pop    %ebx
  103338:	5d                   	pop    %ebp
  103339:	c3                   	ret    

0010333a <memkernel_free>:

/**
 * Frees memory (one page) for kernel allocator
 */
void memkernel_free(void *addr) {
  10333a:	55                   	push   %ebp
  10333b:	89 e5                	mov    %esp,%ebp
  10333d:	83 ec 08             	sub    $0x8,%esp
  memphys_free(paging_unmap(addr));
  103340:	8b 45 08             	mov    0x8(%ebp),%eax
  103343:	89 04 24             	mov    %eax,(%esp)
  103346:	e8 0c 27 00 00       	call   105a57 <paging_unmap>
  10334b:	89 04 24             	mov    %eax,(%esp)
  10334e:	e8 c1 00 00 00       	call   103414 <memphys_push>
}
  103353:	c9                   	leave  
  103354:	c3                   	ret    
  103355:	00 00                	add    %al,(%eax)
	...

00103358 <memphys_init>:

/**
 * Initializes physical memory management
 *  @return -1=Success; 0=Failure
 */
int memphys_init() {
  103358:	55                   	push   %ebp
  103359:	89 e5                	mov    %esp,%ebp
  10335b:	53                   	push   %ebx
  10335c:	83 ec 34             	sub    $0x34,%esp
  memphys_memory = (multiboot_get_memlower()+multiboot_get_memlower());
  10335f:	e8 32 1a 00 00       	call   104d96 <multiboot_get_memlower>
  103364:	89 c3                	mov    %eax,%ebx
  103366:	e8 2b 1a 00 00       	call   104d96 <multiboot_get_memlower>
  10336b:	8d 04 03             	lea    (%ebx,%eax,1),%eax
  10336e:	a3 68 e4 10 00       	mov    %eax,0x10e468

  memphys_stackbase = (void*)STACKDATA_ADDRESS;
  103373:	c7 05 8c e1 10 00 00 	movl   $0x300000,0x10e18c
  10337a:	00 30 00 
  memphys_stackend = memphys_stackbase;
  10337d:	a1 8c e1 10 00       	mov    0x10e18c,%eax
  103382:	a3 70 e4 10 00       	mov    %eax,0x10e470
  memphys_stackptr = memphys_stackbase;
  103387:	a1 8c e1 10 00       	mov    0x10e18c,%eax
  10338c:	a3 6c e4 10 00       	mov    %eax,0x10e46c

  // push free memory on stack
  size_t i = 0;
  103391:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  103398:	eb 47                	jmp    1033e1 <memphys_init+0x89>
  void *addr;
  size_t size;
  multiboot_mmap_type_t type;
  while (multiboot_get_mmap(i++,&addr,&size,&type)==0) {
    if (type==MULTIBOOT_FREE) {
  10339a:	8b 45 e8             	mov    -0x18(%ebp),%eax
  10339d:	83 f8 01             	cmp    $0x1,%eax
  1033a0:	75 3f                	jne    1033e1 <memphys_init+0x89>
      size_t j;
      for (j=0;j<size/PAGE_SIZE;j++) {
  1033a2:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
  1033a9:	eb 2b                	jmp    1033d6 <memphys_init+0x7e>
        if (addr+j*PAGE_SIZE>=(void*)FREEPHYS_ADDRESS) memphys_push(addr+j*PAGE_SIZE);
  1033ab:	8b 55 f0             	mov    -0x10(%ebp),%edx
  1033ae:	8b 45 f8             	mov    -0x8(%ebp),%eax
  1033b1:	c1 e0 0c             	shl    $0xc,%eax
  1033b4:	8d 04 02             	lea    (%edx,%eax,1),%eax
  1033b7:	3d ff 2f 30 00       	cmp    $0x302fff,%eax
  1033bc:	76 14                	jbe    1033d2 <memphys_init+0x7a>
  1033be:	8b 55 f0             	mov    -0x10(%ebp),%edx
  1033c1:	8b 45 f8             	mov    -0x8(%ebp),%eax
  1033c4:	c1 e0 0c             	shl    $0xc,%eax
  1033c7:	8d 04 02             	lea    (%edx,%eax,1),%eax
  1033ca:	89 04 24             	mov    %eax,(%esp)
  1033cd:	e8 42 00 00 00       	call   103414 <memphys_push>
  size_t size;
  multiboot_mmap_type_t type;
  while (multiboot_get_mmap(i++,&addr,&size,&type)==0) {
    if (type==MULTIBOOT_FREE) {
      size_t j;
      for (j=0;j<size/PAGE_SIZE;j++) {
  1033d2:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
  1033d6:	8b 45 ec             	mov    -0x14(%ebp),%eax
  1033d9:	c1 e8 0c             	shr    $0xc,%eax
  1033dc:	3b 45 f8             	cmp    -0x8(%ebp),%eax
  1033df:	77 ca                	ja     1033ab <memphys_init+0x53>
  // push free memory on stack
  size_t i = 0;
  void *addr;
  size_t size;
  multiboot_mmap_type_t type;
  while (multiboot_get_mmap(i++,&addr,&size,&type)==0) {
  1033e1:	8b 55 f4             	mov    -0xc(%ebp),%edx
  1033e4:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
  1033e8:	8d 45 e8             	lea    -0x18(%ebp),%eax
  1033eb:	89 44 24 0c          	mov    %eax,0xc(%esp)
  1033ef:	8d 45 ec             	lea    -0x14(%ebp),%eax
  1033f2:	89 44 24 08          	mov    %eax,0x8(%esp)
  1033f6:	8d 45 f0             	lea    -0x10(%ebp),%eax
  1033f9:	89 44 24 04          	mov    %eax,0x4(%esp)
  1033fd:	89 14 24             	mov    %edx,(%esp)
  103400:	e8 44 1a 00 00       	call   104e49 <multiboot_get_mmap>
  103405:	85 c0                	test   %eax,%eax
  103407:	74 91                	je     10339a <memphys_init+0x42>
        if (addr+j*PAGE_SIZE>=(void*)FREEPHYS_ADDRESS) memphys_push(addr+j*PAGE_SIZE);
      }
    }
  }

  return 0;
  103409:	b8 00 00 00 00       	mov    $0x0,%eax
}
  10340e:	83 c4 34             	add    $0x34,%esp
  103411:	5b                   	pop    %ebx
  103412:	5d                   	pop    %ebp
  103413:	c3                   	ret    

00103414 <memphys_push>:

/**
 * Pushs an address on stack
 *  @param addr Address to push on stack
 */
void memphys_push(void *addr) {
  103414:	55                   	push   %ebp
  103415:	89 e5                	mov    %esp,%ebp
  103417:	83 ec 28             	sub    $0x28,%esp
  if (addr==NULL) return;
  10341a:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
  10341e:	0f 84 8f 00 00 00    	je     1034b3 <memphys_push+0x9f>
  if (memphys_stackptr==memphys_stackend) {
  103424:	8b 15 6c e4 10 00    	mov    0x10e46c,%edx
  10342a:	a1 70 e4 10 00       	mov    0x10e470,%eax
  10342f:	39 c2                	cmp    %eax,%edx
  103431:	75 68                	jne    10349b <memphys_push+0x87>
    // use pushed page as stackpage
    if (paging_map(memphys_stackend,addr,0,1)<0) panic("Error while mapping stackpage: 0x%x",memphys_stackend);
  103433:	a1 74 e4 10 00       	mov    0x10e474,%eax
  103438:	8b 15 70 e4 10 00    	mov    0x10e470,%edx
  10343e:	89 44 24 18          	mov    %eax,0x18(%esp)
  103442:	c7 44 24 14 00 00 00 	movl   $0x0,0x14(%esp)
  103449:	00 
  10344a:	c7 44 24 10 00 00 00 	movl   $0x0,0x10(%esp)
  103451:	00 
  103452:	c7 44 24 0c 01 00 00 	movl   $0x1,0xc(%esp)
  103459:	00 
  10345a:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  103461:	00 
  103462:	8b 45 08             	mov    0x8(%ebp),%eax
  103465:	89 44 24 04          	mov    %eax,0x4(%esp)
  103469:	89 14 24             	mov    %edx,(%esp)
  10346c:	e8 cc 23 00 00       	call   10583d <paging_map_pd>
  103471:	85 c0                	test   %eax,%eax
  103473:	79 15                	jns    10348a <memphys_push+0x76>
  103475:	a1 70 e4 10 00       	mov    0x10e470,%eax
  10347a:	89 44 24 04          	mov    %eax,0x4(%esp)
  10347e:	c7 04 24 0c d6 10 00 	movl   $0x10d60c,(%esp)
  103485:	e8 31 ef ff ff       	call   1023bb <panic>
    memphys_stackend += PAGE_SIZE/sizeof(void*);
  10348a:	a1 70 e4 10 00       	mov    0x10e470,%eax
  10348f:	05 00 10 00 00       	add    $0x1000,%eax
  103494:	a3 70 e4 10 00       	mov    %eax,0x10e470
  103499:	eb 18                	jmp    1034b3 <memphys_push+0x9f>
  }
  else {
    // just push page on stack
    *memphys_stackptr = addr;
  10349b:	8b 15 6c e4 10 00    	mov    0x10e46c,%edx
  1034a1:	8b 45 08             	mov    0x8(%ebp),%eax
  1034a4:	89 02                	mov    %eax,(%edx)
    memphys_stackptr++;
  1034a6:	a1 6c e4 10 00       	mov    0x10e46c,%eax
  1034ab:	83 c0 04             	add    $0x4,%eax
  1034ae:	a3 6c e4 10 00       	mov    %eax,0x10e46c
  }
}
  1034b3:	c9                   	leave  
  1034b4:	c3                   	ret    

001034b5 <memphys_pop>:
/**
 * Pops an address from stack
 *  @return Address popped from stack
 *  @todo Check whether address is already used for DMA
 */
void *memphys_pop() {
  1034b5:	55                   	push   %ebp
  1034b6:	89 e5                	mov    %esp,%ebp
  1034b8:	83 ec 18             	sub    $0x18,%esp
  void *page = NULL;
  1034bb:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
  if (memphys_stackptr>memphys_stackbase) {
  1034c2:	8b 15 6c e4 10 00    	mov    0x10e46c,%edx
  1034c8:	a1 8c e1 10 00       	mov    0x10e18c,%eax
  1034cd:	39 c2                	cmp    %eax,%edx
  1034cf:	76 58                	jbe    103529 <memphys_pop+0x74>
    if (memphys_stackptr-memphys_stackend>PAGE_SIZE) {
  1034d1:	a1 6c e4 10 00       	mov    0x10e46c,%eax
  1034d6:	89 c2                	mov    %eax,%edx
  1034d8:	a1 70 e4 10 00       	mov    0x10e470,%eax
  1034dd:	89 d1                	mov    %edx,%ecx
  1034df:	29 c1                	sub    %eax,%ecx
  1034e1:	89 c8                	mov    %ecx,%eax
  1034e3:	3d 03 40 00 00       	cmp    $0x4003,%eax
  1034e8:	7e 26                	jle    103510 <memphys_pop+0x5b>
      // free stackpage and return it
      memphys_stackend -= PAGE_SIZE;
  1034ea:	a1 70 e4 10 00       	mov    0x10e470,%eax
  1034ef:	2d 00 40 00 00       	sub    $0x4000,%eax
  1034f4:	a3 70 e4 10 00       	mov    %eax,0x10e470
      paging_unmap(memphys_stackend);
  1034f9:	a1 70 e4 10 00       	mov    0x10e470,%eax
  1034fe:	89 04 24             	mov    %eax,(%esp)
  103501:	e8 51 25 00 00       	call   105a57 <paging_unmap>
      page = memphys_stackend;
  103506:	a1 70 e4 10 00       	mov    0x10e470,%eax
  10350b:	89 45 fc             	mov    %eax,-0x4(%ebp)
  10350e:	eb 25                	jmp    103535 <memphys_pop+0x80>
    }
    else {
      // just get page from stack
      memphys_stackptr--;
  103510:	a1 6c e4 10 00       	mov    0x10e46c,%eax
  103515:	83 e8 04             	sub    $0x4,%eax
  103518:	a3 6c e4 10 00       	mov    %eax,0x10e46c
      page = *memphys_stackptr;
  10351d:	a1 6c e4 10 00       	mov    0x10e46c,%eax
  103522:	8b 00                	mov    (%eax),%eax
  103524:	89 45 fc             	mov    %eax,-0x4(%ebp)
  103527:	eb 0c                	jmp    103535 <memphys_pop+0x80>
    }
  }
  else panic("Ran out of memory\n");
  103529:	c7 04 24 30 d6 10 00 	movl   $0x10d630,(%esp)
  103530:	e8 86 ee ff ff       	call   1023bb <panic>
  return page;
  103535:	8b 45 fc             	mov    -0x4(%ebp),%eax
}
  103538:	c9                   	leave  
  103539:	c3                   	ret    

0010353a <memphys_memleft>:

/**
 * Returns the amount of remaining memory
 *  @return Amount of remaining memory in bytes
 */
size_t memphys_memleft() {
  10353a:	55                   	push   %ebp
  10353b:	89 e5                	mov    %esp,%ebp
  return (((size_t)memphys_stackptr)-((size_t)memphys_stackbase))*PAGE_SIZE/4;
  10353d:	a1 6c e4 10 00       	mov    0x10e46c,%eax
  103542:	89 c2                	mov    %eax,%edx
  103544:	a1 8c e1 10 00       	mov    0x10e18c,%eax
  103549:	89 d1                	mov    %edx,%ecx
  10354b:	29 c1                	sub    %eax,%ecx
  10354d:	89 c8                	mov    %ecx,%eax
  10354f:	c1 e0 0c             	shl    $0xc,%eax
  103552:	c1 e8 02             	shr    $0x2,%eax
}
  103555:	5d                   	pop    %ebp
  103556:	c3                   	ret    

00103557 <memphys_dma_init>:

/**
 * Initializes DMA management
 *  @return Success?
 */
int memphys_dma_init() {
  103557:	55                   	push   %ebp
  103558:	89 e5                	mov    %esp,%ebp
  10355a:	83 ec 18             	sub    $0x18,%esp
  memphys_dma_bitmap_size = MEMPHYS_DMALIMIT/(PAGE_SIZE*8);
  10355d:	c7 05 84 e1 10 00 00 	movl   $0x200,0x10e184
  103564:	02 00 00 
  memphys_dma_bitmap = malloc(memphys_dma_bitmap_size);
  103567:	a1 84 e1 10 00       	mov    0x10e184,%eax
  10356c:	89 04 24             	mov    %eax,(%esp)
  10356f:	e8 f5 f9 ff ff       	call   102f69 <malloc>
  103574:	a3 58 e4 10 00       	mov    %eax,0x10e458
  // memory until free memory (BDA, Kernel Code, Stack)
  memset(memphys_dma_bitmap,0xFF,FREEPHYS_ADDRESS/(PAGE_SIZE*8));
  103579:	a1 58 e4 10 00       	mov    0x10e458,%eax
  10357e:	c7 44 24 08 60 00 00 	movl   $0x60,0x8(%esp)
  103585:	00 
  103586:	c7 44 24 04 ff 00 00 	movl   $0xff,0x4(%esp)
  10358d:	00 
  10358e:	89 04 24             	mov    %eax,(%esp)
  103591:	e8 cb 87 00 00       	call   10bd61 <memset>
  // free pages
  memset(((void*)memphys_dma_bitmap)+FREEPHYS_ADDRESS/(PAGE_SIZE*8),0,memphys_dma_bitmap_size-FREEPHYS_ADDRESS/(PAGE_SIZE*8));
  103596:	a1 84 e1 10 00       	mov    0x10e184,%eax
  10359b:	8d 50 a0             	lea    -0x60(%eax),%edx
  10359e:	a1 58 e4 10 00       	mov    0x10e458,%eax
  1035a3:	83 c0 60             	add    $0x60,%eax
  1035a6:	89 54 24 08          	mov    %edx,0x8(%esp)
  1035aa:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  1035b1:	00 
  1035b2:	89 04 24             	mov    %eax,(%esp)
  1035b5:	e8 a7 87 00 00       	call   10bd61 <memset>
  return 0;
  1035ba:	b8 00 00 00 00       	mov    $0x0,%eax
}
  1035bf:	c9                   	leave  
  1035c0:	c3                   	ret    

001035c1 <memphys_dma_alloc>:
/**
 * Gets free DMA pages
 *  @param pages Amount of requested pages
 *  @return Address of first page
 */
void *memphys_dma_alloc(size_t pages) {
  1035c1:	55                   	push   %ebp
  1035c2:	89 e5                	mov    %esp,%ebp
  1035c4:	53                   	push   %ebx
  1035c5:	83 ec 14             	sub    $0x14,%esp
  size_t i;
  size_t found = 0;
  1035c8:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  for (i=0;i<MEMPHYS_DMALIMIT/PAGE_SIZE;i++) {
  1035cf:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
  1035d6:	e9 ac 00 00 00       	jmp    103687 <memphys_dma_alloc+0xc6>
    if (!(memphys_dma_bitmap[i/(8*sizeof(int))]&(1<<(i%(8*sizeof(int)))))) found++;
  1035db:	8b 15 58 e4 10 00    	mov    0x10e458,%edx
  1035e1:	8b 45 f0             	mov    -0x10(%ebp),%eax
  1035e4:	c1 e8 05             	shr    $0x5,%eax
  1035e7:	c1 e0 02             	shl    $0x2,%eax
  1035ea:	8d 04 02             	lea    (%edx,%eax,1),%eax
  1035ed:	8b 10                	mov    (%eax),%edx
  1035ef:	8b 45 f0             	mov    -0x10(%ebp),%eax
  1035f2:	89 c1                	mov    %eax,%ecx
  1035f4:	83 e1 1f             	and    $0x1f,%ecx
  1035f7:	89 d0                	mov    %edx,%eax
  1035f9:	d3 f8                	sar    %cl,%eax
  1035fb:	83 e0 01             	and    $0x1,%eax
  1035fe:	85 c0                	test   %eax,%eax
  103600:	75 06                	jne    103608 <memphys_dma_alloc+0x47>
  103602:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
  103606:	eb 07                	jmp    10360f <memphys_dma_alloc+0x4e>
    else found = 0;
  103608:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    if (found==pages) {
  10360f:	8b 45 f4             	mov    -0xc(%ebp),%eax
  103612:	3b 45 08             	cmp    0x8(%ebp),%eax
  103615:	75 6c                	jne    103683 <memphys_dma_alloc+0xc2>
      size_t j;
      for (j=i-(found-1);j<=i;j++) memphys_dma_bitmap[j/(8*sizeof(int))] |= 1<<(j%(8*sizeof(int)));
  103617:	8b 55 f4             	mov    -0xc(%ebp),%edx
  10361a:	8b 45 f0             	mov    -0x10(%ebp),%eax
  10361d:	29 d0                	sub    %edx,%eax
  10361f:	83 c0 01             	add    $0x1,%eax
  103622:	89 45 f8             	mov    %eax,-0x8(%ebp)
  103625:	eb 41                	jmp    103668 <memphys_dma_alloc+0xa7>
  103627:	8b 15 58 e4 10 00    	mov    0x10e458,%edx
  10362d:	8b 45 f8             	mov    -0x8(%ebp),%eax
  103630:	89 c1                	mov    %eax,%ecx
  103632:	c1 e9 05             	shr    $0x5,%ecx
  103635:	8d 04 8d 00 00 00 00 	lea    0x0(,%ecx,4),%eax
  10363c:	8d 1c 02             	lea    (%edx,%eax,1),%ebx
  10363f:	8b 15 58 e4 10 00    	mov    0x10e458,%edx
  103645:	8d 04 8d 00 00 00 00 	lea    0x0(,%ecx,4),%eax
  10364c:	8d 04 02             	lea    (%edx,%eax,1),%eax
  10364f:	8b 10                	mov    (%eax),%edx
  103651:	8b 45 f8             	mov    -0x8(%ebp),%eax
  103654:	89 c1                	mov    %eax,%ecx
  103656:	83 e1 1f             	and    $0x1f,%ecx
  103659:	b8 01 00 00 00       	mov    $0x1,%eax
  10365e:	d3 e0                	shl    %cl,%eax
  103660:	09 d0                	or     %edx,%eax
  103662:	89 03                	mov    %eax,(%ebx)
  103664:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
  103668:	8b 45 f8             	mov    -0x8(%ebp),%eax
  10366b:	3b 45 f0             	cmp    -0x10(%ebp),%eax
  10366e:	76 b7                	jbe    103627 <memphys_dma_alloc+0x66>
      return (void*)((i-(found-1))*PAGE_SIZE);
  103670:	8b 55 f4             	mov    -0xc(%ebp),%edx
  103673:	8b 45 f0             	mov    -0x10(%ebp),%eax
  103676:	29 d0                	sub    %edx,%eax
  103678:	83 c0 01             	add    $0x1,%eax
  10367b:	c1 e0 0c             	shl    $0xc,%eax
  10367e:	89 45 e8             	mov    %eax,-0x18(%ebp)
  103681:	eb 18                	jmp    10369b <memphys_dma_alloc+0xda>
 *  @return Address of first page
 */
void *memphys_dma_alloc(size_t pages) {
  size_t i;
  size_t found = 0;
  for (i=0;i<MEMPHYS_DMALIMIT/PAGE_SIZE;i++) {
  103683:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
  103687:	81 7d f0 ff 0f 00 00 	cmpl   $0xfff,-0x10(%ebp)
  10368e:	0f 86 47 ff ff ff    	jbe    1035db <memphys_dma_alloc+0x1a>
      size_t j;
      for (j=i-(found-1);j<=i;j++) memphys_dma_bitmap[j/(8*sizeof(int))] |= 1<<(j%(8*sizeof(int)));
      return (void*)((i-(found-1))*PAGE_SIZE);
    }
  }
  return NULL;
  103694:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
  10369b:	8b 45 e8             	mov    -0x18(%ebp),%eax
}
  10369e:	83 c4 14             	add    $0x14,%esp
  1036a1:	5b                   	pop    %ebx
  1036a2:	5d                   	pop    %ebp
  1036a3:	c3                   	ret    

001036a4 <memphys_dma_free>:

/**
 * Frees a DMA page
 *  @param addr Address of DMA page
 */
void memphys_dma_free(void *addr) {
  1036a4:	55                   	push   %ebp
  1036a5:	89 e5                	mov    %esp,%ebp
  1036a7:	53                   	push   %ebx
  1036a8:	83 ec 10             	sub    $0x10,%esp
  size_t i = ((size_t)addr)/PAGE_SIZE;
  1036ab:	8b 45 08             	mov    0x8(%ebp),%eax
  1036ae:	c1 e8 0c             	shr    $0xc,%eax
  1036b1:	89 45 f8             	mov    %eax,-0x8(%ebp)
  memphys_dma_bitmap[i/(8*sizeof(int))] &= ~(1<<(i%(8*sizeof(int))));
  1036b4:	8b 15 58 e4 10 00    	mov    0x10e458,%edx
  1036ba:	8b 45 f8             	mov    -0x8(%ebp),%eax
  1036bd:	89 c1                	mov    %eax,%ecx
  1036bf:	c1 e9 05             	shr    $0x5,%ecx
  1036c2:	8d 04 8d 00 00 00 00 	lea    0x0(,%ecx,4),%eax
  1036c9:	8d 1c 02             	lea    (%edx,%eax,1),%ebx
  1036cc:	8b 15 58 e4 10 00    	mov    0x10e458,%edx
  1036d2:	8d 04 8d 00 00 00 00 	lea    0x0(,%ecx,4),%eax
  1036d9:	8d 04 02             	lea    (%edx,%eax,1),%eax
  1036dc:	8b 10                	mov    (%eax),%edx
  1036de:	8b 45 f8             	mov    -0x8(%ebp),%eax
  1036e1:	89 c1                	mov    %eax,%ecx
  1036e3:	83 e1 1f             	and    $0x1f,%ecx
  1036e6:	b8 01 00 00 00       	mov    $0x1,%eax
  1036eb:	d3 e0                	shl    %cl,%eax
  1036ed:	f7 d0                	not    %eax
  1036ef:	21 d0                	and    %edx,%eax
  1036f1:	89 03                	mov    %eax,(%ebx)
}
  1036f3:	83 c4 10             	add    $0x10,%esp
  1036f6:	5b                   	pop    %ebx
  1036f7:	5d                   	pop    %ebp
  1036f8:	c3                   	ret    
  1036f9:	00 00                	add    %al,(%eax)
	...

001036fc <memuser_init>:

/**
 * Initializes User Memory Management
 *  @return Success?
 */
int memuser_init() {
  1036fc:	55                   	push   %ebp
  1036fd:	89 e5                	mov    %esp,%ebp
  1036ff:	83 ec 18             	sub    $0x18,%esp
  memuser_inited = 1;
  103702:	c7 05 88 e1 10 00 01 	movl   $0x1,0x10e188
  103709:	00 00 00 
  memuser_debug = 0;
  10370c:	c7 05 4c e4 10 00 00 	movl   $0x0,0x10e44c
  103713:	00 00 00 
  if (syscall_create(SYSCALL_MEM_MALLOC,memuser_alloc_syscall,1)==-1) return -1;
  103716:	c7 44 24 08 01 00 00 	movl   $0x1,0x8(%esp)
  10371d:	00 
  10371e:	c7 44 24 04 76 3d 10 	movl   $0x103d76,0x4(%esp)
  103725:	00 
  103726:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
  10372d:	e8 08 67 00 00       	call   109e3a <syscall_create>
  103732:	83 f8 ff             	cmp    $0xffffffff,%eax
  103735:	75 0c                	jne    103743 <memuser_init+0x47>
  103737:	c7 45 fc ff ff ff ff 	movl   $0xffffffff,-0x4(%ebp)
  10373e:	e9 f3 00 00 00       	jmp    103836 <memuser_init+0x13a>
  if (syscall_create(SYSCALL_MEM_FREE,memuser_free_syscall,1)==-1) return -1;
  103743:	c7 44 24 08 01 00 00 	movl   $0x1,0x8(%esp)
  10374a:	00 
  10374b:	c7 44 24 04 fb 3e 10 	movl   $0x103efb,0x4(%esp)
  103752:	00 
  103753:	c7 04 24 02 00 00 00 	movl   $0x2,(%esp)
  10375a:	e8 db 66 00 00       	call   109e3a <syscall_create>
  10375f:	83 f8 ff             	cmp    $0xffffffff,%eax
  103762:	75 0c                	jne    103770 <memuser_init+0x74>
  103764:	c7 45 fc ff ff ff ff 	movl   $0xffffffff,-0x4(%ebp)
  10376b:	e9 c6 00 00 00       	jmp    103836 <memuser_init+0x13a>
  if (syscall_create(SYSCALL_MEM_GETPHYSADDR,memuser_getphysaddr_syscall,1)==-1) return -1;
  103770:	c7 44 24 08 01 00 00 	movl   $0x1,0x8(%esp)
  103777:	00 
  103778:	c7 44 24 04 64 3f 10 	movl   $0x103f64,0x4(%esp)
  10377f:	00 
  103780:	c7 04 24 03 00 00 00 	movl   $0x3,(%esp)
  103787:	e8 ae 66 00 00       	call   109e3a <syscall_create>
  10378c:	83 f8 ff             	cmp    $0xffffffff,%eax
  10378f:	75 0c                	jne    10379d <memuser_init+0xa1>
  103791:	c7 45 fc ff ff ff ff 	movl   $0xffffffff,-0x4(%ebp)
  103798:	e9 99 00 00 00       	jmp    103836 <memuser_init+0x13a>
  if (syscall_create(SYSCALL_MEM_GETVGA,memuser_getvga,1)==-1) return -1;
  10379d:	c7 44 24 08 01 00 00 	movl   $0x1,0x8(%esp)
  1037a4:	00 
  1037a5:	c7 44 24 04 c1 43 10 	movl   $0x1043c1,0x4(%esp)
  1037ac:	00 
  1037ad:	c7 04 24 06 00 00 00 	movl   $0x6,(%esp)
  1037b4:	e8 81 66 00 00       	call   109e3a <syscall_create>
  1037b9:	83 f8 ff             	cmp    $0xffffffff,%eax
  1037bc:	75 09                	jne    1037c7 <memuser_init+0xcb>
  1037be:	c7 45 fc ff ff ff ff 	movl   $0xffffffff,-0x4(%ebp)
  1037c5:	eb 6f                	jmp    103836 <memuser_init+0x13a>
  if (syscall_create(SYSCALL_MEM_DMA_ALLOC,memuser_dma_alloc,1)==-1) return -1;
  1037c7:	c7 44 24 08 01 00 00 	movl   $0x1,0x8(%esp)
  1037ce:	00 
  1037cf:	c7 44 24 04 37 44 10 	movl   $0x104437,0x4(%esp)
  1037d6:	00 
  1037d7:	c7 04 24 04 00 00 00 	movl   $0x4,(%esp)
  1037de:	e8 57 66 00 00       	call   109e3a <syscall_create>
  1037e3:	83 f8 ff             	cmp    $0xffffffff,%eax
  1037e6:	75 09                	jne    1037f1 <memuser_init+0xf5>
  1037e8:	c7 45 fc ff ff ff ff 	movl   $0xffffffff,-0x4(%ebp)
  1037ef:	eb 45                	jmp    103836 <memuser_init+0x13a>
  if (syscall_create(SYSCALL_MEM_DMA_FREE,memuser_dma_free,2)==-1) return -1;
  1037f1:	c7 44 24 08 02 00 00 	movl   $0x2,0x8(%esp)
  1037f8:	00 
  1037f9:	c7 44 24 04 f5 44 10 	movl   $0x1044f5,0x4(%esp)
  103800:	00 
  103801:	c7 04 24 05 00 00 00 	movl   $0x5,(%esp)
  103808:	e8 2d 66 00 00       	call   109e3a <syscall_create>
  10380d:	83 f8 ff             	cmp    $0xffffffff,%eax
  103810:	75 09                	jne    10381b <memuser_init+0x11f>
  103812:	c7 45 fc ff ff ff ff 	movl   $0xffffffff,-0x4(%ebp)
  103819:	eb 1b                	jmp    103836 <memuser_init+0x13a>
  if (memphys_dma_init()==-1) return -1;
  10381b:	e8 37 fd ff ff       	call   103557 <memphys_dma_init>
  103820:	83 f8 ff             	cmp    $0xffffffff,%eax
  103823:	75 09                	jne    10382e <memuser_init+0x132>
  103825:	c7 45 fc ff ff ff ff 	movl   $0xffffffff,-0x4(%ebp)
  10382c:	eb 08                	jmp    103836 <memuser_init+0x13a>
  return swap_init();
  10382e:	e8 59 62 00 00       	call   109a8c <swap_init>
  103833:	89 45 fc             	mov    %eax,-0x4(%ebp)
  103836:	8b 45 fc             	mov    -0x4(%ebp),%eax
}
  103839:	c9                   	leave  
  10383a:	c3                   	ret    

0010383b <memuser_findvirt>:
 * Find a free virtual address
 *  @param addrspace Address space
 *  @param pages Number of pages
 *  @return Address of first page
 */
void *memuser_findvirt(addrspace_t *addrspace,size_t pages) {
  10383b:	55                   	push   %ebp
  10383c:	89 e5                	mov    %esp,%ebp
  10383e:	83 ec 28             	sub    $0x28,%esp
  void *virt;
  size_t found = 0;
  103841:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)

  for (virt = (void*)USERDATA_ADDRESS;virt<(void*)USERDATA_ADDRESS+USERDATA_SIZE;virt+=PAGE_SIZE) {
  103848:	c7 45 f8 00 00 00 40 	movl   $0x40000000,-0x8(%ebp)
  10384f:	e9 a4 00 00 00       	jmp    1038f8 <memuser_findvirt+0xbd>
    // check if enough pages are found
    if (found>=pages) return virt-found*PAGE_SIZE;
  103854:	8b 45 fc             	mov    -0x4(%ebp),%eax
  103857:	3b 45 0c             	cmp    0xc(%ebp),%eax
  10385a:	72 15                	jb     103871 <memuser_findvirt+0x36>
  10385c:	8b 45 fc             	mov    -0x4(%ebp),%eax
  10385f:	c1 e0 0c             	shl    $0xc,%eax
  103862:	f7 d8                	neg    %eax
  103864:	8b 55 f8             	mov    -0x8(%ebp),%edx
  103867:	01 c2                	add    %eax,%edx
  103869:	89 55 ec             	mov    %edx,-0x14(%ebp)
  10386c:	e9 9b 00 00 00       	jmp    10390c <memuser_findvirt+0xd1>
    if (ADDR2PTE(virt)==0) {
  103871:	8b 45 f8             	mov    -0x8(%ebp),%eax
  103874:	c1 e8 0c             	shr    $0xc,%eax
  103877:	25 ff 03 00 00       	and    $0x3ff,%eax
  10387c:	85 c0                	test   %eax,%eax
  10387e:	75 3a                	jne    1038ba <memuser_findvirt+0x7f>
      // check for PDE
      if (!paging_getpde_pd(virt,addrspace->pagedir).exists) {
  103880:	8b 45 08             	mov    0x8(%ebp),%eax
  103883:	8b 40 10             	mov    0x10(%eax),%eax
  103886:	8d 55 f0             	lea    -0x10(%ebp),%edx
  103889:	89 44 24 08          	mov    %eax,0x8(%esp)
  10388d:	8b 45 f8             	mov    -0x8(%ebp),%eax
  103890:	89 44 24 04          	mov    %eax,0x4(%esp)
  103894:	89 14 24             	mov    %edx,(%esp)
  103897:	e8 89 1d 00 00       	call   105625 <paging_getpde_pd>
  10389c:	83 ec 04             	sub    $0x4,%esp
  10389f:	0f b6 45 f0          	movzbl -0x10(%ebp),%eax
  1038a3:	83 e0 01             	and    $0x1,%eax
  1038a6:	84 c0                	test   %al,%al
  1038a8:	75 10                	jne    1038ba <memuser_findvirt+0x7f>
        found += 1024;
  1038aa:	81 45 fc 00 04 00 00 	addl   $0x400,-0x4(%ebp)
        virt += 1023*PAGE_SIZE;
  1038b1:	81 45 f8 00 f0 3f 00 	addl   $0x3ff000,-0x8(%ebp)
  1038b8:	eb 37                	jmp    1038f1 <memuser_findvirt+0xb6>
        continue;
      }
    }
    // check for PTE
    if (paging_getpte_pd(virt,addrspace->pagedir).exists) found = 0;
  1038ba:	8b 45 08             	mov    0x8(%ebp),%eax
  1038bd:	8b 40 10             	mov    0x10(%eax),%eax
  1038c0:	8d 55 f4             	lea    -0xc(%ebp),%edx
  1038c3:	89 44 24 08          	mov    %eax,0x8(%esp)
  1038c7:	8b 45 f8             	mov    -0x8(%ebp),%eax
  1038ca:	89 44 24 04          	mov    %eax,0x4(%esp)
  1038ce:	89 14 24             	mov    %edx,(%esp)
  1038d1:	e8 14 1e 00 00       	call   1056ea <paging_getpte_pd>
  1038d6:	83 ec 04             	sub    $0x4,%esp
  1038d9:	0f b6 45 f5          	movzbl -0xb(%ebp),%eax
  1038dd:	83 e0 02             	and    $0x2,%eax
  1038e0:	84 c0                	test   %al,%al
  1038e2:	74 09                	je     1038ed <memuser_findvirt+0xb2>
  1038e4:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
  1038eb:	eb 04                	jmp    1038f1 <memuser_findvirt+0xb6>
    else found++;
  1038ed:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
 */
void *memuser_findvirt(addrspace_t *addrspace,size_t pages) {
  void *virt;
  size_t found = 0;

  for (virt = (void*)USERDATA_ADDRESS;virt<(void*)USERDATA_ADDRESS+USERDATA_SIZE;virt+=PAGE_SIZE) {
  1038f1:	81 45 f8 00 10 00 00 	addl   $0x1000,-0x8(%ebp)
  1038f8:	81 7d f8 ff ef bf ff 	cmpl   $0xffbfefff,-0x8(%ebp)
  1038ff:	0f 86 4f ff ff ff    	jbe    103854 <memuser_findvirt+0x19>
    // check for PTE
    if (paging_getpte_pd(virt,addrspace->pagedir).exists) found = 0;
    else found++;
  }

  return NULL;
  103905:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
  10390c:	8b 45 ec             	mov    -0x14(%ebp),%eax
}
  10390f:	c9                   	leave  
  103910:	c3                   	ret    

00103911 <memuser_create_pagedir>:

/**
 * Creates an user pagedir
 *  @return User pagedir
 */
pd_t memuser_create_pagedir() {
  103911:	55                   	push   %ebp
  103912:	89 e5                	mov    %esp,%ebp
  103914:	83 ec 28             	sub    $0x28,%esp
if (memuser_debug) kprintf("HELLO\n");
  103917:	a1 4c e4 10 00       	mov    0x10e44c,%eax
  10391c:	85 c0                	test   %eax,%eax
  10391e:	74 0c                	je     10392c <memuser_create_pagedir+0x1b>
  103920:	c7 04 24 44 d6 10 00 	movl   $0x10d644,(%esp)
  103927:	e8 6f ea ff ff       	call   10239b <kprintf>
  pd_t pagedir = paging_cleanpage(memphys_alloc());
  10392c:	e8 84 fb ff ff       	call   1034b5 <memphys_pop>
  103931:	89 04 24             	mov    %eax,(%esp)
  103934:	e8 33 1a 00 00       	call   10536c <paging_cleanpage>
  103939:	89 45 fc             	mov    %eax,-0x4(%ebp)
  // copy kernel PTEs
  pde_t pde;
  paging_physwrite(pagedir,(void*)PAGEDIR_ADDRESS,ADDR2PDE(KERNELDATA_ADDRESS+KERNELDATA_SIZE));
  10393c:	c7 44 24 08 00 01 00 	movl   $0x100,0x8(%esp)
  103943:	00 
  103944:	c7 44 24 04 00 f0 ff 	movl   $0xfffff000,0x4(%esp)
  10394b:	ff 
  10394c:	8b 45 fc             	mov    -0x4(%ebp),%eax
  10394f:	89 04 24             	mov    %eax,(%esp)
  103952:	e8 79 19 00 00       	call   1052d0 <paging_physwrite>
  // link last PDE to PD
  memset(&pde,0,sizeof(pde));
  103957:	c7 44 24 08 04 00 00 	movl   $0x4,0x8(%esp)
  10395e:	00 
  10395f:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  103966:	00 
  103967:	8d 45 f8             	lea    -0x8(%ebp),%eax
  10396a:	89 04 24             	mov    %eax,(%esp)
  10396d:	e8 ef 83 00 00       	call   10bd61 <memset>
  pde.page = ADDR2PAGE(pagedir);
  103972:	8b 45 fc             	mov    -0x4(%ebp),%eax
  103975:	c1 e8 0c             	shr    $0xc,%eax
  103978:	25 ff ff 0f 00       	and    $0xfffff,%eax
  10397d:	89 c2                	mov    %eax,%edx
  10397f:	c1 e2 0c             	shl    $0xc,%edx
  103982:	8b 45 f8             	mov    -0x8(%ebp),%eax
  103985:	25 ff 0f 00 00       	and    $0xfff,%eax
  10398a:	09 d0                	or     %edx,%eax
  10398c:	89 45 f8             	mov    %eax,-0x8(%ebp)
  pde.pagesize = PGSIZE_4K;
  10398f:	0f b6 45 f8          	movzbl -0x8(%ebp),%eax
  103993:	83 e0 7f             	and    $0x7f,%eax
  103996:	88 45 f8             	mov    %al,-0x8(%ebp)
  pde.user = 0;
  103999:	0f b6 45 f8          	movzbl -0x8(%ebp),%eax
  10399d:	83 e0 fb             	and    $0xfffffffb,%eax
  1039a0:	88 45 f8             	mov    %al,-0x8(%ebp)
  pde.writable = 1;
  1039a3:	0f b6 45 f8          	movzbl -0x8(%ebp),%eax
  1039a7:	83 c8 02             	or     $0x2,%eax
  1039aa:	88 45 f8             	mov    %al,-0x8(%ebp)
  pde.exists = 1;
  1039ad:	0f b6 45 f8          	movzbl -0x8(%ebp),%eax
  1039b1:	83 c8 01             	or     $0x1,%eax
  1039b4:	88 45 f8             	mov    %al,-0x8(%ebp)
  paging_setpde_pd((void*)(4092*MBYTES),pde,pagedir);
  1039b7:	8b 45 fc             	mov    -0x4(%ebp),%eax
  1039ba:	89 44 24 08          	mov    %eax,0x8(%esp)
  1039be:	8b 45 f8             	mov    -0x8(%ebp),%eax
  1039c1:	89 44 24 04          	mov    %eax,0x4(%esp)
  1039c5:	c7 04 24 00 00 c0 ff 	movl   $0xffc00000,(%esp)
  1039cc:	e8 ad 1c 00 00       	call   10567e <paging_setpde_pd>
  return pagedir;
  1039d1:	8b 45 fc             	mov    -0x4(%ebp),%eax
}
  1039d4:	c9                   	leave  
  1039d5:	c3                   	ret    

001039d6 <memuser_destroy_pagedir>:
 * Destroys an user pagedir
 *  @param pagedir Pagedir
 *  @return Success?
 *  @todo Check if there are really no user pages left
 */
int memuser_destroy_pagedir(pd_t pagedir) {
  1039d6:	55                   	push   %ebp
  1039d7:	89 e5                	mov    %esp,%ebp
  1039d9:	83 ec 08             	sub    $0x8,%esp
  if (paging_curpd==pagedir) paging_loadpagedir(paging_kernelpd);
  1039dc:	a1 74 e4 10 00       	mov    0x10e474,%eax
  1039e1:	3b 45 08             	cmp    0x8(%ebp),%eax
  1039e4:	75 0d                	jne    1039f3 <memuser_destroy_pagedir+0x1d>
  1039e6:	a1 64 e4 10 00       	mov    0x10e464,%eax
  1039eb:	89 04 24             	mov    %eax,(%esp)
  1039ee:	e8 10 18 00 00       	call   105203 <paging_loadpagedir>
  memphys_free(pagedir);
  1039f3:	8b 45 08             	mov    0x8(%ebp),%eax
  1039f6:	89 04 24             	mov    %eax,(%esp)
  1039f9:	e8 16 fa ff ff       	call   103414 <memphys_push>
  return 0;
  1039fe:	b8 00 00 00 00       	mov    $0x0,%eax
}
  103a03:	c9                   	leave  
  103a04:	c3                   	ret    

00103a05 <memuser_create_pagetable>:
 * Creates an user pagetable
 *  @param addrspace Address space
 *  @param virt Virtual address
 *  @return Success?
 */
int memuser_create_pagetable(pd_t pagedir,void *virt) {
  103a05:	55                   	push   %ebp
  103a06:	89 e5                	mov    %esp,%ebp
  103a08:	83 ec 28             	sub    $0x28,%esp
  pde_t new;
  memset(&new,0,sizeof(new));
  103a0b:	c7 44 24 08 04 00 00 	movl   $0x4,0x8(%esp)
  103a12:	00 
  103a13:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  103a1a:	00 
  103a1b:	8d 45 fc             	lea    -0x4(%ebp),%eax
  103a1e:	89 04 24             	mov    %eax,(%esp)
  103a21:	e8 3b 83 00 00       	call   10bd61 <memset>
memuser_debug++;
  103a26:	a1 4c e4 10 00       	mov    0x10e44c,%eax
  103a2b:	83 c0 01             	add    $0x1,%eax
  103a2e:	a3 4c e4 10 00       	mov    %eax,0x10e44c
  new.page = ADDR2PAGE(paging_cleanpage(memphys_alloc()));
  103a33:	e8 7d fa ff ff       	call   1034b5 <memphys_pop>
  103a38:	89 04 24             	mov    %eax,(%esp)
  103a3b:	e8 2c 19 00 00       	call   10536c <paging_cleanpage>
  103a40:	c1 e8 0c             	shr    $0xc,%eax
  103a43:	25 ff ff 0f 00       	and    $0xfffff,%eax
  103a48:	89 c2                	mov    %eax,%edx
  103a4a:	c1 e2 0c             	shl    $0xc,%edx
  103a4d:	8b 45 fc             	mov    -0x4(%ebp),%eax
  103a50:	25 ff 0f 00 00       	and    $0xfff,%eax
  103a55:	09 d0                	or     %edx,%eax
  103a57:	89 45 fc             	mov    %eax,-0x4(%ebp)
memuser_debug--;
  103a5a:	a1 4c e4 10 00       	mov    0x10e44c,%eax
  103a5f:	83 e8 01             	sub    $0x1,%eax
  103a62:	a3 4c e4 10 00       	mov    %eax,0x10e44c
  new.pagesize = PGSIZE_4K;
  103a67:	0f b6 45 fc          	movzbl -0x4(%ebp),%eax
  103a6b:	83 e0 7f             	and    $0x7f,%eax
  103a6e:	88 45 fc             	mov    %al,-0x4(%ebp)
  new.user = 1;
  103a71:	0f b6 45 fc          	movzbl -0x4(%ebp),%eax
  103a75:	83 c8 04             	or     $0x4,%eax
  103a78:	88 45 fc             	mov    %al,-0x4(%ebp)
  new.writable = 1;
  103a7b:	0f b6 45 fc          	movzbl -0x4(%ebp),%eax
  103a7f:	83 c8 02             	or     $0x2,%eax
  103a82:	88 45 fc             	mov    %al,-0x4(%ebp)
  new.exists = 1;
  103a85:	0f b6 45 fc          	movzbl -0x4(%ebp),%eax
  103a89:	83 c8 01             	or     $0x1,%eax
  103a8c:	88 45 fc             	mov    %al,-0x4(%ebp)
  return paging_setpde_pd(virt,new,pagedir)>=0?0:-1;
  103a8f:	8b 45 08             	mov    0x8(%ebp),%eax
  103a92:	89 44 24 08          	mov    %eax,0x8(%esp)
  103a96:	8b 45 fc             	mov    -0x4(%ebp),%eax
  103a99:	89 44 24 04          	mov    %eax,0x4(%esp)
  103a9d:	8b 45 0c             	mov    0xc(%ebp),%eax
  103aa0:	89 04 24             	mov    %eax,(%esp)
  103aa3:	e8 d6 1b 00 00       	call   10567e <paging_setpde_pd>
  103aa8:	85 c0                	test   %eax,%eax
  103aaa:	78 09                	js     103ab5 <memuser_create_pagetable+0xb0>
  103aac:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
  103ab3:	eb 07                	jmp    103abc <memuser_create_pagetable+0xb7>
  103ab5:	c7 45 ec ff ff ff ff 	movl   $0xffffffff,-0x14(%ebp)
  103abc:	8b 45 ec             	mov    -0x14(%ebp),%eax
}
  103abf:	c9                   	leave  
  103ac0:	c3                   	ret    

00103ac1 <memuser_create_addrspace>:

/**
 * Creates an address space
 *  @return Address space
 */
addrspace_t *memuser_create_addrspace(proc_t *proc) {
  103ac1:	55                   	push   %ebp
  103ac2:	89 e5                	mov    %esp,%ebp
  103ac4:	83 ec 18             	sub    $0x18,%esp
  addrspace_t *new = malloc(sizeof(addrspace_t));
  103ac7:	c7 04 24 18 00 00 00 	movl   $0x18,(%esp)
  103ace:	e8 96 f4 ff ff       	call   102f69 <malloc>
  103ad3:	89 45 fc             	mov    %eax,-0x4(%ebp)
  new->proc = proc;
  103ad6:	8b 55 fc             	mov    -0x4(%ebp),%edx
  103ad9:	8b 45 08             	mov    0x8(%ebp),%eax
  103adc:	89 02                	mov    %eax,(%edx)
  new->pages_loaded = llist_create();
  103ade:	e8 f1 6d 00 00       	call   10a8d4 <llist_create>
  103ae3:	89 c2                	mov    %eax,%edx
  103ae5:	8b 45 fc             	mov    -0x4(%ebp),%eax
  103ae8:	89 50 04             	mov    %edx,0x4(%eax)
  new->pages_imaginary = llist_create();
  103aeb:	e8 e4 6d 00 00       	call   10a8d4 <llist_create>
  103af0:	89 c2                	mov    %eax,%edx
  103af2:	8b 45 fc             	mov    -0x4(%ebp),%eax
  103af5:	89 50 08             	mov    %edx,0x8(%eax)
  new->pages_swapped = llist_create();
  103af8:	e8 d7 6d 00 00       	call   10a8d4 <llist_create>
  103afd:	89 c2                	mov    %eax,%edx
  103aff:	8b 45 fc             	mov    -0x4(%ebp),%eax
  103b02:	89 50 0c             	mov    %edx,0xc(%eax)
  new->pagedir = memuser_create_pagedir();
  103b05:	e8 07 fe ff ff       	call   103911 <memuser_create_pagedir>
  103b0a:	89 c2                	mov    %eax,%edx
  103b0c:	8b 45 fc             	mov    -0x4(%ebp),%eax
  103b0f:	89 50 10             	mov    %edx,0x10(%eax)
  new->stack = NULL;
  103b12:	8b 45 fc             	mov    -0x4(%ebp),%eax
  103b15:	c7 40 14 00 00 00 00 	movl   $0x0,0x14(%eax)
  return new;
  103b1c:	8b 45 fc             	mov    -0x4(%ebp),%eax
}
  103b1f:	c9                   	leave  
  103b20:	c3                   	ret    

00103b21 <memuser_destroy_addrspace>:
/**
 * Destroys an address space
 *  @param addrspace Address space
 *  @return Success?
 */
int memuser_destroy_addrspace(addrspace_t *addrspace) {
  103b21:	55                   	push   %ebp
  103b22:	89 e5                	mov    %esp,%ebp
  103b24:	83 ec 28             	sub    $0x28,%esp
  if (paging_curpd!=addrspace->pagedir) return -1;
  103b27:	8b 45 08             	mov    0x8(%ebp),%eax
  103b2a:	8b 50 10             	mov    0x10(%eax),%edx
  103b2d:	a1 74 e4 10 00       	mov    0x10e474,%eax
  103b32:	39 c2                	cmp    %eax,%edx
  103b34:	74 0c                	je     103b42 <memuser_destroy_addrspace+0x21>
  103b36:	c7 45 ec ff ff ff ff 	movl   $0xffffffff,-0x14(%ebp)
  103b3d:	e9 d4 00 00 00       	jmp    103c16 <memuser_destroy_addrspace+0xf5>
  void *page;

  if (addrspace->stack!=NULL) memuser_destroy_stack(addrspace->stack);
  103b42:	8b 45 08             	mov    0x8(%ebp),%eax
  103b45:	8b 40 14             	mov    0x14(%eax),%eax
  103b48:	85 c0                	test   %eax,%eax
  103b4a:	74 23                	je     103b6f <memuser_destroy_addrspace+0x4e>
  103b4c:	8b 45 08             	mov    0x8(%ebp),%eax
  103b4f:	8b 40 14             	mov    0x14(%eax),%eax
  103b52:	89 04 24             	mov    %eax,(%esp)
  103b55:	e8 78 04 00 00       	call   103fd2 <memuser_destroy_stack>
  103b5a:	eb 13                	jmp    103b6f <memuser_destroy_addrspace+0x4e>
  while ((page = llist_pop(addrspace->pages_loaded))!=NULL) memphys_free(paging_unmap(page));
  103b5c:	8b 45 fc             	mov    -0x4(%ebp),%eax
  103b5f:	89 04 24             	mov    %eax,(%esp)
  103b62:	e8 f0 1e 00 00       	call   105a57 <paging_unmap>
  103b67:	89 04 24             	mov    %eax,(%esp)
  103b6a:	e8 a5 f8 ff ff       	call   103414 <memphys_push>
  103b6f:	8b 45 08             	mov    0x8(%ebp),%eax
  103b72:	8b 40 04             	mov    0x4(%eax),%eax
  103b75:	89 04 24             	mov    %eax,(%esp)
  103b78:	e8 2b 6e 00 00       	call   10a9a8 <llist_pop>
  103b7d:	89 45 fc             	mov    %eax,-0x4(%ebp)
  103b80:	83 7d fc 00          	cmpl   $0x0,-0x4(%ebp)
  103b84:	75 d6                	jne    103b5c <memuser_destroy_addrspace+0x3b>
  103b86:	eb 0b                	jmp    103b93 <memuser_destroy_addrspace+0x72>
  while ((page = llist_pop(addrspace->pages_imaginary))!=NULL) paging_unmap(page);
  103b88:	8b 45 fc             	mov    -0x4(%ebp),%eax
  103b8b:	89 04 24             	mov    %eax,(%esp)
  103b8e:	e8 c4 1e 00 00       	call   105a57 <paging_unmap>
  103b93:	8b 45 08             	mov    0x8(%ebp),%eax
  103b96:	8b 40 08             	mov    0x8(%eax),%eax
  103b99:	89 04 24             	mov    %eax,(%esp)
  103b9c:	e8 07 6e 00 00       	call   10a9a8 <llist_pop>
  103ba1:	89 45 fc             	mov    %eax,-0x4(%ebp)
  103ba4:	83 7d fc 00          	cmpl   $0x0,-0x4(%ebp)
  103ba8:	75 de                	jne    103b88 <memuser_destroy_addrspace+0x67>
  103baa:	eb 14                	jmp    103bc0 <memuser_destroy_addrspace+0x9f>
  while ((page = llist_pop(addrspace->pages_swapped))!=NULL) swap_remove(addrspace->proc,page);
  103bac:	8b 45 08             	mov    0x8(%ebp),%eax
  103baf:	8b 10                	mov    (%eax),%edx
  103bb1:	8b 45 fc             	mov    -0x4(%ebp),%eax
  103bb4:	89 44 24 04          	mov    %eax,0x4(%esp)
  103bb8:	89 14 24             	mov    %edx,(%esp)
  103bbb:	e8 66 61 00 00       	call   109d26 <swap_remove>
  103bc0:	8b 45 08             	mov    0x8(%ebp),%eax
  103bc3:	8b 40 0c             	mov    0xc(%eax),%eax
  103bc6:	89 04 24             	mov    %eax,(%esp)
  103bc9:	e8 da 6d 00 00       	call   10a9a8 <llist_pop>
  103bce:	89 45 fc             	mov    %eax,-0x4(%ebp)
  103bd1:	83 7d fc 00          	cmpl   $0x0,-0x4(%ebp)
  103bd5:	75 d5                	jne    103bac <memuser_destroy_addrspace+0x8b>
  llist_destroy(addrspace->pages_loaded);
  103bd7:	8b 45 08             	mov    0x8(%ebp),%eax
  103bda:	8b 40 04             	mov    0x4(%eax),%eax
  103bdd:	89 04 24             	mov    %eax,(%esp)
  103be0:	e8 1c 6d 00 00       	call   10a901 <llist_destroy>
  llist_destroy(addrspace->pages_imaginary);
  103be5:	8b 45 08             	mov    0x8(%ebp),%eax
  103be8:	8b 40 08             	mov    0x8(%eax),%eax
  103beb:	89 04 24             	mov    %eax,(%esp)
  103bee:	e8 0e 6d 00 00       	call   10a901 <llist_destroy>
  llist_destroy(addrspace->pages_swapped);
  103bf3:	8b 45 08             	mov    0x8(%ebp),%eax
  103bf6:	8b 40 0c             	mov    0xc(%eax),%eax
  103bf9:	89 04 24             	mov    %eax,(%esp)
  103bfc:	e8 00 6d 00 00       	call   10a901 <llist_destroy>
  memuser_destroy_pagedir(addrspace->pagedir);
  103c01:	8b 45 08             	mov    0x8(%ebp),%eax
  103c04:	8b 40 10             	mov    0x10(%eax),%eax
  103c07:	89 04 24             	mov    %eax,(%esp)
  103c0a:	e8 c7 fd ff ff       	call   1039d6 <memuser_destroy_pagedir>
  return 0;
  103c0f:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
  103c16:	8b 45 ec             	mov    -0x14(%ebp),%eax
}
  103c19:	c9                   	leave  
  103c1a:	c3                   	ret    

00103c1b <memuser_load_addrspace>:
/**
 * Loads an address space
 *  @param addrspace Address space
 *  @return Success?
 */
int memuser_load_addrspace(addrspace_t *addrspace) {
  103c1b:	55                   	push   %ebp
  103c1c:	89 e5                	mov    %esp,%ebp
  103c1e:	83 ec 08             	sub    $0x8,%esp
  if (paging_curpd!=addrspace->pagedir) return paging_loadpagedir(addrspace->pagedir);
  103c21:	8b 45 08             	mov    0x8(%ebp),%eax
  103c24:	8b 50 10             	mov    0x10(%eax),%edx
  103c27:	a1 74 e4 10 00       	mov    0x10e474,%eax
  103c2c:	39 c2                	cmp    %eax,%edx
  103c2e:	74 13                	je     103c43 <memuser_load_addrspace+0x28>
  103c30:	8b 45 08             	mov    0x8(%ebp),%eax
  103c33:	8b 40 10             	mov    0x10(%eax),%eax
  103c36:	89 04 24             	mov    %eax,(%esp)
  103c39:	e8 c5 15 00 00       	call   105203 <paging_loadpagedir>
  103c3e:	89 45 fc             	mov    %eax,-0x4(%ebp)
  103c41:	eb 07                	jmp    103c4a <memuser_load_addrspace+0x2f>
  else return 0;
  103c43:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
  103c4a:	8b 45 fc             	mov    -0x4(%ebp),%eax
}
  103c4d:	c9                   	leave  
  103c4e:	c3                   	ret    

00103c4f <memuser_alloc>:
 * Allocates an user page
 *  @param addrspace Address space
 *  @param count How many bytes to allocated (should be devidable with PAGE_SIZE)
 *  @return Address
 */
void *memuser_alloc(addrspace_t *addrspace,size_t count,int swappable) {
  103c4f:	55                   	push   %ebp
  103c50:	89 e5                	mov    %esp,%ebp
  103c52:	83 ec 38             	sub    $0x38,%esp
  void *addr = memuser_findvirt(addrspace,count/PAGE_SIZE);
  103c55:	8b 45 0c             	mov    0xc(%ebp),%eax
  103c58:	c1 e8 0c             	shr    $0xc,%eax
  103c5b:	89 44 24 04          	mov    %eax,0x4(%esp)
  103c5f:	8b 45 08             	mov    0x8(%ebp),%eax
  103c62:	89 04 24             	mov    %eax,(%esp)
  103c65:	e8 d1 fb ff ff       	call   10383b <memuser_findvirt>
  103c6a:	89 45 f4             	mov    %eax,-0xc(%ebp)
  if (addr!=NULL) {
  103c6d:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
  103c71:	0f 84 fa 00 00 00    	je     103d71 <memuser_alloc+0x122>
    size_t i;
    for (i=0;i<count/PAGE_SIZE;i++) {
  103c77:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
  103c7e:	e9 df 00 00 00       	jmp    103d62 <memuser_alloc+0x113>
      void *virt = addr+i*PAGE_SIZE;
  103c83:	8b 45 f8             	mov    -0x8(%ebp),%eax
  103c86:	c1 e0 0c             	shl    $0xc,%eax
  103c89:	03 45 f4             	add    -0xc(%ebp),%eax
  103c8c:	89 45 fc             	mov    %eax,-0x4(%ebp)
      if (!paging_getpde_pd(virt,addrspace->pagedir).exists) memuser_create_pagetable(addrspace->pagedir,virt);
  103c8f:	8b 45 08             	mov    0x8(%ebp),%eax
  103c92:	8b 40 10             	mov    0x10(%eax),%eax
  103c95:	8d 55 f0             	lea    -0x10(%ebp),%edx
  103c98:	89 44 24 08          	mov    %eax,0x8(%esp)
  103c9c:	8b 45 fc             	mov    -0x4(%ebp),%eax
  103c9f:	89 44 24 04          	mov    %eax,0x4(%esp)
  103ca3:	89 14 24             	mov    %edx,(%esp)
  103ca6:	e8 7a 19 00 00       	call   105625 <paging_getpde_pd>
  103cab:	83 ec 04             	sub    $0x4,%esp
  103cae:	0f b6 45 f0          	movzbl -0x10(%ebp),%eax
  103cb2:	83 e0 01             	and    $0x1,%eax
  103cb5:	84 c0                	test   %al,%al
  103cb7:	75 15                	jne    103cce <memuser_alloc+0x7f>
  103cb9:	8b 45 08             	mov    0x8(%ebp),%eax
  103cbc:	8b 50 10             	mov    0x10(%eax),%edx
  103cbf:	8b 45 fc             	mov    -0x4(%ebp),%eax
  103cc2:	89 44 24 04          	mov    %eax,0x4(%esp)
  103cc6:	89 14 24             	mov    %edx,(%esp)
  103cc9:	e8 37 fd ff ff       	call   103a05 <memuser_create_pagetable>
      pte_t pte;
      memset(&pte,0,sizeof(pte));
  103cce:	c7 44 24 08 04 00 00 	movl   $0x4,0x8(%esp)
  103cd5:	00 
  103cd6:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  103cdd:	00 
  103cde:	8d 45 ec             	lea    -0x14(%ebp),%eax
  103ce1:	89 04 24             	mov    %eax,(%esp)
  103ce4:	e8 78 80 00 00       	call   10bd61 <memset>
      pte.exists = 1;
  103ce9:	0f b6 45 ed          	movzbl -0x13(%ebp),%eax
  103ced:	83 c8 02             	or     $0x2,%eax
  103cf0:	88 45 ed             	mov    %al,-0x13(%ebp)
      pte.swappable = swappable;
  103cf3:	8b 45 10             	mov    0x10(%ebp),%eax
  103cf6:	83 e0 01             	and    $0x1,%eax
  103cf9:	83 e0 01             	and    $0x1,%eax
  103cfc:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
  103d03:	0f b6 45 ed          	movzbl -0x13(%ebp),%eax
  103d07:	83 e0 fb             	and    $0xfffffffb,%eax
  103d0a:	09 d0                	or     %edx,%eax
  103d0c:	88 45 ed             	mov    %al,-0x13(%ebp)
      pte.swapped = 0;
  103d0f:	0f b6 45 ed          	movzbl -0x13(%ebp),%eax
  103d13:	83 e0 f7             	and    $0xfffffff7,%eax
  103d16:	88 45 ed             	mov    %al,-0x13(%ebp)
      pte.writable = 1;
  103d19:	0f b6 45 ec          	movzbl -0x14(%ebp),%eax
  103d1d:	83 c8 02             	or     $0x2,%eax
  103d20:	88 45 ec             	mov    %al,-0x14(%ebp)
      pte.user = 1;
  103d23:	0f b6 45 ec          	movzbl -0x14(%ebp),%eax
  103d27:	83 c8 04             	or     $0x4,%eax
  103d2a:	88 45 ec             	mov    %al,-0x14(%ebp)
      paging_setpte_pd(virt,pte,addrspace->pagedir);
  103d2d:	8b 45 08             	mov    0x8(%ebp),%eax
  103d30:	8b 40 10             	mov    0x10(%eax),%eax
  103d33:	89 44 24 08          	mov    %eax,0x8(%esp)
  103d37:	8b 45 ec             	mov    -0x14(%ebp),%eax
  103d3a:	89 44 24 04          	mov    %eax,0x4(%esp)
  103d3e:	8b 45 fc             	mov    -0x4(%ebp),%eax
  103d41:	89 04 24             	mov    %eax,(%esp)
  103d44:	e8 4a 1a 00 00       	call   105793 <paging_setpte_pd>
      llist_push(addrspace->pages_imaginary,virt);
  103d49:	8b 45 08             	mov    0x8(%ebp),%eax
  103d4c:	8b 50 08             	mov    0x8(%eax),%edx
  103d4f:	8b 45 fc             	mov    -0x4(%ebp),%eax
  103d52:	89 44 24 04          	mov    %eax,0x4(%esp)
  103d56:	89 14 24             	mov    %edx,(%esp)
  103d59:	e8 f1 6b 00 00       	call   10a94f <llist_push>
 */
void *memuser_alloc(addrspace_t *addrspace,size_t count,int swappable) {
  void *addr = memuser_findvirt(addrspace,count/PAGE_SIZE);
  if (addr!=NULL) {
    size_t i;
    for (i=0;i<count/PAGE_SIZE;i++) {
  103d5e:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
  103d62:	8b 45 0c             	mov    0xc(%ebp),%eax
  103d65:	c1 e8 0c             	shr    $0xc,%eax
  103d68:	3b 45 f8             	cmp    -0x8(%ebp),%eax
  103d6b:	0f 87 12 ff ff ff    	ja     103c83 <memuser_alloc+0x34>
      pte.user = 1;
      paging_setpte_pd(virt,pte,addrspace->pagedir);
      llist_push(addrspace->pages_imaginary,virt);
    }
  }
  return addr;
  103d71:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
  103d74:	c9                   	leave  
  103d75:	c3                   	ret    

00103d76 <memuser_alloc_syscall>:
/**
 * Allocates an user page (Syscall)
 *  @param count How many bytes to allocated (should be devidable with PAGE_SIZE)
 *  @return Address
 */
void *memuser_alloc_syscall(size_t count) {
  103d76:	55                   	push   %ebp
  103d77:	89 e5                	mov    %esp,%ebp
  103d79:	83 ec 18             	sub    $0x18,%esp
  return memuser_alloc(proc_current->addrspace,count,1);
  103d7c:	a1 a0 e1 10 00       	mov    0x10e1a0,%eax
  103d81:	8b 50 6c             	mov    0x6c(%eax),%edx
  103d84:	c7 44 24 08 01 00 00 	movl   $0x1,0x8(%esp)
  103d8b:	00 
  103d8c:	8b 45 08             	mov    0x8(%ebp),%eax
  103d8f:	89 44 24 04          	mov    %eax,0x4(%esp)
  103d93:	89 14 24             	mov    %edx,(%esp)
  103d96:	e8 b4 fe ff ff       	call   103c4f <memuser_alloc>
}
  103d9b:	c9                   	leave  
  103d9c:	c3                   	ret    

00103d9d <memuser_free>:
 * Frees an user page
 *  @param addrspace Address space
 *  @param page Page
 *  @return Success?
 */
int memuser_free(addrspace_t *addrspace,void *page) {
  103d9d:	55                   	push   %ebp
  103d9e:	89 e5                	mov    %esp,%ebp
  103da0:	83 ec 28             	sub    $0x28,%esp
  if (page==NULL) return 0;
  103da3:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
  103da7:	75 0c                	jne    103db5 <memuser_free+0x18>
  103da9:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
  103db0:	e9 41 01 00 00       	jmp    103ef6 <memuser_free+0x159>

  pte_t pte = paging_getpte_pd(addrspace->stack,addrspace->pagedir);
  103db5:	8b 45 08             	mov    0x8(%ebp),%eax
  103db8:	8b 48 10             	mov    0x10(%eax),%ecx
  103dbb:	8b 45 08             	mov    0x8(%ebp),%eax
  103dbe:	8b 40 14             	mov    0x14(%eax),%eax
  103dc1:	8d 55 fc             	lea    -0x4(%ebp),%edx
  103dc4:	89 4c 24 08          	mov    %ecx,0x8(%esp)
  103dc8:	89 44 24 04          	mov    %eax,0x4(%esp)
  103dcc:	89 14 24             	mov    %edx,(%esp)
  103dcf:	e8 16 19 00 00       	call   1056ea <paging_getpte_pd>
  103dd4:	83 ec 04             	sub    $0x4,%esp
  if (pte.in_memory) {
  103dd7:	0f b6 45 fc          	movzbl -0x4(%ebp),%eax
  103ddb:	83 e0 01             	and    $0x1,%eax
  103dde:	84 c0                	test   %al,%al
  103de0:	74 3f                	je     103e21 <memuser_free+0x84>
    memphys_free(PAGE2ADDR(pte.page));
  103de2:	8b 45 fc             	mov    -0x4(%ebp),%eax
  103de5:	c1 e8 0c             	shr    $0xc,%eax
  103de8:	c1 e0 0c             	shl    $0xc,%eax
  103deb:	89 04 24             	mov    %eax,(%esp)
  103dee:	e8 21 f6 ff ff       	call   103414 <memphys_push>
    llist_remove(addrspace->pages_loaded,llist_find(addrspace->pages_loaded,page));
  103df3:	8b 45 08             	mov    0x8(%ebp),%eax
  103df6:	8b 50 04             	mov    0x4(%eax),%edx
  103df9:	8b 45 0c             	mov    0xc(%ebp),%eax
  103dfc:	89 44 24 04          	mov    %eax,0x4(%esp)
  103e00:	89 14 24             	mov    %edx,(%esp)
  103e03:	e8 19 6e 00 00       	call   10ac21 <llist_find>
  103e08:	89 c2                	mov    %eax,%edx
  103e0a:	8b 45 08             	mov    0x8(%ebp),%eax
  103e0d:	8b 40 04             	mov    0x4(%eax),%eax
  103e10:	89 54 24 04          	mov    %edx,0x4(%esp)
  103e14:	89 04 24             	mov    %eax,(%esp)
  103e17:	e8 3d 6d 00 00       	call   10ab59 <llist_remove>
  103e1c:	e9 97 00 00 00       	jmp    103eb8 <memuser_free+0x11b>
  }
  else if (pte.swapped) {
  103e21:	0f b6 45 fd          	movzbl -0x3(%ebp),%eax
  103e25:	83 e0 08             	and    $0x8,%eax
  103e28:	84 c0                	test   %al,%al
  103e2a:	74 40                	je     103e6c <memuser_free+0xcf>
    swap_remove(proc_current,page);
  103e2c:	8b 15 a0 e1 10 00    	mov    0x10e1a0,%edx
  103e32:	8b 45 0c             	mov    0xc(%ebp),%eax
  103e35:	89 44 24 04          	mov    %eax,0x4(%esp)
  103e39:	89 14 24             	mov    %edx,(%esp)
  103e3c:	e8 e5 5e 00 00       	call   109d26 <swap_remove>
    llist_remove(addrspace->pages_swapped,llist_find(addrspace->pages_swapped,page));
  103e41:	8b 45 08             	mov    0x8(%ebp),%eax
  103e44:	8b 50 0c             	mov    0xc(%eax),%edx
  103e47:	8b 45 0c             	mov    0xc(%ebp),%eax
  103e4a:	89 44 24 04          	mov    %eax,0x4(%esp)
  103e4e:	89 14 24             	mov    %edx,(%esp)
  103e51:	e8 cb 6d 00 00       	call   10ac21 <llist_find>
  103e56:	89 c2                	mov    %eax,%edx
  103e58:	8b 45 08             	mov    0x8(%ebp),%eax
  103e5b:	8b 40 0c             	mov    0xc(%eax),%eax
  103e5e:	89 54 24 04          	mov    %edx,0x4(%esp)
  103e62:	89 04 24             	mov    %eax,(%esp)
  103e65:	e8 ef 6c 00 00       	call   10ab59 <llist_remove>
  103e6a:	eb 4c                	jmp    103eb8 <memuser_free+0x11b>
  }
  else if (pte.cow) {
  103e6c:	0f b6 45 fc          	movzbl -0x4(%ebp),%eax
  103e70:	83 e0 80             	and    $0xffffff80,%eax
  103e73:	84 c0                	test   %al,%al
  103e75:	74 0d                	je     103e84 <memuser_free+0xe7>
    paging_unmap(page);
  103e77:	8b 45 0c             	mov    0xc(%ebp),%eax
  103e7a:	89 04 24             	mov    %eax,(%esp)
  103e7d:	e8 d5 1b 00 00       	call   105a57 <paging_unmap>
  103e82:	eb 34                	jmp    103eb8 <memuser_free+0x11b>
  }
  else {
    paging_unmap(page);
  103e84:	8b 45 0c             	mov    0xc(%ebp),%eax
  103e87:	89 04 24             	mov    %eax,(%esp)
  103e8a:	e8 c8 1b 00 00       	call   105a57 <paging_unmap>
    llist_remove(addrspace->pages_imaginary,llist_find(addrspace->pages_imaginary,page));
  103e8f:	8b 45 08             	mov    0x8(%ebp),%eax
  103e92:	8b 50 08             	mov    0x8(%eax),%edx
  103e95:	8b 45 0c             	mov    0xc(%ebp),%eax
  103e98:	89 44 24 04          	mov    %eax,0x4(%esp)
  103e9c:	89 14 24             	mov    %edx,(%esp)
  103e9f:	e8 7d 6d 00 00       	call   10ac21 <llist_find>
  103ea4:	89 c2                	mov    %eax,%edx
  103ea6:	8b 45 08             	mov    0x8(%ebp),%eax
  103ea9:	8b 40 08             	mov    0x8(%eax),%eax
  103eac:	89 54 24 04          	mov    %edx,0x4(%esp)
  103eb0:	89 04 24             	mov    %eax,(%esp)
  103eb3:	e8 a1 6c 00 00       	call   10ab59 <llist_remove>
  }
  memset(&pte,0,sizeof(pte));
  103eb8:	c7 44 24 08 04 00 00 	movl   $0x4,0x8(%esp)
  103ebf:	00 
  103ec0:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  103ec7:	00 
  103ec8:	8d 45 fc             	lea    -0x4(%ebp),%eax
  103ecb:	89 04 24             	mov    %eax,(%esp)
  103ece:	e8 8e 7e 00 00       	call   10bd61 <memset>
  paging_setpte_pd(page,pte,addrspace->pagedir);
  103ed3:	8b 45 08             	mov    0x8(%ebp),%eax
  103ed6:	8b 40 10             	mov    0x10(%eax),%eax
  103ed9:	89 44 24 08          	mov    %eax,0x8(%esp)
  103edd:	8b 45 fc             	mov    -0x4(%ebp),%eax
  103ee0:	89 44 24 04          	mov    %eax,0x4(%esp)
  103ee4:	8b 45 0c             	mov    0xc(%ebp),%eax
  103ee7:	89 04 24             	mov    %eax,(%esp)
  103eea:	e8 a4 18 00 00       	call   105793 <paging_setpte_pd>
  return 0;
  103eef:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
  103ef6:	8b 45 ec             	mov    -0x14(%ebp),%eax
}
  103ef9:	c9                   	leave  
  103efa:	c3                   	ret    

00103efb <memuser_free_syscall>:
/**
 * Frees an user page (Syscall)
 *  @param page Page
 *  @return Success?
 */
int memuser_free_syscall(void *page) {
  103efb:	55                   	push   %ebp
  103efc:	89 e5                	mov    %esp,%ebp
  103efe:	83 ec 08             	sub    $0x8,%esp
  return memuser_free(proc_current->addrspace,page);
  103f01:	a1 a0 e1 10 00       	mov    0x10e1a0,%eax
  103f06:	8b 50 6c             	mov    0x6c(%eax),%edx
  103f09:	8b 45 08             	mov    0x8(%ebp),%eax
  103f0c:	89 44 24 04          	mov    %eax,0x4(%esp)
  103f10:	89 14 24             	mov    %edx,(%esp)
  103f13:	e8 85 fe ff ff       	call   103d9d <memuser_free>
}
  103f18:	c9                   	leave  
  103f19:	c3                   	ret    

00103f1a <memuser_getphysaddr>:
 * Gets physical address of a virtual one in specified address space
 *  @param addrspace Address space
 *  @param virt Virtual address
 *  @return Physical address
 */
void *memuser_getphysaddr(addrspace_t *addrspace,void *virt) {
  103f1a:	55                   	push   %ebp
  103f1b:	89 e5                	mov    %esp,%ebp
  103f1d:	83 ec 28             	sub    $0x28,%esp
  pte_t pte = paging_getpte_pd(virt,addrspace->pagedir);
  103f20:	8b 45 08             	mov    0x8(%ebp),%eax
  103f23:	8b 40 10             	mov    0x10(%eax),%eax
  103f26:	8d 55 fc             	lea    -0x4(%ebp),%edx
  103f29:	89 44 24 08          	mov    %eax,0x8(%esp)
  103f2d:	8b 45 0c             	mov    0xc(%ebp),%eax
  103f30:	89 44 24 04          	mov    %eax,0x4(%esp)
  103f34:	89 14 24             	mov    %edx,(%esp)
  103f37:	e8 ae 17 00 00       	call   1056ea <paging_getpte_pd>
  103f3c:	83 ec 04             	sub    $0x4,%esp
  if (!pte.in_memory) return NULL;
  103f3f:	0f b6 45 fc          	movzbl -0x4(%ebp),%eax
  103f43:	83 e0 01             	and    $0x1,%eax
  103f46:	84 c0                	test   %al,%al
  103f48:	75 09                	jne    103f53 <memuser_getphysaddr+0x39>
  103f4a:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
  103f51:	eb 0c                	jmp    103f5f <memuser_getphysaddr+0x45>
  return PAGE2ADDR(pte.page);
  103f53:	8b 45 fc             	mov    -0x4(%ebp),%eax
  103f56:	c1 e8 0c             	shr    $0xc,%eax
  103f59:	c1 e0 0c             	shl    $0xc,%eax
  103f5c:	89 45 ec             	mov    %eax,-0x14(%ebp)
  103f5f:	8b 45 ec             	mov    -0x14(%ebp),%eax
}
  103f62:	c9                   	leave  
  103f63:	c3                   	ret    

00103f64 <memuser_getphysaddr_syscall>:
/**
 * Gets physical address of a virtual one in specified address space (Syscall)
 *  @param virt Virtual address
 *  @return Physical address
 */
void *memuser_getphysaddr_syscall(void *virt) {
  103f64:	55                   	push   %ebp
  103f65:	89 e5                	mov    %esp,%ebp
  103f67:	83 ec 08             	sub    $0x8,%esp
  return memuser_getphysaddr(proc_current->addrspace,virt);
  103f6a:	a1 a0 e1 10 00       	mov    0x10e1a0,%eax
  103f6f:	8b 50 6c             	mov    0x6c(%eax),%edx
  103f72:	8b 45 08             	mov    0x8(%ebp),%eax
  103f75:	89 44 24 04          	mov    %eax,0x4(%esp)
  103f79:	89 14 24             	mov    %edx,(%esp)
  103f7c:	e8 99 ff ff ff       	call   103f1a <memuser_getphysaddr>
}
  103f81:	c9                   	leave  
  103f82:	c3                   	ret    

00103f83 <memuser_create_stack>:
/**
 * Creates a stack
 *  @param addrspace Address space
 *  @return Stack address
 */
void *memuser_create_stack(addrspace_t *addrspace) {
  103f83:	55                   	push   %ebp
  103f84:	89 e5                	mov    %esp,%ebp
  103f86:	83 ec 18             	sub    $0x18,%esp
  addrspace->stack = memuser_alloc(addrspace,PAGE_SIZE,0);
  103f89:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  103f90:	00 
  103f91:	c7 44 24 04 00 10 00 	movl   $0x1000,0x4(%esp)
  103f98:	00 
  103f99:	8b 45 08             	mov    0x8(%ebp),%eax
  103f9c:	89 04 24             	mov    %eax,(%esp)
  103f9f:	e8 ab fc ff ff       	call   103c4f <memuser_alloc>
  103fa4:	89 c2                	mov    %eax,%edx
  103fa6:	8b 45 08             	mov    0x8(%ebp),%eax
  103fa9:	89 50 14             	mov    %edx,0x14(%eax)
  if (addrspace->stack!=NULL) return addrspace->stack+PAGE_SIZE-4;
  103fac:	8b 45 08             	mov    0x8(%ebp),%eax
  103faf:	8b 40 14             	mov    0x14(%eax),%eax
  103fb2:	85 c0                	test   %eax,%eax
  103fb4:	74 10                	je     103fc6 <memuser_create_stack+0x43>
  103fb6:	8b 45 08             	mov    0x8(%ebp),%eax
  103fb9:	8b 40 14             	mov    0x14(%eax),%eax
  103fbc:	05 fc 0f 00 00       	add    $0xffc,%eax
  103fc1:	89 45 fc             	mov    %eax,-0x4(%ebp)
  103fc4:	eb 07                	jmp    103fcd <memuser_create_stack+0x4a>
  else return NULL;
  103fc6:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
  103fcd:	8b 45 fc             	mov    -0x4(%ebp),%eax
}
  103fd0:	c9                   	leave  
  103fd1:	c3                   	ret    

00103fd2 <memuser_destroy_stack>:
/**
 * Destroys a stack
 *  @param addrspace Address space
 *  @return Success?
 */
int memuser_destroy_stack(addrspace_t *addrspace) {
  103fd2:	55                   	push   %ebp
  103fd3:	89 e5                	mov    %esp,%ebp
  103fd5:	83 ec 08             	sub    $0x8,%esp
  return memuser_free(addrspace,addrspace->stack);
  103fd8:	8b 45 08             	mov    0x8(%ebp),%eax
  103fdb:	8b 40 14             	mov    0x14(%eax),%eax
  103fde:	89 44 24 04          	mov    %eax,0x4(%esp)
  103fe2:	8b 45 08             	mov    0x8(%ebp),%eax
  103fe5:	89 04 24             	mov    %eax,(%esp)
  103fe8:	e8 b0 fd ff ff       	call   103d9d <memuser_free>
}
  103fed:	c9                   	leave  
  103fee:	c3                   	ret    

00103fef <memuser_pagefault>:
/**
 * User memory pagefault handler
 *  @param addr Address
 *  @return If Pagefault is a "real" Pagefault
 */
int memuser_pagefault(void *addr) {
  103fef:	55                   	push   %ebp
  103ff0:	89 e5                	mov    %esp,%ebp
  103ff2:	83 ec 38             	sub    $0x38,%esp
  addrspace_t *addrspace = proc_current->addrspace;
  103ff5:	a1 a0 e1 10 00       	mov    0x10e1a0,%eax
  103ffa:	8b 40 6c             	mov    0x6c(%eax),%eax
  103ffd:	89 45 f0             	mov    %eax,-0x10(%ebp)
  void *page = PAGEDOWN(addr);
  104000:	8b 45 08             	mov    0x8(%ebp),%eax
  104003:	c1 e8 0c             	shr    $0xc,%eax
  104006:	c1 e0 0c             	shl    $0xc,%eax
  104009:	89 45 f4             	mov    %eax,-0xc(%ebp)
  pte_t pte = paging_getpte(page);
  10400c:	8d 55 ec             	lea    -0x14(%ebp),%edx
  10400f:	8b 45 f4             	mov    -0xc(%ebp),%eax
  104012:	89 44 24 04          	mov    %eax,0x4(%esp)
  104016:	89 14 24             	mov    %edx,(%esp)
  104019:	e8 c5 14 00 00       	call   1054e3 <paging_getpte>
  10401e:	83 ec 04             	sub    $0x4,%esp
  if (!pte.exists) return -1;
  104021:	0f b6 45 ed          	movzbl -0x13(%ebp),%eax
  104025:	83 e0 02             	and    $0x2,%eax
  104028:	84 c0                	test   %al,%al
  10402a:	75 0c                	jne    104038 <memuser_pagefault+0x49>
  10402c:	c7 45 dc ff ff ff ff 	movl   $0xffffffff,-0x24(%ebp)
  104033:	e9 dd 01 00 00       	jmp    104215 <memuser_pagefault+0x226>
  else if (pte.swapped && pte.in_memory==0) {
  104038:	0f b6 45 ed          	movzbl -0x13(%ebp),%eax
  10403c:	83 e0 08             	and    $0x8,%eax
  10403f:	84 c0                	test   %al,%al
  104041:	0f 84 9f 00 00 00    	je     1040e6 <memuser_pagefault+0xf7>
  104047:	0f b6 45 ec          	movzbl -0x14(%ebp),%eax
  10404b:	83 e0 01             	and    $0x1,%eax
  10404e:	84 c0                	test   %al,%al
  104050:	0f 85 90 00 00 00    	jne    1040e6 <memuser_pagefault+0xf7>
    kprintf("kernel: Catched access to out-swapped memory\n");
  104056:	c7 04 24 4c d6 10 00 	movl   $0x10d64c,(%esp)
  10405d:	e8 39 e3 ff ff       	call   10239b <kprintf>
    if (swap_in(proc_current,page)!=-1) {
  104062:	a1 a0 e1 10 00       	mov    0x10e1a0,%eax
  104067:	8b 55 f4             	mov    -0xc(%ebp),%edx
  10406a:	89 54 24 04          	mov    %edx,0x4(%esp)
  10406e:	89 04 24             	mov    %eax,(%esp)
  104071:	e8 cb 5a 00 00       	call   109b41 <swap_in>
  104076:	83 f8 ff             	cmp    $0xffffffff,%eax
  104079:	74 5f                	je     1040da <memuser_pagefault+0xeb>
      llist_remove(addrspace->pages_swapped,llist_find(addrspace->pages_swapped,page));
  10407b:	8b 45 f0             	mov    -0x10(%ebp),%eax
  10407e:	8b 50 0c             	mov    0xc(%eax),%edx
  104081:	8b 45 f4             	mov    -0xc(%ebp),%eax
  104084:	89 44 24 04          	mov    %eax,0x4(%esp)
  104088:	89 14 24             	mov    %edx,(%esp)
  10408b:	e8 91 6b 00 00       	call   10ac21 <llist_find>
  104090:	89 c2                	mov    %eax,%edx
  104092:	8b 45 f0             	mov    -0x10(%ebp),%eax
  104095:	8b 40 0c             	mov    0xc(%eax),%eax
  104098:	89 54 24 04          	mov    %edx,0x4(%esp)
  10409c:	89 04 24             	mov    %eax,(%esp)
  10409f:	e8 b5 6a 00 00       	call   10ab59 <llist_remove>
      llist_push(addrspace->pages_loaded,page);
  1040a4:	8b 45 f0             	mov    -0x10(%ebp),%eax
  1040a7:	8b 50 04             	mov    0x4(%eax),%edx
  1040aa:	8b 45 f4             	mov    -0xc(%ebp),%eax
  1040ad:	89 44 24 04          	mov    %eax,0x4(%esp)
  1040b1:	89 14 24             	mov    %edx,(%esp)
  1040b4:	e8 96 68 00 00       	call   10a94f <llist_push>
      swap_remove(proc_current,page);
  1040b9:	8b 15 a0 e1 10 00    	mov    0x10e1a0,%edx
  1040bf:	8b 45 f4             	mov    -0xc(%ebp),%eax
  1040c2:	89 44 24 04          	mov    %eax,0x4(%esp)
  1040c6:	89 14 24             	mov    %edx,(%esp)
  1040c9:	e8 58 5c 00 00       	call   109d26 <swap_remove>
      return 0;
  1040ce:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
  1040d5:	e9 3b 01 00 00       	jmp    104215 <memuser_pagefault+0x226>
    }
    else return -1;
  1040da:	c7 45 dc ff ff ff ff 	movl   $0xffffffff,-0x24(%ebp)
  1040e1:	e9 2f 01 00 00       	jmp    104215 <memuser_pagefault+0x226>
  }
  else if (pte.cow && pte.in_memory==1) {
  1040e6:	0f b6 45 ec          	movzbl -0x14(%ebp),%eax
  1040ea:	83 e0 80             	and    $0xffffff80,%eax
  1040ed:	84 c0                	test   %al,%al
  1040ef:	0f 84 88 00 00 00    	je     10417d <memuser_pagefault+0x18e>
  1040f5:	0f b6 45 ec          	movzbl -0x14(%ebp),%eax
  1040f9:	83 e0 01             	and    $0x1,%eax
  1040fc:	84 c0                	test   %al,%al
  1040fe:	74 7d                	je     10417d <memuser_pagefault+0x18e>
    void *old = PAGE2ADDR(pte.page);
  104100:	8b 45 ec             	mov    -0x14(%ebp),%eax
  104103:	c1 e8 0c             	shr    $0xc,%eax
  104106:	c1 e0 0c             	shl    $0xc,%eax
  104109:	89 45 f8             	mov    %eax,-0x8(%ebp)
    void *new = memphys_alloc();
  10410c:	e8 a4 f3 ff ff       	call   1034b5 <memphys_pop>
  104111:	89 45 fc             	mov    %eax,-0x4(%ebp)
    pte.page = ADDR2PAGE(new);
  104114:	8b 45 fc             	mov    -0x4(%ebp),%eax
  104117:	c1 e8 0c             	shr    $0xc,%eax
  10411a:	25 ff ff 0f 00       	and    $0xfffff,%eax
  10411f:	89 c2                	mov    %eax,%edx
  104121:	c1 e2 0c             	shl    $0xc,%edx
  104124:	8b 45 ec             	mov    -0x14(%ebp),%eax
  104127:	25 ff 0f 00 00       	and    $0xfff,%eax
  10412c:	09 d0                	or     %edx,%eax
  10412e:	89 45 ec             	mov    %eax,-0x14(%ebp)
    pte.cow = 0;
  104131:	0f b6 45 ec          	movzbl -0x14(%ebp),%eax
  104135:	83 e0 7f             	and    $0x7f,%eax
  104138:	88 45 ec             	mov    %al,-0x14(%ebp)
    pte.writable = 1;
  10413b:	0f b6 45 ec          	movzbl -0x14(%ebp),%eax
  10413f:	83 c8 02             	or     $0x2,%eax
  104142:	88 45 ec             	mov    %al,-0x14(%ebp)
    paging_setpte(page,pte);
  104145:	8b 45 ec             	mov    -0x14(%ebp),%eax
  104148:	89 44 24 04          	mov    %eax,0x4(%esp)
  10414c:	8b 45 f4             	mov    -0xc(%ebp),%eax
  10414f:	89 04 24             	mov    %eax,(%esp)
  104152:	e8 31 14 00 00       	call   105588 <paging_setpte>
    paging_physread(page,old,PAGE_SIZE);
  104157:	c7 44 24 08 00 10 00 	movl   $0x1000,0x8(%esp)
  10415e:	00 
  10415f:	8b 45 f8             	mov    -0x8(%ebp),%eax
  104162:	89 44 24 04          	mov    %eax,0x4(%esp)
  104166:	8b 45 f4             	mov    -0xc(%ebp),%eax
  104169:	89 04 24             	mov    %eax,(%esp)
  10416c:	e8 aa 10 00 00       	call   10521b <paging_physread>
    return 0;
  104171:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
  104178:	e9 98 00 00 00       	jmp    104215 <memuser_pagefault+0x226>
  }
  else if (pte.in_memory==0) {
  10417d:	0f b6 45 ec          	movzbl -0x14(%ebp),%eax
  104181:	83 e0 01             	and    $0x1,%eax
  104184:	84 c0                	test   %al,%al
  104186:	0f 85 82 00 00 00    	jne    10420e <memuser_pagefault+0x21f>
    pte.page = ADDR2PAGE(memphys_alloc());
  10418c:	e8 24 f3 ff ff       	call   1034b5 <memphys_pop>
  104191:	c1 e8 0c             	shr    $0xc,%eax
  104194:	25 ff ff 0f 00       	and    $0xfffff,%eax
  104199:	89 c2                	mov    %eax,%edx
  10419b:	c1 e2 0c             	shl    $0xc,%edx
  10419e:	8b 45 ec             	mov    -0x14(%ebp),%eax
  1041a1:	25 ff 0f 00 00       	and    $0xfff,%eax
  1041a6:	09 d0                	or     %edx,%eax
  1041a8:	89 45 ec             	mov    %eax,-0x14(%ebp)
    pte.in_memory = 1;
  1041ab:	0f b6 45 ec          	movzbl -0x14(%ebp),%eax
  1041af:	83 c8 01             	or     $0x1,%eax
  1041b2:	88 45 ec             	mov    %al,-0x14(%ebp)
    paging_setpte(page,pte);
  1041b5:	8b 45 ec             	mov    -0x14(%ebp),%eax
  1041b8:	89 44 24 04          	mov    %eax,0x4(%esp)
  1041bc:	8b 45 f4             	mov    -0xc(%ebp),%eax
  1041bf:	89 04 24             	mov    %eax,(%esp)
  1041c2:	e8 c1 13 00 00       	call   105588 <paging_setpte>
    llist_remove(addrspace->pages_imaginary,llist_find(addrspace->pages_imaginary,page));
  1041c7:	8b 45 f0             	mov    -0x10(%ebp),%eax
  1041ca:	8b 50 08             	mov    0x8(%eax),%edx
  1041cd:	8b 45 f4             	mov    -0xc(%ebp),%eax
  1041d0:	89 44 24 04          	mov    %eax,0x4(%esp)
  1041d4:	89 14 24             	mov    %edx,(%esp)
  1041d7:	e8 45 6a 00 00       	call   10ac21 <llist_find>
  1041dc:	89 c2                	mov    %eax,%edx
  1041de:	8b 45 f0             	mov    -0x10(%ebp),%eax
  1041e1:	8b 40 08             	mov    0x8(%eax),%eax
  1041e4:	89 54 24 04          	mov    %edx,0x4(%esp)
  1041e8:	89 04 24             	mov    %eax,(%esp)
  1041eb:	e8 69 69 00 00       	call   10ab59 <llist_remove>
    llist_push(addrspace->pages_loaded,page);
  1041f0:	8b 45 f0             	mov    -0x10(%ebp),%eax
  1041f3:	8b 50 04             	mov    0x4(%eax),%edx
  1041f6:	8b 45 f4             	mov    -0xc(%ebp),%eax
  1041f9:	89 44 24 04          	mov    %eax,0x4(%esp)
  1041fd:	89 14 24             	mov    %edx,(%esp)
  104200:	e8 4a 67 00 00       	call   10a94f <llist_push>
    return 0;
  104205:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
  10420c:	eb 07                	jmp    104215 <memuser_pagefault+0x226>
  }
  else return -1;
  10420e:	c7 45 dc ff ff ff ff 	movl   $0xffffffff,-0x24(%ebp)
  104215:	8b 45 dc             	mov    -0x24(%ebp),%eax
}
  104218:	c9                   	leave  
  104219:	c3                   	ret    

0010421a <memuser_alloc_at>:
 *  @param addrspace Address space
 *  @param addr Address to allocate
 *  @param writable If page is writable
 *  @return Success?
 */
int memuser_alloc_at(addrspace_t *addrspace,void *addr,void *phys,int writable) {
  10421a:	55                   	push   %ebp
  10421b:	89 e5                	mov    %esp,%ebp
  10421d:	83 ec 28             	sub    $0x28,%esp
  if (!paging_getpde_pd(addr,addrspace->pagedir).exists) {
  104220:	8b 45 08             	mov    0x8(%ebp),%eax
  104223:	8b 40 10             	mov    0x10(%eax),%eax
  104226:	8d 55 fc             	lea    -0x4(%ebp),%edx
  104229:	89 44 24 08          	mov    %eax,0x8(%esp)
  10422d:	8b 45 0c             	mov    0xc(%ebp),%eax
  104230:	89 44 24 04          	mov    %eax,0x4(%esp)
  104234:	89 14 24             	mov    %edx,(%esp)
  104237:	e8 e9 13 00 00       	call   105625 <paging_getpde_pd>
  10423c:	83 ec 04             	sub    $0x4,%esp
  10423f:	0f b6 45 fc          	movzbl -0x4(%ebp),%eax
  104243:	83 e0 01             	and    $0x1,%eax
  104246:	84 c0                	test   %al,%al
  104248:	75 15                	jne    10425f <memuser_alloc_at+0x45>
    memuser_create_pagetable(addrspace->pagedir,addr);
  10424a:	8b 45 08             	mov    0x8(%ebp),%eax
  10424d:	8b 50 10             	mov    0x10(%eax),%edx
  104250:	8b 45 0c             	mov    0xc(%ebp),%eax
  104253:	89 44 24 04          	mov    %eax,0x4(%esp)
  104257:	89 14 24             	mov    %edx,(%esp)
  10425a:	e8 a6 f7 ff ff       	call   103a05 <memuser_create_pagetable>
  }

  pte_t pte = paging_getpte_pd(addr,addrspace->pagedir);
  10425f:	8b 45 08             	mov    0x8(%ebp),%eax
  104262:	8b 40 10             	mov    0x10(%eax),%eax
  104265:	8d 55 f8             	lea    -0x8(%ebp),%edx
  104268:	89 44 24 08          	mov    %eax,0x8(%esp)
  10426c:	8b 45 0c             	mov    0xc(%ebp),%eax
  10426f:	89 44 24 04          	mov    %eax,0x4(%esp)
  104273:	89 14 24             	mov    %edx,(%esp)
  104276:	e8 6f 14 00 00       	call   1056ea <paging_getpte_pd>
  10427b:	83 ec 04             	sub    $0x4,%esp
  memset(&pte,0,sizeof(pte));
  10427e:	c7 44 24 08 04 00 00 	movl   $0x4,0x8(%esp)
  104285:	00 
  104286:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  10428d:	00 
  10428e:	8d 45 f8             	lea    -0x8(%ebp),%eax
  104291:	89 04 24             	mov    %eax,(%esp)
  104294:	e8 c8 7a 00 00       	call   10bd61 <memset>
  pte.exists = 1;
  104299:	0f b6 45 f9          	movzbl -0x7(%ebp),%eax
  10429d:	83 c8 02             	or     $0x2,%eax
  1042a0:	88 45 f9             	mov    %al,-0x7(%ebp)
  pte.in_memory = 1;
  1042a3:	0f b6 45 f8          	movzbl -0x8(%ebp),%eax
  1042a7:	83 c8 01             	or     $0x1,%eax
  1042aa:	88 45 f8             	mov    %al,-0x8(%ebp)
  pte.swappable = 1;
  1042ad:	0f b6 45 f9          	movzbl -0x7(%ebp),%eax
  1042b1:	83 c8 04             	or     $0x4,%eax
  1042b4:	88 45 f9             	mov    %al,-0x7(%ebp)
  pte.writable = writable;
  1042b7:	8b 45 14             	mov    0x14(%ebp),%eax
  1042ba:	83 e0 01             	and    $0x1,%eax
  1042bd:	83 e0 01             	and    $0x1,%eax
  1042c0:	8d 14 00             	lea    (%eax,%eax,1),%edx
  1042c3:	0f b6 45 f8          	movzbl -0x8(%ebp),%eax
  1042c7:	83 e0 fd             	and    $0xfffffffd,%eax
  1042ca:	09 d0                	or     %edx,%eax
  1042cc:	88 45 f8             	mov    %al,-0x8(%ebp)
  pte.user = 1;
  1042cf:	0f b6 45 f8          	movzbl -0x8(%ebp),%eax
  1042d3:	83 c8 04             	or     $0x4,%eax
  1042d6:	88 45 f8             	mov    %al,-0x8(%ebp)
  if (phys==NULL) phys = memphys_alloc();
  1042d9:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
  1042dd:	75 08                	jne    1042e7 <memuser_alloc_at+0xcd>
  1042df:	e8 d1 f1 ff ff       	call   1034b5 <memphys_pop>
  1042e4:	89 45 10             	mov    %eax,0x10(%ebp)
  pte.page = ADDR2PAGE(phys);
  1042e7:	8b 45 10             	mov    0x10(%ebp),%eax
  1042ea:	c1 e8 0c             	shr    $0xc,%eax
  1042ed:	25 ff ff 0f 00       	and    $0xfffff,%eax
  1042f2:	89 c2                	mov    %eax,%edx
  1042f4:	c1 e2 0c             	shl    $0xc,%edx
  1042f7:	8b 45 f8             	mov    -0x8(%ebp),%eax
  1042fa:	25 ff 0f 00 00       	and    $0xfff,%eax
  1042ff:	09 d0                	or     %edx,%eax
  104301:	89 45 f8             	mov    %eax,-0x8(%ebp)
  paging_setpte_pd(addr,pte,addrspace->pagedir);
  104304:	8b 45 08             	mov    0x8(%ebp),%eax
  104307:	8b 40 10             	mov    0x10(%eax),%eax
  10430a:	89 44 24 08          	mov    %eax,0x8(%esp)
  10430e:	8b 45 f8             	mov    -0x8(%ebp),%eax
  104311:	89 44 24 04          	mov    %eax,0x4(%esp)
  104315:	8b 45 0c             	mov    0xc(%ebp),%eax
  104318:	89 04 24             	mov    %eax,(%esp)
  10431b:	e8 73 14 00 00       	call   105793 <paging_setpte_pd>
  llist_push(addrspace->pages_loaded,addr);
  104320:	8b 45 08             	mov    0x8(%ebp),%eax
  104323:	8b 50 04             	mov    0x4(%eax),%edx
  104326:	8b 45 0c             	mov    0xc(%ebp),%eax
  104329:	89 44 24 04          	mov    %eax,0x4(%esp)
  10432d:	89 14 24             	mov    %edx,(%esp)
  104330:	e8 1a 66 00 00       	call   10a94f <llist_push>
  return 0;
  104335:	b8 00 00 00 00       	mov    $0x0,%eax
}
  10433a:	c9                   	leave  
  10433b:	c3                   	ret    

0010433c <memuser_syncpds>:

/**
 * Syncronize current pagedir with all other pagedirs
 */
int memuser_syncpds(void *addr) {
  10433c:	55                   	push   %ebp
  10433d:	89 e5                	mov    %esp,%ebp
  10433f:	83 ec 18             	sub    $0x18,%esp
  size_t i;
  proc_t *proc;
  pde_t pde = paging_getpde(addr);
  104342:	8d 55 f4             	lea    -0xc(%ebp),%edx
  104345:	8b 45 08             	mov    0x8(%ebp),%eax
  104348:	89 44 24 04          	mov    %eax,0x4(%esp)
  10434c:	89 14 24             	mov    %edx,(%esp)
  10434f:	e8 ef 10 00 00       	call   105443 <paging_getpde>
  104354:	83 ec 04             	sub    $0x4,%esp

  for (i=0;(proc = llist_get(proc_all,i));i++) {
  104357:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
  10435e:	eb 24                	jmp    104384 <memuser_syncpds+0x48>
    memuser_load_addrspace(proc->addrspace);
  104360:	8b 45 fc             	mov    -0x4(%ebp),%eax
  104363:	8b 40 6c             	mov    0x6c(%eax),%eax
  104366:	89 04 24             	mov    %eax,(%esp)
  104369:	e8 ad f8 ff ff       	call   103c1b <memuser_load_addrspace>
    paging_setpde(addr,pde);
  10436e:	8b 45 f4             	mov    -0xc(%ebp),%eax
  104371:	89 44 24 04          	mov    %eax,0x4(%esp)
  104375:	8b 45 08             	mov    0x8(%ebp),%eax
  104378:	89 04 24             	mov    %eax,(%esp)
  10437b:	e8 0d 11 00 00       	call   10548d <paging_setpde>
int memuser_syncpds(void *addr) {
  size_t i;
  proc_t *proc;
  pde_t pde = paging_getpde(addr);

  for (i=0;(proc = llist_get(proc_all,i));i++) {
  104380:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
  104384:	a1 80 e1 10 00       	mov    0x10e180,%eax
  104389:	8b 55 f8             	mov    -0x8(%ebp),%edx
  10438c:	89 54 24 04          	mov    %edx,0x4(%esp)
  104390:	89 04 24             	mov    %eax,(%esp)
  104393:	e8 ef 66 00 00       	call   10aa87 <llist_get>
  104398:	89 45 fc             	mov    %eax,-0x4(%ebp)
  10439b:	83 7d fc 00          	cmpl   $0x0,-0x4(%ebp)
  10439f:	75 bf                	jne    104360 <memuser_syncpds+0x24>
    memuser_load_addrspace(proc->addrspace);
    paging_setpde(addr,pde);
  }
  if (proc_current!=NULL) memuser_load_addrspace(proc_current->addrspace);
  1043a1:	a1 a0 e1 10 00       	mov    0x10e1a0,%eax
  1043a6:	85 c0                	test   %eax,%eax
  1043a8:	74 10                	je     1043ba <memuser_syncpds+0x7e>
  1043aa:	a1 a0 e1 10 00       	mov    0x10e1a0,%eax
  1043af:	8b 40 6c             	mov    0x6c(%eax),%eax
  1043b2:	89 04 24             	mov    %eax,(%esp)
  1043b5:	e8 61 f8 ff ff       	call   103c1b <memuser_load_addrspace>

  return 0;
  1043ba:	b8 00 00 00 00       	mov    $0x0,%eax
}
  1043bf:	c9                   	leave  
  1043c0:	c3                   	ret    

001043c1 <memuser_getvga>:

/**
 * Maps VGA memory in address space
 *  @return Success?
 */
void *memuser_getvga() {
  1043c1:	55                   	push   %ebp
  1043c2:	89 e5                	mov    %esp,%ebp
  1043c4:	83 ec 38             	sub    $0x38,%esp
  void *virt;
  if ((virt = memuser_findvirt(proc_current->addrspace,1))) paging_map(virt,(void*)VGA_TEXT_ADDRESS,1,proc_current->gid==PERM_ROOTGID);
  1043c7:	a1 a0 e1 10 00       	mov    0x10e1a0,%eax
  1043cc:	8b 40 6c             	mov    0x6c(%eax),%eax
  1043cf:	c7 44 24 04 01 00 00 	movl   $0x1,0x4(%esp)
  1043d6:	00 
  1043d7:	89 04 24             	mov    %eax,(%esp)
  1043da:	e8 5c f4 ff ff       	call   10383b <memuser_findvirt>
  1043df:	89 45 fc             	mov    %eax,-0x4(%ebp)
  1043e2:	83 7d fc 00          	cmpl   $0x0,-0x4(%ebp)
  1043e6:	74 4a                	je     104432 <memuser_getvga+0x71>
  1043e8:	8b 15 74 e4 10 00    	mov    0x10e474,%edx
  1043ee:	a1 a0 e1 10 00       	mov    0x10e1a0,%eax
  1043f3:	8b 40 10             	mov    0x10(%eax),%eax
  1043f6:	83 f8 01             	cmp    $0x1,%eax
  1043f9:	0f 94 c0             	sete   %al
  1043fc:	0f b6 c0             	movzbl %al,%eax
  1043ff:	89 54 24 18          	mov    %edx,0x18(%esp)
  104403:	c7 44 24 14 00 00 00 	movl   $0x0,0x14(%esp)
  10440a:	00 
  10440b:	c7 44 24 10 00 00 00 	movl   $0x0,0x10(%esp)
  104412:	00 
  104413:	89 44 24 0c          	mov    %eax,0xc(%esp)
  104417:	c7 44 24 08 01 00 00 	movl   $0x1,0x8(%esp)
  10441e:	00 
  10441f:	c7 44 24 04 00 80 0b 	movl   $0xb8000,0x4(%esp)
  104426:	00 
  104427:	8b 45 fc             	mov    -0x4(%ebp),%eax
  10442a:	89 04 24             	mov    %eax,(%esp)
  10442d:	e8 0b 14 00 00       	call   10583d <paging_map_pd>
  return virt;
  104432:	8b 45 fc             	mov    -0x4(%ebp),%eax
}
  104435:	c9                   	leave  
  104436:	c3                   	ret    

00104437 <memuser_dma_alloc>:
/**
 * Allocates DMA memory and maps it into address space (Syscall)
 *  @param size Size of DMA memory
 *  @return DMA memory
 */
void *memuser_dma_alloc(size_t size) {
  104437:	55                   	push   %ebp
  104438:	89 e5                	mov    %esp,%ebp
  10443a:	53                   	push   %ebx
  10443b:	83 ec 34             	sub    $0x34,%esp
  void *phys = memphys_dma_alloc(size/PAGE_SIZE);
  10443e:	8b 45 08             	mov    0x8(%ebp),%eax
  104441:	c1 e8 0c             	shr    $0xc,%eax
  104444:	89 04 24             	mov    %eax,(%esp)
  104447:	e8 75 f1 ff ff       	call   1035c1 <memphys_dma_alloc>
  10444c:	89 45 f0             	mov    %eax,-0x10(%ebp)
  if (phys!=NULL) {
  10444f:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
  104453:	0f 84 8c 00 00 00    	je     1044e5 <memuser_dma_alloc+0xae>
    void *virt = memuser_findvirt(proc_current->addrspace,size/PAGE_SIZE);
  104459:	8b 45 08             	mov    0x8(%ebp),%eax
  10445c:	89 c2                	mov    %eax,%edx
  10445e:	c1 ea 0c             	shr    $0xc,%edx
  104461:	a1 a0 e1 10 00       	mov    0x10e1a0,%eax
  104466:	8b 40 6c             	mov    0x6c(%eax),%eax
  104469:	89 54 24 04          	mov    %edx,0x4(%esp)
  10446d:	89 04 24             	mov    %eax,(%esp)
  104470:	e8 c6 f3 ff ff       	call   10383b <memuser_findvirt>
  104475:	89 45 f4             	mov    %eax,-0xc(%ebp)
    if (virt!=NULL) {
  104478:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
  10447c:	74 67                	je     1044e5 <memuser_dma_alloc+0xae>
      size_t i;
      for (i=0;i<size;i+=PAGE_SIZE) {
  10447e:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
  104485:	eb 4e                	jmp    1044d5 <memuser_dma_alloc+0x9e>
        paging_map(virt+i,phys+i,1,1);
  104487:	8b 0d 74 e4 10 00    	mov    0x10e474,%ecx
  10448d:	8b 55 f8             	mov    -0x8(%ebp),%edx
  104490:	8b 45 f0             	mov    -0x10(%ebp),%eax
  104493:	8d 1c 10             	lea    (%eax,%edx,1),%ebx
  104496:	8b 55 f8             	mov    -0x8(%ebp),%edx
  104499:	8b 45 f4             	mov    -0xc(%ebp),%eax
  10449c:	01 d0                	add    %edx,%eax
  10449e:	89 4c 24 18          	mov    %ecx,0x18(%esp)
  1044a2:	c7 44 24 14 00 00 00 	movl   $0x0,0x14(%esp)
  1044a9:	00 
  1044aa:	c7 44 24 10 00 00 00 	movl   $0x0,0x10(%esp)
  1044b1:	00 
  1044b2:	c7 44 24 0c 01 00 00 	movl   $0x1,0xc(%esp)
  1044b9:	00 
  1044ba:	c7 44 24 08 01 00 00 	movl   $0x1,0x8(%esp)
  1044c1:	00 
  1044c2:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  1044c6:	89 04 24             	mov    %eax,(%esp)
  1044c9:	e8 6f 13 00 00       	call   10583d <paging_map_pd>
  void *phys = memphys_dma_alloc(size/PAGE_SIZE);
  if (phys!=NULL) {
    void *virt = memuser_findvirt(proc_current->addrspace,size/PAGE_SIZE);
    if (virt!=NULL) {
      size_t i;
      for (i=0;i<size;i+=PAGE_SIZE) {
  1044ce:	81 45 f8 00 10 00 00 	addl   $0x1000,-0x8(%ebp)
  1044d5:	8b 45 f8             	mov    -0x8(%ebp),%eax
  1044d8:	3b 45 08             	cmp    0x8(%ebp),%eax
  1044db:	72 aa                	jb     104487 <memuser_dma_alloc+0x50>
        paging_map(virt+i,phys+i,1,1);
        //llist_push(proc_current->addrspace->pages_loaded,virt+i);
      }
      return virt;
  1044dd:	8b 45 f4             	mov    -0xc(%ebp),%eax
  1044e0:	89 45 e8             	mov    %eax,-0x18(%ebp)
  1044e3:	eb 07                	jmp    1044ec <memuser_dma_alloc+0xb5>
    }
  }
  return NULL;
  1044e5:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
  1044ec:	8b 45 e8             	mov    -0x18(%ebp),%eax
}
  1044ef:	83 c4 34             	add    $0x34,%esp
  1044f2:	5b                   	pop    %ebx
  1044f3:	5d                   	pop    %ebp
  1044f4:	c3                   	ret    

001044f5 <memuser_dma_free>:
/**
 * Unmaps DMA memory and frees it (Syscall)
 *  @param addr DMA memory
 *  @param size Size of DMA memory
 */
int memuser_dma_free(void *addr,size_t size) {
  1044f5:	55                   	push   %ebp
  1044f6:	89 e5                	mov    %esp,%ebp
  1044f8:	83 ec 18             	sub    $0x18,%esp
  size_t i;
  for (i=0;i<size;i+=PAGE_SIZE) {
  1044fb:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
  104502:	eb 1f                	jmp    104523 <memuser_dma_free+0x2e>
    //llist_remove(proc_current->addrspace->pages_loaded,llist_find(proc_current->addrspace->pages_loaded,addr));
    memphys_dma_free(paging_unmap(addr+i));
  104504:	8b 55 fc             	mov    -0x4(%ebp),%edx
  104507:	8b 45 08             	mov    0x8(%ebp),%eax
  10450a:	01 d0                	add    %edx,%eax
  10450c:	89 04 24             	mov    %eax,(%esp)
  10450f:	e8 43 15 00 00       	call   105a57 <paging_unmap>
  104514:	89 04 24             	mov    %eax,(%esp)
  104517:	e8 88 f1 ff ff       	call   1036a4 <memphys_dma_free>
 *  @param addr DMA memory
 *  @param size Size of DMA memory
 */
int memuser_dma_free(void *addr,size_t size) {
  size_t i;
  for (i=0;i<size;i+=PAGE_SIZE) {
  10451c:	81 45 fc 00 10 00 00 	addl   $0x1000,-0x4(%ebp)
  104523:	8b 45 fc             	mov    -0x4(%ebp),%eax
  104526:	3b 45 0c             	cmp    0xc(%ebp),%eax
  104529:	72 d9                	jb     104504 <memuser_dma_free+0xf>
    //llist_remove(proc_current->addrspace->pages_loaded,llist_find(proc_current->addrspace->pages_loaded,addr));
    memphys_dma_free(paging_unmap(addr+i));
  }
  return 0;
  10452b:	b8 00 00 00 00       	mov    $0x0,%eax
}
  104530:	c9                   	leave  
  104531:	c3                   	ret    
	...

00104534 <ipc_msg_init>:
#include <errno.h>
#include <debug.h>

#define ipc_msg_find(key,id) ipc_find(key,id,IPC_MSG)

int ipc_msg_init() {
  104534:	55                   	push   %ebp
  104535:	89 e5                	mov    %esp,%ebp
  104537:	83 ec 18             	sub    $0x18,%esp
  if (syscall_create(SYSCALL_IPC_MSG_GET,ipc_msg_get,1)==-1) return -1;
  10453a:	c7 44 24 08 01 00 00 	movl   $0x1,0x8(%esp)
  104541:	00 
  104542:	c7 44 24 04 1e 46 10 	movl   $0x10461e,0x4(%esp)
  104549:	00 
  10454a:	c7 04 24 07 00 00 00 	movl   $0x7,(%esp)
  104551:	e8 e4 58 00 00       	call   109e3a <syscall_create>
  104556:	83 f8 ff             	cmp    $0xffffffff,%eax
  104559:	75 0c                	jne    104567 <ipc_msg_init+0x33>
  10455b:	c7 45 fc ff ff ff ff 	movl   $0xffffffff,-0x4(%ebp)
  104562:	e9 b2 00 00 00       	jmp    104619 <ipc_msg_init+0xe5>
  if (syscall_create(SYSCALL_IPC_MSG_CREATE,ipc_msg_create,3)==-1) return -1;
  104567:	c7 44 24 08 03 00 00 	movl   $0x3,0x8(%esp)
  10456e:	00 
  10456f:	c7 44 24 04 5f 46 10 	movl   $0x10465f,0x4(%esp)
  104576:	00 
  104577:	c7 04 24 08 00 00 00 	movl   $0x8,(%esp)
  10457e:	e8 b7 58 00 00       	call   109e3a <syscall_create>
  104583:	83 f8 ff             	cmp    $0xffffffff,%eax
  104586:	75 0c                	jne    104594 <ipc_msg_init+0x60>
  104588:	c7 45 fc ff ff ff ff 	movl   $0xffffffff,-0x4(%ebp)
  10458f:	e9 85 00 00 00       	jmp    104619 <ipc_msg_init+0xe5>
  if (syscall_create(SYSCALL_IPC_MSG_DESTROY,ipc_msg_destroy,2)==-1) return -1;
  104594:	c7 44 24 08 02 00 00 	movl   $0x2,0x8(%esp)
  10459b:	00 
  10459c:	c7 44 24 04 6c 47 10 	movl   $0x10476c,0x4(%esp)
  1045a3:	00 
  1045a4:	c7 04 24 09 00 00 00 	movl   $0x9,(%esp)
  1045ab:	e8 8a 58 00 00       	call   109e3a <syscall_create>
  1045b0:	83 f8 ff             	cmp    $0xffffffff,%eax
  1045b3:	75 09                	jne    1045be <ipc_msg_init+0x8a>
  1045b5:	c7 45 fc ff ff ff ff 	movl   $0xffffffff,-0x4(%ebp)
  1045bc:	eb 5b                	jmp    104619 <ipc_msg_init+0xe5>
  if (syscall_create(SYSCALL_IPC_MSG_SEND,ipc_msg_send,6)==-1) return -1;
  1045be:	c7 44 24 08 06 00 00 	movl   $0x6,0x8(%esp)
  1045c5:	00 
  1045c6:	c7 44 24 04 bc 48 10 	movl   $0x1048bc,0x4(%esp)
  1045cd:	00 
  1045ce:	c7 04 24 0a 00 00 00 	movl   $0xa,(%esp)
  1045d5:	e8 60 58 00 00       	call   109e3a <syscall_create>
  1045da:	83 f8 ff             	cmp    $0xffffffff,%eax
  1045dd:	75 09                	jne    1045e8 <ipc_msg_init+0xb4>
  1045df:	c7 45 fc ff ff ff ff 	movl   $0xffffffff,-0x4(%ebp)
  1045e6:	eb 31                	jmp    104619 <ipc_msg_init+0xe5>
  if (syscall_create(SYSCALL_IPC_MSG_RECV,ipc_msg_recv,6)==-1) return -1;
  1045e8:	c7 44 24 08 06 00 00 	movl   $0x6,0x8(%esp)
  1045ef:	00 
  1045f0:	c7 44 24 04 30 4a 10 	movl   $0x104a30,0x4(%esp)
  1045f7:	00 
  1045f8:	c7 04 24 0b 00 00 00 	movl   $0xb,(%esp)
  1045ff:	e8 36 58 00 00       	call   109e3a <syscall_create>
  104604:	83 f8 ff             	cmp    $0xffffffff,%eax
  104607:	75 09                	jne    104612 <ipc_msg_init+0xde>
  104609:	c7 45 fc ff ff ff ff 	movl   $0xffffffff,-0x4(%ebp)
  104610:	eb 07                	jmp    104619 <ipc_msg_init+0xe5>
  return 0;
  104612:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
  104619:	8b 45 fc             	mov    -0x4(%ebp),%eax
}
  10461c:	c9                   	leave  
  10461d:	c3                   	ret    

0010461e <ipc_msg_get>:
/**
 * Gets MSQID by key (Syscall)
 *  @param key IPC Key
 *  @return MSQID
 */
id_t ipc_msg_get(key_t key) {
  10461e:	55                   	push   %ebp
  10461f:	89 e5                	mov    %esp,%ebp
  104621:	83 ec 28             	sub    $0x28,%esp
  ipc_msg_t *msg = ipc_msg_find(key,-1);
  104624:	c7 44 24 08 02 00 00 	movl   $0x2,0x8(%esp)
  10462b:	00 
  10462c:	c7 44 24 04 ff ff ff 	movl   $0xffffffff,0x4(%esp)
  104633:	ff 
  104634:	8b 45 08             	mov    0x8(%ebp),%eax
  104637:	89 04 24             	mov    %eax,(%esp)
  10463a:	e8 cc ce ff ff       	call   10150b <ipc_find>
  10463f:	89 45 fc             	mov    %eax,-0x4(%ebp)
  if (msg==NULL) return -1;
  104642:	83 7d fc 00          	cmpl   $0x0,-0x4(%ebp)
  104646:	75 09                	jne    104651 <ipc_msg_get+0x33>
  104648:	c7 45 ec ff ff ff ff 	movl   $0xffffffff,-0x14(%ebp)
  10464f:	eb 09                	jmp    10465a <ipc_msg_get+0x3c>
  return msg->ipc.id;
  104651:	8b 45 fc             	mov    -0x4(%ebp),%eax
  104654:	8b 40 04             	mov    0x4(%eax),%eax
  104657:	89 45 ec             	mov    %eax,-0x14(%ebp)
  10465a:	8b 45 ec             	mov    -0x14(%ebp),%eax
}
  10465d:	c9                   	leave  
  10465e:	c3                   	ret    

0010465f <ipc_msg_create>:
 *  @param key IPC key
 *  @param flags Flags
 *  @param time Current time
 *  @return MSQID
 */
id_t ipc_msg_create(key_t key,mode_t mode,time_t time) {
  10465f:	55                   	push   %ebp
  104660:	89 e5                	mov    %esp,%ebp
  104662:	83 ec 28             	sub    $0x28,%esp
  ipc_msg_t *msg = key!=IPC_PRIVATE?ipc_msg_find(key,-1):NULL;
  104665:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
  104669:	74 20                	je     10468b <ipc_msg_create+0x2c>
  10466b:	c7 44 24 08 02 00 00 	movl   $0x2,0x8(%esp)
  104672:	00 
  104673:	c7 44 24 04 ff ff ff 	movl   $0xffffffff,0x4(%esp)
  10467a:	ff 
  10467b:	8b 45 08             	mov    0x8(%ebp),%eax
  10467e:	89 04 24             	mov    %eax,(%esp)
  104681:	e8 85 ce ff ff       	call   10150b <ipc_find>
  104686:	89 45 e8             	mov    %eax,-0x18(%ebp)
  104689:	eb 07                	jmp    104692 <ipc_msg_create+0x33>
  10468b:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
  104692:	8b 45 e8             	mov    -0x18(%ebp),%eax
  104695:	89 45 f8             	mov    %eax,-0x8(%ebp)
  if (msg==NULL) {
  104698:	83 7d f8 00          	cmpl   $0x0,-0x8(%ebp)
  10469c:	0f 85 be 00 00 00    	jne    104760 <ipc_msg_create+0x101>
    ipc_msg_t *new = malloc(sizeof(ipc_msg_t));
  1046a2:	c7 04 24 38 00 00 00 	movl   $0x38,(%esp)
  1046a9:	e8 bb e8 ff ff       	call   102f69 <malloc>
  1046ae:	89 45 fc             	mov    %eax,-0x4(%ebp)
    if (new!=NULL) {
  1046b1:	83 7d fc 00          	cmpl   $0x0,-0x4(%ebp)
  1046b5:	0f 84 a5 00 00 00    	je     104760 <ipc_msg_create+0x101>
      memset(new,0,sizeof(ipc_msg_t));
  1046bb:	c7 44 24 08 38 00 00 	movl   $0x38,0x8(%esp)
  1046c2:	00 
  1046c3:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  1046ca:	00 
  1046cb:	8b 45 fc             	mov    -0x4(%ebp),%eax
  1046ce:	89 04 24             	mov    %eax,(%esp)
  1046d1:	e8 8b 76 00 00       	call   10bd61 <memset>
      new->ipc.type = IPC_MSG;
  1046d6:	8b 45 fc             	mov    -0x4(%ebp),%eax
  1046d9:	c7 00 02 00 00 00    	movl   $0x2,(%eax)
      new->ipc.key = key;
  1046df:	8b 55 fc             	mov    -0x4(%ebp),%edx
  1046e2:	8b 45 08             	mov    0x8(%ebp),%eax
  1046e5:	89 42 08             	mov    %eax,0x8(%edx)
      new->ipc.owner = proc_current;
  1046e8:	8b 15 a0 e1 10 00    	mov    0x10e1a0,%edx
  1046ee:	8b 45 fc             	mov    -0x4(%ebp),%eax
  1046f1:	89 50 0c             	mov    %edx,0xc(%eax)
      new->ipc.creator = proc_current;
  1046f4:	8b 15 a0 e1 10 00    	mov    0x10e1a0,%edx
  1046fa:	8b 45 fc             	mov    -0x4(%ebp),%eax
  1046fd:	89 50 10             	mov    %edx,0x10(%eax)
      new->ipc.id = ipc_lastid++;
  104700:	8b 15 98 e1 10 00    	mov    0x10e198,%edx
  104706:	8b 45 fc             	mov    -0x4(%ebp),%eax
  104709:	89 50 04             	mov    %edx,0x4(%eax)
  10470c:	8d 42 01             	lea    0x1(%edx),%eax
  10470f:	a3 98 e1 10 00       	mov    %eax,0x10e198
      new->ipc.mode = mode;
  104714:	8b 55 fc             	mov    -0x4(%ebp),%edx
  104717:	8b 45 0c             	mov    0xc(%ebp),%eax
  10471a:	89 42 14             	mov    %eax,0x14(%edx)
      new->msgs = llist_create();
  10471d:	e8 b2 61 00 00       	call   10a8d4 <llist_create>
  104722:	89 c2                	mov    %eax,%edx
  104724:	8b 45 fc             	mov    -0x4(%ebp),%eax
  104727:	89 50 18             	mov    %edx,0x18(%eax)
      new->waiting = llist_create();
  10472a:	e8 a5 61 00 00       	call   10a8d4 <llist_create>
  10472f:	89 c2                	mov    %eax,%edx
  104731:	8b 45 fc             	mov    -0x4(%ebp),%eax
  104734:	89 50 1c             	mov    %edx,0x1c(%eax)
      new->ctime = time;
  104737:	8b 55 fc             	mov    -0x4(%ebp),%edx
  10473a:	8b 45 10             	mov    0x10(%ebp),%eax
  10473d:	89 42 34             	mov    %eax,0x34(%edx)
      llist_push(ipc_objects,new);
  104740:	8b 15 90 e1 10 00    	mov    0x10e190,%edx
  104746:	8b 45 fc             	mov    -0x4(%ebp),%eax
  104749:	89 44 24 04          	mov    %eax,0x4(%esp)
  10474d:	89 14 24             	mov    %edx,(%esp)
  104750:	e8 fa 61 00 00       	call   10a94f <llist_push>
      return new->ipc.id;
  104755:	8b 45 fc             	mov    -0x4(%ebp),%eax
  104758:	8b 40 04             	mov    0x4(%eax),%eax
  10475b:	89 45 ec             	mov    %eax,-0x14(%ebp)
  10475e:	eb 07                	jmp    104767 <ipc_msg_create+0x108>
    }
  }
  return -EINVAL;
  104760:	c7 45 ec e4 ff ff ff 	movl   $0xffffffe4,-0x14(%ebp)
  104767:	8b 45 ec             	mov    -0x14(%ebp),%eax
}
  10476a:	c9                   	leave  
  10476b:	c3                   	ret    

0010476c <ipc_msg_destroy>:
/**
 * Destroys a message queue (Syscall)
 *  @param id ID of message queue
 *  @return Success?
 */
int ipc_msg_destroy(id_t id) {
  10476c:	55                   	push   %ebp
  10476d:	89 e5                	mov    %esp,%ebp
  10476f:	56                   	push   %esi
  104770:	53                   	push   %ebx
  104771:	83 ec 30             	sub    $0x30,%esp
  ipc_msg_t *msq = ipc_msg_find(-1,id);
  104774:	c7 44 24 08 02 00 00 	movl   $0x2,0x8(%esp)
  10477b:	00 
  10477c:	8b 45 08             	mov    0x8(%ebp),%eax
  10477f:	89 44 24 04          	mov    %eax,0x4(%esp)
  104783:	c7 04 24 ff ff ff ff 	movl   $0xffffffff,(%esp)
  10478a:	e8 7c cd ff ff       	call   10150b <ipc_find>
  10478f:	89 45 ec             	mov    %eax,-0x14(%ebp)
  if (msq!=NULL) {
  104792:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
  104796:	0f 84 0f 01 00 00    	je     1048ab <ipc_msg_destroy+0x13f>
    if (perm_check(proc_current->pid,proc_current->gid,msq->ipc.owner->uid,msq->ipc.owner->gid,msq->mode,PERM_W)) {
  10479c:	8b 45 ec             	mov    -0x14(%ebp),%eax
  10479f:	8b 70 20             	mov    0x20(%eax),%esi
  1047a2:	8b 45 ec             	mov    -0x14(%ebp),%eax
  1047a5:	8b 40 0c             	mov    0xc(%eax),%eax
  1047a8:	8b 50 10             	mov    0x10(%eax),%edx
  1047ab:	8b 45 ec             	mov    -0x14(%ebp),%eax
  1047ae:	8b 40 0c             	mov    0xc(%eax),%eax
  1047b1:	8b 48 04             	mov    0x4(%eax),%ecx
  1047b4:	a1 a0 e1 10 00       	mov    0x10e1a0,%eax
  1047b9:	8b 58 10             	mov    0x10(%eax),%ebx
  1047bc:	a1 a0 e1 10 00       	mov    0x10e1a0,%eax
  1047c1:	8b 00                	mov    (%eax),%eax
  1047c3:	c7 44 24 14 02 00 00 	movl   $0x2,0x14(%esp)
  1047ca:	00 
  1047cb:	89 74 24 10          	mov    %esi,0x10(%esp)
  1047cf:	89 54 24 0c          	mov    %edx,0xc(%esp)
  1047d3:	89 4c 24 08          	mov    %ecx,0x8(%esp)
  1047d7:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  1047db:	89 04 24             	mov    %eax,(%esp)
  1047de:	e8 51 66 00 00       	call   10ae34 <perm_check>
  1047e3:	85 c0                	test   %eax,%eax
  1047e5:	0f 84 b7 00 00 00    	je     1048a2 <ipc_msg_destroy+0x136>
  1047eb:	eb 3f                	jmp    10482c <ipc_msg_destroy+0xc0>
      ipc_msg_msg_t *msg;
      proc_t *waiter;
      while ((msg = llist_pop(msq->msgs))!=NULL) {
        if ((msg->flags&IPC_NOWAIT)!=msg->flags) proc_wake(msg->sender);
  1047ed:	8b 45 f0             	mov    -0x10(%ebp),%eax
  1047f0:	8b 40 10             	mov    0x10(%eax),%eax
  1047f3:	89 c2                	mov    %eax,%edx
  1047f5:	81 e2 03 02 00 00    	and    $0x203,%edx
  1047fb:	8b 45 f0             	mov    -0x10(%ebp),%eax
  1047fe:	8b 40 10             	mov    0x10(%eax),%eax
  104801:	39 c2                	cmp    %eax,%edx
  104803:	74 0e                	je     104813 <ipc_msg_destroy+0xa7>
  104805:	8b 45 f0             	mov    -0x10(%ebp),%eax
  104808:	8b 40 14             	mov    0x14(%eax),%eax
  10480b:	89 04 24             	mov    %eax,(%esp)
  10480e:	e8 7a 1e 00 00       	call   10668d <proc_wake>
        free(msg->data);
  104813:	8b 45 f0             	mov    -0x10(%ebp),%eax
  104816:	8b 40 04             	mov    0x4(%eax),%eax
  104819:	89 04 24             	mov    %eax,(%esp)
  10481c:	e8 7c e7 ff ff       	call   102f9d <free>
        free(msg);
  104821:	8b 45 f0             	mov    -0x10(%ebp),%eax
  104824:	89 04 24             	mov    %eax,(%esp)
  104827:	e8 71 e7 ff ff       	call   102f9d <free>
  ipc_msg_t *msq = ipc_msg_find(-1,id);
  if (msq!=NULL) {
    if (perm_check(proc_current->pid,proc_current->gid,msq->ipc.owner->uid,msq->ipc.owner->gid,msq->mode,PERM_W)) {
      ipc_msg_msg_t *msg;
      proc_t *waiter;
      while ((msg = llist_pop(msq->msgs))!=NULL) {
  10482c:	8b 45 ec             	mov    -0x14(%ebp),%eax
  10482f:	8b 40 18             	mov    0x18(%eax),%eax
  104832:	89 04 24             	mov    %eax,(%esp)
  104835:	e8 6e 61 00 00       	call   10a9a8 <llist_pop>
  10483a:	89 45 f0             	mov    %eax,-0x10(%ebp)
  10483d:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
  104841:	75 aa                	jne    1047ed <ipc_msg_destroy+0x81>
  104843:	eb 0b                	jmp    104850 <ipc_msg_destroy+0xe4>
        if ((msg->flags&IPC_NOWAIT)!=msg->flags) proc_wake(msg->sender);
        free(msg->data);
        free(msg);
      }
      while ((waiter = llist_pop(msq->waiting))!=NULL) proc_wake(waiter);
  104845:	8b 45 f4             	mov    -0xc(%ebp),%eax
  104848:	89 04 24             	mov    %eax,(%esp)
  10484b:	e8 3d 1e 00 00       	call   10668d <proc_wake>
  104850:	8b 45 ec             	mov    -0x14(%ebp),%eax
  104853:	8b 40 1c             	mov    0x1c(%eax),%eax
  104856:	89 04 24             	mov    %eax,(%esp)
  104859:	e8 4a 61 00 00       	call   10a9a8 <llist_pop>
  10485e:	89 45 f4             	mov    %eax,-0xc(%ebp)
  104861:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
  104865:	75 de                	jne    104845 <ipc_msg_destroy+0xd9>
      llist_remove(ipc_objects,llist_find(ipc_objects,msq));
  104867:	8b 15 90 e1 10 00    	mov    0x10e190,%edx
  10486d:	8b 45 ec             	mov    -0x14(%ebp),%eax
  104870:	89 44 24 04          	mov    %eax,0x4(%esp)
  104874:	89 14 24             	mov    %edx,(%esp)
  104877:	e8 a5 63 00 00       	call   10ac21 <llist_find>
  10487c:	8b 15 90 e1 10 00    	mov    0x10e190,%edx
  104882:	89 44 24 04          	mov    %eax,0x4(%esp)
  104886:	89 14 24             	mov    %edx,(%esp)
  104889:	e8 cb 62 00 00       	call   10ab59 <llist_remove>
      free(msq);
  10488e:	8b 45 ec             	mov    -0x14(%ebp),%eax
  104891:	89 04 24             	mov    %eax,(%esp)
  104894:	e8 04 e7 ff ff       	call   102f9d <free>
      return 0;
  104899:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
  1048a0:	eb 10                	jmp    1048b2 <ipc_msg_destroy+0x146>
    }
    else return -EACCES;
  1048a2:	c7 45 e4 fe ff ff ff 	movl   $0xfffffffe,-0x1c(%ebp)
  1048a9:	eb 07                	jmp    1048b2 <ipc_msg_destroy+0x146>
  }
  return -EINVAL;
  1048ab:	c7 45 e4 e4 ff ff ff 	movl   $0xffffffe4,-0x1c(%ebp)
  1048b2:	8b 45 e4             	mov    -0x1c(%ebp),%eax
}
  1048b5:	83 c4 30             	add    $0x30,%esp
  1048b8:	5b                   	pop    %ebx
  1048b9:	5e                   	pop    %esi
  1048ba:	5d                   	pop    %ebp
  1048bb:	c3                   	ret    

001048bc <ipc_msg_send>:
 *  @param type Message type
 *  @param flags Flags
 *  @param time Current time
 *  @return Success?
 */
int ipc_msg_send(id_t id,void *data,size_t msgsz,long type,int flags,time_t time) {
  1048bc:	55                   	push   %ebp
  1048bd:	89 e5                	mov    %esp,%ebp
  1048bf:	56                   	push   %esi
  1048c0:	53                   	push   %ebx
  1048c1:	83 ec 30             	sub    $0x30,%esp
  proc_t *waiter;
  ipc_msg_t *msq = ipc_msg_find(-1,id);
  1048c4:	c7 44 24 08 02 00 00 	movl   $0x2,0x8(%esp)
  1048cb:	00 
  1048cc:	8b 45 08             	mov    0x8(%ebp),%eax
  1048cf:	89 44 24 04          	mov    %eax,0x4(%esp)
  1048d3:	c7 04 24 ff ff ff ff 	movl   $0xffffffff,(%esp)
  1048da:	e8 2c cc ff ff       	call   10150b <ipc_find>
  1048df:	89 45 f0             	mov    %eax,-0x10(%ebp)
  if (msq!=NULL) {
  1048e2:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
  1048e6:	0f 84 33 01 00 00    	je     104a1f <ipc_msg_send+0x163>
    if (perm_check(proc_current->pid,proc_current->gid,msq->ipc.owner->uid,msq->ipc.owner->gid,msq->mode,PERM_W)) {
  1048ec:	8b 45 f0             	mov    -0x10(%ebp),%eax
  1048ef:	8b 70 20             	mov    0x20(%eax),%esi
  1048f2:	8b 45 f0             	mov    -0x10(%ebp),%eax
  1048f5:	8b 40 0c             	mov    0xc(%eax),%eax
  1048f8:	8b 50 10             	mov    0x10(%eax),%edx
  1048fb:	8b 45 f0             	mov    -0x10(%ebp),%eax
  1048fe:	8b 40 0c             	mov    0xc(%eax),%eax
  104901:	8b 48 04             	mov    0x4(%eax),%ecx
  104904:	a1 a0 e1 10 00       	mov    0x10e1a0,%eax
  104909:	8b 58 10             	mov    0x10(%eax),%ebx
  10490c:	a1 a0 e1 10 00       	mov    0x10e1a0,%eax
  104911:	8b 00                	mov    (%eax),%eax
  104913:	c7 44 24 14 02 00 00 	movl   $0x2,0x14(%esp)
  10491a:	00 
  10491b:	89 74 24 10          	mov    %esi,0x10(%esp)
  10491f:	89 54 24 0c          	mov    %edx,0xc(%esp)
  104923:	89 4c 24 08          	mov    %ecx,0x8(%esp)
  104927:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  10492b:	89 04 24             	mov    %eax,(%esp)
  10492e:	e8 01 65 00 00       	call   10ae34 <perm_check>
  104933:	85 c0                	test   %eax,%eax
  104935:	0f 84 db 00 00 00    	je     104a16 <ipc_msg_send+0x15a>
      ipc_msg_msg_t *new = malloc(sizeof(ipc_msg_msg_t));
  10493b:	c7 04 24 18 00 00 00 	movl   $0x18,(%esp)
  104942:	e8 22 e6 ff ff       	call   102f69 <malloc>
  104947:	89 45 f4             	mov    %eax,-0xc(%ebp)
      new->msg = msq;
  10494a:	8b 55 f4             	mov    -0xc(%ebp),%edx
  10494d:	8b 45 f0             	mov    -0x10(%ebp),%eax
  104950:	89 02                	mov    %eax,(%edx)
      new->data = memcpy(malloc(msgsz),data,msgsz);
  104952:	8b 45 10             	mov    0x10(%ebp),%eax
  104955:	89 04 24             	mov    %eax,(%esp)
  104958:	e8 0c e6 ff ff       	call   102f69 <malloc>
  10495d:	89 c2                	mov    %eax,%edx
  10495f:	8b 45 10             	mov    0x10(%ebp),%eax
  104962:	89 44 24 08          	mov    %eax,0x8(%esp)
  104966:	8b 45 0c             	mov    0xc(%ebp),%eax
  104969:	89 44 24 04          	mov    %eax,0x4(%esp)
  10496d:	89 14 24             	mov    %edx,(%esp)
  104970:	e8 0f 72 00 00       	call   10bb84 <memcpy>
  104975:	89 c2                	mov    %eax,%edx
  104977:	8b 45 f4             	mov    -0xc(%ebp),%eax
  10497a:	89 50 04             	mov    %edx,0x4(%eax)
      new->type = type;
  10497d:	8b 55 f4             	mov    -0xc(%ebp),%edx
  104980:	8b 45 14             	mov    0x14(%ebp),%eax
  104983:	89 42 0c             	mov    %eax,0xc(%edx)
      new->size = msgsz;
  104986:	8b 55 f4             	mov    -0xc(%ebp),%edx
  104989:	8b 45 10             	mov    0x10(%ebp),%eax
  10498c:	89 42 08             	mov    %eax,0x8(%edx)
      new->flags = flags;
  10498f:	8b 55 f4             	mov    -0xc(%ebp),%edx
  104992:	8b 45 18             	mov    0x18(%ebp),%eax
  104995:	89 42 10             	mov    %eax,0x10(%edx)
      new->sender = proc_current;
  104998:	8b 15 a0 e1 10 00    	mov    0x10e1a0,%edx
  10499e:	8b 45 f4             	mov    -0xc(%ebp),%eax
  1049a1:	89 50 14             	mov    %edx,0x14(%eax)
      msq->lspid = proc_current->pid;
  1049a4:	a1 a0 e1 10 00       	mov    0x10e1a0,%eax
  1049a9:	8b 10                	mov    (%eax),%edx
  1049ab:	8b 45 f0             	mov    -0x10(%ebp),%eax
  1049ae:	89 50 28             	mov    %edx,0x28(%eax)
      msq->stime = time;
  1049b1:	8b 55 f0             	mov    -0x10(%ebp),%edx
  1049b4:	8b 45 1c             	mov    0x1c(%ebp),%eax
  1049b7:	89 42 2c             	mov    %eax,0x2c(%edx)
      llist_push(msq->msgs,new);
  1049ba:	8b 45 f0             	mov    -0x10(%ebp),%eax
  1049bd:	8b 50 18             	mov    0x18(%eax),%edx
  1049c0:	8b 45 f4             	mov    -0xc(%ebp),%eax
  1049c3:	89 44 24 04          	mov    %eax,0x4(%esp)
  1049c7:	89 14 24             	mov    %edx,(%esp)
  1049ca:	e8 80 5f 00 00       	call   10a94f <llist_push>
  1049cf:	eb 0b                	jmp    1049dc <ipc_msg_send+0x120>
      while ((waiter = llist_pop(msq->waiting))!=NULL) proc_wake(waiter);
  1049d1:	8b 45 ec             	mov    -0x14(%ebp),%eax
  1049d4:	89 04 24             	mov    %eax,(%esp)
  1049d7:	e8 b1 1c 00 00       	call   10668d <proc_wake>
  1049dc:	8b 45 f0             	mov    -0x10(%ebp),%eax
  1049df:	8b 40 1c             	mov    0x1c(%eax),%eax
  1049e2:	89 04 24             	mov    %eax,(%esp)
  1049e5:	e8 be 5f 00 00       	call   10a9a8 <llist_pop>
  1049ea:	89 45 ec             	mov    %eax,-0x14(%ebp)
  1049ed:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
  1049f1:	75 de                	jne    1049d1 <ipc_msg_send+0x115>
      if ((flags&IPC_NOWAIT)!=flags) proc_sleep(proc_current);
  1049f3:	8b 45 18             	mov    0x18(%ebp),%eax
  1049f6:	25 03 02 00 00       	and    $0x203,%eax
  1049fb:	3b 45 18             	cmp    0x18(%ebp),%eax
  1049fe:	74 0d                	je     104a0d <ipc_msg_send+0x151>
  104a00:	a1 a0 e1 10 00       	mov    0x10e1a0,%eax
  104a05:	89 04 24             	mov    %eax,(%esp)
  104a08:	e8 14 1c 00 00       	call   106621 <proc_sleep>
      return 0;
  104a0d:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
  104a14:	eb 10                	jmp    104a26 <ipc_msg_send+0x16a>
    }
    else return -EACCES;
  104a16:	c7 45 e4 fe ff ff ff 	movl   $0xfffffffe,-0x1c(%ebp)
  104a1d:	eb 07                	jmp    104a26 <ipc_msg_send+0x16a>
  }
  return -EINVAL;
  104a1f:	c7 45 e4 e4 ff ff ff 	movl   $0xffffffe4,-0x1c(%ebp)
  104a26:	8b 45 e4             	mov    -0x1c(%ebp),%eax
}
  104a29:	83 c4 30             	add    $0x30,%esp
  104a2c:	5b                   	pop    %ebx
  104a2d:	5e                   	pop    %esi
  104a2e:	5d                   	pop    %ebp
  104a2f:	c3                   	ret    

00104a30 <ipc_msg_recv>:
 *  @param flags Flags
 *  @param time Current time
 *  @return Number of bytes received
 *  @todo Get first message with type, not first absolute message
 */
ssize_t ipc_msg_recv(id_t id,void *data,size_t msgsz,long type,int flags,time_t time) {
  104a30:	55                   	push   %ebp
  104a31:	89 e5                	mov    %esp,%ebp
  104a33:	56                   	push   %esi
  104a34:	53                   	push   %ebx
  104a35:	83 ec 40             	sub    $0x40,%esp
  ipc_msg_t *msq = ipc_msg_find(-1,id);
  104a38:	c7 44 24 08 02 00 00 	movl   $0x2,0x8(%esp)
  104a3f:	00 
  104a40:	8b 45 08             	mov    0x8(%ebp),%eax
  104a43:	89 44 24 04          	mov    %eax,0x4(%esp)
  104a47:	c7 04 24 ff ff ff ff 	movl   $0xffffffff,(%esp)
  104a4e:	e8 b8 ca ff ff       	call   10150b <ipc_find>
  104a53:	89 45 e8             	mov    %eax,-0x18(%ebp)
  if (msq!=NULL) {
  104a56:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
  104a5a:	0f 84 8f 01 00 00    	je     104bef <ipc_msg_recv+0x1bf>
    if (perm_check(proc_current->pid,proc_current->gid,msq->ipc.owner->uid,msq->ipc.owner->gid,msq->mode,PERM_R)) {
  104a60:	8b 45 e8             	mov    -0x18(%ebp),%eax
  104a63:	8b 70 20             	mov    0x20(%eax),%esi
  104a66:	8b 45 e8             	mov    -0x18(%ebp),%eax
  104a69:	8b 40 0c             	mov    0xc(%eax),%eax
  104a6c:	8b 50 10             	mov    0x10(%eax),%edx
  104a6f:	8b 45 e8             	mov    -0x18(%ebp),%eax
  104a72:	8b 40 0c             	mov    0xc(%eax),%eax
  104a75:	8b 48 04             	mov    0x4(%eax),%ecx
  104a78:	a1 a0 e1 10 00       	mov    0x10e1a0,%eax
  104a7d:	8b 58 10             	mov    0x10(%eax),%ebx
  104a80:	a1 a0 e1 10 00       	mov    0x10e1a0,%eax
  104a85:	8b 00                	mov    (%eax),%eax
  104a87:	c7 44 24 14 01 00 00 	movl   $0x1,0x14(%esp)
  104a8e:	00 
  104a8f:	89 74 24 10          	mov    %esi,0x10(%esp)
  104a93:	89 54 24 0c          	mov    %edx,0xc(%esp)
  104a97:	89 4c 24 08          	mov    %ecx,0x8(%esp)
  104a9b:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  104a9f:	89 04 24             	mov    %eax,(%esp)
  104aa2:	e8 8d 63 00 00       	call   10ae34 <perm_check>
  104aa7:	85 c0                	test   %eax,%eax
  104aa9:	0f 84 37 01 00 00    	je     104be6 <ipc_msg_recv+0x1b6>
      ipc_msg_msg_t *msg;
      size_t i;
      for (i=0;(msg = llist_get(msq->msgs,i));i++) {
  104aaf:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
  104ab6:	e9 c6 00 00 00       	jmp    104b81 <ipc_msg_recv+0x151>
        if (msg->type==type || type==0 || (type<0 && msg->type<=-type)) {
  104abb:	8b 45 ec             	mov    -0x14(%ebp),%eax
  104abe:	8b 40 0c             	mov    0xc(%eax),%eax
  104ac1:	3b 45 14             	cmp    0x14(%ebp),%eax
  104ac4:	74 23                	je     104ae9 <ipc_msg_recv+0xb9>
  104ac6:	83 7d 14 00          	cmpl   $0x0,0x14(%ebp)
  104aca:	74 1d                	je     104ae9 <ipc_msg_recv+0xb9>
  104acc:	83 7d 14 00          	cmpl   $0x0,0x14(%ebp)
  104ad0:	0f 89 a7 00 00 00    	jns    104b7d <ipc_msg_recv+0x14d>
  104ad6:	8b 45 ec             	mov    -0x14(%ebp),%eax
  104ad9:	8b 50 0c             	mov    0xc(%eax),%edx
  104adc:	8b 45 14             	mov    0x14(%ebp),%eax
  104adf:	f7 d8                	neg    %eax
  104ae1:	39 c2                	cmp    %eax,%edx
  104ae3:	0f 8f 94 00 00 00    	jg     104b7d <ipc_msg_recv+0x14d>
          size_t count = msgsz>msg->size?msg->size:msgsz;
  104ae9:	8b 45 ec             	mov    -0x14(%ebp),%eax
  104aec:	8b 40 08             	mov    0x8(%eax),%eax
  104aef:	8b 55 10             	mov    0x10(%ebp),%edx
  104af2:	89 55 dc             	mov    %edx,-0x24(%ebp)
  104af5:	89 45 e0             	mov    %eax,-0x20(%ebp)
  104af8:	8b 45 dc             	mov    -0x24(%ebp),%eax
  104afb:	39 45 e0             	cmp    %eax,-0x20(%ebp)
  104afe:	76 06                	jbe    104b06 <ipc_msg_recv+0xd6>
  104b00:	8b 55 dc             	mov    -0x24(%ebp),%edx
  104b03:	89 55 e0             	mov    %edx,-0x20(%ebp)
  104b06:	8b 45 e0             	mov    -0x20(%ebp),%eax
  104b09:	89 45 f4             	mov    %eax,-0xc(%ebp)
          memcpy(data,msg->data,count);
  104b0c:	8b 45 ec             	mov    -0x14(%ebp),%eax
  104b0f:	8b 50 04             	mov    0x4(%eax),%edx
  104b12:	8b 45 f4             	mov    -0xc(%ebp),%eax
  104b15:	89 44 24 08          	mov    %eax,0x8(%esp)
  104b19:	89 54 24 04          	mov    %edx,0x4(%esp)
  104b1d:	8b 45 0c             	mov    0xc(%ebp),%eax
  104b20:	89 04 24             	mov    %eax,(%esp)
  104b23:	e8 5c 70 00 00       	call   10bb84 <memcpy>
          if ((msg->flags&IPC_NOWAIT)==flags) proc_wake(msg->sender);
  104b28:	8b 45 ec             	mov    -0x14(%ebp),%eax
  104b2b:	8b 40 10             	mov    0x10(%eax),%eax
  104b2e:	25 03 02 00 00       	and    $0x203,%eax
  104b33:	3b 45 18             	cmp    0x18(%ebp),%eax
  104b36:	75 0e                	jne    104b46 <ipc_msg_recv+0x116>
  104b38:	8b 45 ec             	mov    -0x14(%ebp),%eax
  104b3b:	8b 40 14             	mov    0x14(%eax),%eax
  104b3e:	89 04 24             	mov    %eax,(%esp)
  104b41:	e8 47 1b 00 00       	call   10668d <proc_wake>
          msq->lrpid = proc_current->pid;
  104b46:	a1 a0 e1 10 00       	mov    0x10e1a0,%eax
  104b4b:	8b 10                	mov    (%eax),%edx
  104b4d:	8b 45 e8             	mov    -0x18(%ebp),%eax
  104b50:	89 50 24             	mov    %edx,0x24(%eax)
          msq->rtime = time;
  104b53:	8b 55 e8             	mov    -0x18(%ebp),%edx
  104b56:	8b 45 1c             	mov    0x1c(%ebp),%eax
  104b59:	89 42 30             	mov    %eax,0x30(%edx)
          free(msg->data);
  104b5c:	8b 45 ec             	mov    -0x14(%ebp),%eax
  104b5f:	8b 40 04             	mov    0x4(%eax),%eax
  104b62:	89 04 24             	mov    %eax,(%esp)
  104b65:	e8 33 e4 ff ff       	call   102f9d <free>
          free(msg);
  104b6a:	8b 45 ec             	mov    -0x14(%ebp),%eax
  104b6d:	89 04 24             	mov    %eax,(%esp)
  104b70:	e8 28 e4 ff ff       	call   102f9d <free>
          return count;
  104b75:	8b 55 f4             	mov    -0xc(%ebp),%edx
  104b78:	89 55 e4             	mov    %edx,-0x1c(%ebp)
  104b7b:	eb 79                	jmp    104bf6 <ipc_msg_recv+0x1c6>
  ipc_msg_t *msq = ipc_msg_find(-1,id);
  if (msq!=NULL) {
    if (perm_check(proc_current->pid,proc_current->gid,msq->ipc.owner->uid,msq->ipc.owner->gid,msq->mode,PERM_R)) {
      ipc_msg_msg_t *msg;
      size_t i;
      for (i=0;(msg = llist_get(msq->msgs,i));i++) {
  104b7d:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
  104b81:	8b 45 e8             	mov    -0x18(%ebp),%eax
  104b84:	8b 50 18             	mov    0x18(%eax),%edx
  104b87:	8b 45 f0             	mov    -0x10(%ebp),%eax
  104b8a:	89 44 24 04          	mov    %eax,0x4(%esp)
  104b8e:	89 14 24             	mov    %edx,(%esp)
  104b91:	e8 f1 5e 00 00       	call   10aa87 <llist_get>
  104b96:	89 45 ec             	mov    %eax,-0x14(%ebp)
  104b99:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
  104b9d:	0f 85 18 ff ff ff    	jne    104abb <ipc_msg_recv+0x8b>
          free(msg->data);
          free(msg);
          return count;
        }
      }
      if (!(flags&IPC_NOWAIT)) {
  104ba3:	8b 45 18             	mov    0x18(%ebp),%eax
  104ba6:	25 03 02 00 00       	and    $0x203,%eax
  104bab:	85 c0                	test   %eax,%eax
  104bad:	75 2e                	jne    104bdd <ipc_msg_recv+0x1ad>
        llist_push(msq->waiting,proc_current);
  104baf:	8b 15 a0 e1 10 00    	mov    0x10e1a0,%edx
  104bb5:	8b 45 e8             	mov    -0x18(%ebp),%eax
  104bb8:	8b 40 1c             	mov    0x1c(%eax),%eax
  104bbb:	89 54 24 04          	mov    %edx,0x4(%esp)
  104bbf:	89 04 24             	mov    %eax,(%esp)
  104bc2:	e8 88 5d 00 00       	call   10a94f <llist_push>
        proc_sleep(proc_current);
  104bc7:	a1 a0 e1 10 00       	mov    0x10e1a0,%eax
  104bcc:	89 04 24             	mov    %eax,(%esp)
  104bcf:	e8 4d 1a 00 00       	call   106621 <proc_sleep>
        return 0; // try again after sleeping
  104bd4:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
  104bdb:	eb 19                	jmp    104bf6 <ipc_msg_recv+0x1c6>
      }
      return -ENOMSG;
  104bdd:	c7 45 e4 ce ff ff ff 	movl   $0xffffffce,-0x1c(%ebp)
  104be4:	eb 10                	jmp    104bf6 <ipc_msg_recv+0x1c6>
    }
    else return -EACCES;
  104be6:	c7 45 e4 fe ff ff ff 	movl   $0xfffffffe,-0x1c(%ebp)
  104bed:	eb 07                	jmp    104bf6 <ipc_msg_recv+0x1c6>
  }
  return -EINVAL;
  104bef:	c7 45 e4 e4 ff ff ff 	movl   $0xffffffe4,-0x1c(%ebp)
  104bf6:	8b 45 e4             	mov    -0x1c(%ebp),%eax
}
  104bf9:	83 c4 40             	add    $0x40,%esp
  104bfc:	5b                   	pop    %ebx
  104bfd:	5e                   	pop    %esi
  104bfe:	5d                   	pop    %ebp
  104bff:	c3                   	ret    

00104c00 <msg_stat>:
 *  @param stime Reference for last send time
 *  @param rtime Reference for last receive time
 *  @param ctime Reference for last change time
 *  @return Success?
 */
int msg_stat(id_t id,uid_t *uid,gid_t *gid,uid_t *cuid,gid_t *cgid,mode_t *mode,size_t *num,pid_t *lspid,pid_t *lrpid,time_t *stime,time_t *rtime,time_t *ctime) {
  104c00:	55                   	push   %ebp
  104c01:	89 e5                	mov    %esp,%ebp
  104c03:	83 ec 28             	sub    $0x28,%esp
  ipc_msg_t *msq = ipc_msg_find(-1,id);
  104c06:	c7 44 24 08 02 00 00 	movl   $0x2,0x8(%esp)
  104c0d:	00 
  104c0e:	8b 45 08             	mov    0x8(%ebp),%eax
  104c11:	89 44 24 04          	mov    %eax,0x4(%esp)
  104c15:	c7 04 24 ff ff ff ff 	movl   $0xffffffff,(%esp)
  104c1c:	e8 ea c8 ff ff       	call   10150b <ipc_find>
  104c21:	89 45 fc             	mov    %eax,-0x4(%ebp)
  if (msq!=NULL) {
  104c24:	83 7d fc 00          	cmpl   $0x0,-0x4(%ebp)
  104c28:	0f 84 98 00 00 00    	je     104cc6 <msg_stat+0xc6>
    *uid = msq->ipc.owner->uid;
  104c2e:	8b 45 fc             	mov    -0x4(%ebp),%eax
  104c31:	8b 40 0c             	mov    0xc(%eax),%eax
  104c34:	8b 50 04             	mov    0x4(%eax),%edx
  104c37:	8b 45 0c             	mov    0xc(%ebp),%eax
  104c3a:	89 10                	mov    %edx,(%eax)
    *gid = msq->ipc.owner->gid;
  104c3c:	8b 45 fc             	mov    -0x4(%ebp),%eax
  104c3f:	8b 40 0c             	mov    0xc(%eax),%eax
  104c42:	8b 50 10             	mov    0x10(%eax),%edx
  104c45:	8b 45 10             	mov    0x10(%ebp),%eax
  104c48:	89 10                	mov    %edx,(%eax)
    *cuid = msq->ipc.creator->uid;
  104c4a:	8b 45 fc             	mov    -0x4(%ebp),%eax
  104c4d:	8b 40 10             	mov    0x10(%eax),%eax
  104c50:	8b 50 04             	mov    0x4(%eax),%edx
  104c53:	8b 45 14             	mov    0x14(%ebp),%eax
  104c56:	89 10                	mov    %edx,(%eax)
    *cgid = msq->ipc.creator->gid;
  104c58:	8b 45 fc             	mov    -0x4(%ebp),%eax
  104c5b:	8b 40 10             	mov    0x10(%eax),%eax
  104c5e:	8b 50 10             	mov    0x10(%eax),%edx
  104c61:	8b 45 18             	mov    0x18(%ebp),%eax
  104c64:	89 10                	mov    %edx,(%eax)
    *mode = msq->mode;
  104c66:	8b 45 fc             	mov    -0x4(%ebp),%eax
  104c69:	8b 50 20             	mov    0x20(%eax),%edx
  104c6c:	8b 45 1c             	mov    0x1c(%ebp),%eax
  104c6f:	89 10                	mov    %edx,(%eax)
    *num = llist_size(msq->msgs);
  104c71:	8b 45 fc             	mov    -0x4(%ebp),%eax
  104c74:	8b 40 18             	mov    0x18(%eax),%eax
  104c77:	89 04 24             	mov    %eax,(%esp)
  104c7a:	e8 a4 5c 00 00       	call   10a923 <llist_size>
  104c7f:	89 c2                	mov    %eax,%edx
  104c81:	8b 45 20             	mov    0x20(%ebp),%eax
  104c84:	89 10                	mov    %edx,(%eax)
    *lspid = msq->lspid;
  104c86:	8b 45 fc             	mov    -0x4(%ebp),%eax
  104c89:	8b 50 28             	mov    0x28(%eax),%edx
  104c8c:	8b 45 24             	mov    0x24(%ebp),%eax
  104c8f:	89 10                	mov    %edx,(%eax)
    *lrpid = msq->lrpid;
  104c91:	8b 45 fc             	mov    -0x4(%ebp),%eax
  104c94:	8b 50 24             	mov    0x24(%eax),%edx
  104c97:	8b 45 28             	mov    0x28(%ebp),%eax
  104c9a:	89 10                	mov    %edx,(%eax)
    *stime = msq->stime;
  104c9c:	8b 45 fc             	mov    -0x4(%ebp),%eax
  104c9f:	8b 50 2c             	mov    0x2c(%eax),%edx
  104ca2:	8b 45 2c             	mov    0x2c(%ebp),%eax
  104ca5:	89 10                	mov    %edx,(%eax)
    *rtime = msq->rtime;
  104ca7:	8b 45 fc             	mov    -0x4(%ebp),%eax
  104caa:	8b 50 30             	mov    0x30(%eax),%edx
  104cad:	8b 45 30             	mov    0x30(%ebp),%eax
  104cb0:	89 10                	mov    %edx,(%eax)
    *ctime = msq->ctime;
  104cb2:	8b 45 fc             	mov    -0x4(%ebp),%eax
  104cb5:	8b 50 34             	mov    0x34(%eax),%edx
  104cb8:	8b 45 34             	mov    0x34(%ebp),%eax
  104cbb:	89 10                	mov    %edx,(%eax)
    return 0;
  104cbd:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
  104cc4:	eb 07                	jmp    104ccd <msg_stat+0xcd>
  }
  else return -EINVAL;
  104cc6:	c7 45 ec e4 ff ff ff 	movl   $0xffffffe4,-0x14(%ebp)
  104ccd:	8b 45 ec             	mov    -0x14(%ebp),%eax
}
  104cd0:	c9                   	leave  
  104cd1:	c3                   	ret    

00104cd2 <msg_set>:
 *  @param gid Owner's GID
 *  @param mode Permissions
 *  @param time Current time
 *  @return Success?
 */
int msg_set(id_t id,uid_t uid,gid_t gid,mode_t mode,time_t time) {
  104cd2:	55                   	push   %ebp
  104cd3:	89 e5                	mov    %esp,%ebp
  104cd5:	56                   	push   %esi
  104cd6:	53                   	push   %ebx
  104cd7:	83 ec 30             	sub    $0x30,%esp
  ipc_msg_t *msq = ipc_msg_find(-1,id);
  104cda:	c7 44 24 08 02 00 00 	movl   $0x2,0x8(%esp)
  104ce1:	00 
  104ce2:	8b 45 08             	mov    0x8(%ebp),%eax
  104ce5:	89 44 24 04          	mov    %eax,0x4(%esp)
  104ce9:	c7 04 24 ff ff ff ff 	movl   $0xffffffff,(%esp)
  104cf0:	e8 16 c8 ff ff       	call   10150b <ipc_find>
  104cf5:	89 45 f4             	mov    %eax,-0xc(%ebp)
  if (msq!=NULL) {
  104cf8:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
  104cfc:	74 75                	je     104d73 <msg_set+0xa1>
    if (perm_check(proc_current->pid,proc_current->gid,msq->ipc.owner->uid,msq->ipc.owner->gid,msq->mode,PERM_W) || proc_current==msq->ipc.creator) {
  104cfe:	8b 45 f4             	mov    -0xc(%ebp),%eax
  104d01:	8b 70 20             	mov    0x20(%eax),%esi
  104d04:	8b 45 f4             	mov    -0xc(%ebp),%eax
  104d07:	8b 40 0c             	mov    0xc(%eax),%eax
  104d0a:	8b 50 10             	mov    0x10(%eax),%edx
  104d0d:	8b 45 f4             	mov    -0xc(%ebp),%eax
  104d10:	8b 40 0c             	mov    0xc(%eax),%eax
  104d13:	8b 48 04             	mov    0x4(%eax),%ecx
  104d16:	a1 a0 e1 10 00       	mov    0x10e1a0,%eax
  104d1b:	8b 58 10             	mov    0x10(%eax),%ebx
  104d1e:	a1 a0 e1 10 00       	mov    0x10e1a0,%eax
  104d23:	8b 00                	mov    (%eax),%eax
  104d25:	c7 44 24 14 02 00 00 	movl   $0x2,0x14(%esp)
  104d2c:	00 
  104d2d:	89 74 24 10          	mov    %esi,0x10(%esp)
  104d31:	89 54 24 0c          	mov    %edx,0xc(%esp)
  104d35:	89 4c 24 08          	mov    %ecx,0x8(%esp)
  104d39:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  104d3d:	89 04 24             	mov    %eax,(%esp)
  104d40:	e8 ef 60 00 00       	call   10ae34 <perm_check>
  104d45:	85 c0                	test   %eax,%eax
  104d47:	75 0f                	jne    104d58 <msg_set+0x86>
  104d49:	8b 45 f4             	mov    -0xc(%ebp),%eax
  104d4c:	8b 50 10             	mov    0x10(%eax),%edx
  104d4f:	a1 a0 e1 10 00       	mov    0x10e1a0,%eax
  104d54:	39 c2                	cmp    %eax,%edx
  104d56:	75 12                	jne    104d6a <msg_set+0x98>
      msq->mode = mode;
  104d58:	8b 55 f4             	mov    -0xc(%ebp),%edx
  104d5b:	8b 45 14             	mov    0x14(%ebp),%eax
  104d5e:	89 42 20             	mov    %eax,0x20(%edx)
      msq->ctime = time;
  104d61:	8b 55 f4             	mov    -0xc(%ebp),%edx
  104d64:	8b 45 18             	mov    0x18(%ebp),%eax
  104d67:	89 42 34             	mov    %eax,0x34(%edx)
    }
    return 0;
  104d6a:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
  104d71:	eb 07                	jmp    104d7a <msg_set+0xa8>
  }
  return -EINVAL;
  104d73:	c7 45 e4 e4 ff ff ff 	movl   $0xffffffe4,-0x1c(%ebp)
  104d7a:	8b 45 e4             	mov    -0x1c(%ebp),%eax
}
  104d7d:	83 c4 30             	add    $0x30,%esp
  104d80:	5b                   	pop    %ebx
  104d81:	5e                   	pop    %esi
  104d82:	5d                   	pop    %ebp
  104d83:	c3                   	ret    

00104d84 <multiboot_init>:
/**
 * Initializes Multiboot
 *  @param mbi Multiboot sturcture
 *  @return 0=Success; -1=Failure
 */
int multiboot_init(multiboot_info_t *mbi) {
  104d84:	55                   	push   %ebp
  104d85:	89 e5                	mov    %esp,%ebp
  multiboot_info = mbi;
  104d87:	8b 45 08             	mov    0x8(%ebp),%eax
  104d8a:	a3 54 e9 10 00       	mov    %eax,0x10e954
  return 0;
  104d8f:	b8 00 00 00 00       	mov    $0x0,%eax
}
  104d94:	5d                   	pop    %ebp
  104d95:	c3                   	ret    

00104d96 <multiboot_get_memlower>:

/**
 * Gets amount of lower memory
 *  @return Amount of lower memory
 */
size_t multiboot_get_memlower() {
  104d96:	55                   	push   %ebp
  104d97:	89 e5                	mov    %esp,%ebp
  return ((size_t)multiboot_info->mem_lower)*KBYTES;
  104d99:	a1 54 e9 10 00       	mov    0x10e954,%eax
  104d9e:	8b 40 04             	mov    0x4(%eax),%eax
  104da1:	c1 e0 0a             	shl    $0xa,%eax
}
  104da4:	5d                   	pop    %ebp
  104da5:	c3                   	ret    

00104da6 <multiboot_get_memupper>:

/**
 * Gets amount of upper memory
 *  @return Amount of upper memory
 */
size_t multiboot_get_memupper() {
  104da6:	55                   	push   %ebp
  104da7:	89 e5                	mov    %esp,%ebp
  return ((size_t)multiboot_info->mem_upper)*KBYTES;
  104da9:	a1 54 e9 10 00       	mov    0x10e954,%eax
  104dae:	8b 40 08             	mov    0x8(%eax),%eax
  104db1:	c1 e0 0a             	shl    $0xa,%eax
}
  104db4:	5d                   	pop    %ebp
  104db5:	c3                   	ret    

00104db6 <multiboot_get_bootdev>:

/**
 * Gets bootdevice
 *  @return Bootdevice
 */
int multiboot_get_bootdev() {
  104db6:	55                   	push   %ebp
  104db7:	89 e5                	mov    %esp,%ebp
  return *((int*)(multiboot_info->boot_device));
  104db9:	a1 54 e9 10 00       	mov    0x10e954,%eax
  104dbe:	83 c0 0c             	add    $0xc,%eax
  104dc1:	8b 00                	mov    (%eax),%eax
}
  104dc3:	5d                   	pop    %ebp
  104dc4:	c3                   	ret    

00104dc5 <multiboot_get_cmdline>:

/**
 * Gets command line
 *  @return Command line
 */
char* multiboot_get_cmdline() {
  104dc5:	55                   	push   %ebp
  104dc6:	89 e5                	mov    %esp,%ebp
  return (char*)(multiboot_info->cmdline);
  104dc8:	a1 54 e9 10 00       	mov    0x10e954,%eax
  104dcd:	8b 40 10             	mov    0x10(%eax),%eax
}
  104dd0:	5d                   	pop    %ebp
  104dd1:	c3                   	ret    

00104dd2 <multiboot_get_mod>:
 * Gets list of modules
 *  @param i Number of Module
 *  @param name Reference for name pointer
 *  @param size Reference for module size
 */
void *multiboot_get_mod(size_t i,char **name,size_t *size) {
  104dd2:	55                   	push   %ebp
  104dd3:	89 e5                	mov    %esp,%ebp
  104dd5:	83 ec 14             	sub    $0x14,%esp
  if (i>=multiboot_info->mods_count) return NULL;
  104dd8:	a1 54 e9 10 00       	mov    0x10e954,%eax
  104ddd:	8b 40 14             	mov    0x14(%eax),%eax
  104de0:	3b 45 08             	cmp    0x8(%ebp),%eax
  104de3:	77 09                	ja     104dee <multiboot_get_mod+0x1c>
  104de5:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
  104dec:	eb 49                	jmp    104e37 <multiboot_get_mod+0x65>
  multiboot_mod_t *mod = ((multiboot_mod_t*)(multiboot_info->mods_addr))+i;
  104dee:	8b 45 08             	mov    0x8(%ebp),%eax
  104df1:	89 c2                	mov    %eax,%edx
  104df3:	c1 e2 04             	shl    $0x4,%edx
  104df6:	a1 54 e9 10 00       	mov    0x10e954,%eax
  104dfb:	8b 40 18             	mov    0x18(%eax),%eax
  104dfe:	8d 04 02             	lea    (%edx,%eax,1),%eax
  104e01:	89 45 fc             	mov    %eax,-0x4(%ebp)
  if (name!=NULL) *name = (char*)(mod->mod_name);
  104e04:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
  104e08:	74 0d                	je     104e17 <multiboot_get_mod+0x45>
  104e0a:	8b 45 fc             	mov    -0x4(%ebp),%eax
  104e0d:	8b 40 08             	mov    0x8(%eax),%eax
  104e10:	89 c2                	mov    %eax,%edx
  104e12:	8b 45 0c             	mov    0xc(%ebp),%eax
  104e15:	89 10                	mov    %edx,(%eax)
  if (size!=NULL) *size = mod->mod_end-mod->mod_start;
  104e17:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
  104e1b:	74 12                	je     104e2f <multiboot_get_mod+0x5d>
  104e1d:	8b 45 fc             	mov    -0x4(%ebp),%eax
  104e20:	8b 50 04             	mov    0x4(%eax),%edx
  104e23:	8b 45 fc             	mov    -0x4(%ebp),%eax
  104e26:	8b 00                	mov    (%eax),%eax
  104e28:	29 c2                	sub    %eax,%edx
  104e2a:	8b 45 10             	mov    0x10(%ebp),%eax
  104e2d:	89 10                	mov    %edx,(%eax)
  return (void*)(mod->mod_start);
  104e2f:	8b 45 fc             	mov    -0x4(%ebp),%eax
  104e32:	8b 00                	mov    (%eax),%eax
  104e34:	89 45 ec             	mov    %eax,-0x14(%ebp)
  104e37:	8b 45 ec             	mov    -0x14(%ebp),%eax
}
  104e3a:	c9                   	leave  
  104e3b:	c3                   	ret    

00104e3c <multiboot_get_bootloader>:

/**
 * Gets name of bootloader
 *  @return Name of bootloader
 */
char *multiboot_get_bootloader() {
  104e3c:	55                   	push   %ebp
  104e3d:	89 e5                	mov    %esp,%ebp
  return (char*)(multiboot_info->boot_loader_name);
  104e3f:	a1 54 e9 10 00       	mov    0x10e954,%eax
  104e44:	8b 40 40             	mov    0x40(%eax),%eax
}
  104e47:	5d                   	pop    %ebp
  104e48:	c3                   	ret    

00104e49 <multiboot_get_mmap>:
 *  @param addr Reference for memory block's base address
 *  @param length Reference for memory block's length
 *  @param type Reference for memory block's type
 *  @return 0=Success; -1=Failure
 */
int multiboot_get_mmap(int item,void **addr,size_t *length,multiboot_mmap_type_t *type) {
  104e49:	55                   	push   %ebp
  104e4a:	89 e5                	mov    %esp,%ebp
  104e4c:	83 ec 14             	sub    $0x14,%esp
  if (!multiboot_checkflag(multiboot_info,6)) return -1;
  104e4f:	a1 54 e9 10 00       	mov    0x10e954,%eax
  104e54:	8b 00                	mov    (%eax),%eax
  104e56:	83 e0 40             	and    $0x40,%eax
  104e59:	85 c0                	test   %eax,%eax
  104e5b:	75 0c                	jne    104e69 <multiboot_get_mmap+0x20>
  104e5d:	c7 45 ec ff ff ff ff 	movl   $0xffffffff,-0x14(%ebp)
  104e64:	e9 92 00 00 00       	jmp    104efb <multiboot_get_mmap+0xb2>
  multiboot_mmape_t *mmap;
  size_t i = 0;
  104e69:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)

  for (mmap=(multiboot_mmape_t*)multiboot_info->mmap_addr;(unsigned long)mmap<multiboot_info->mmap_addr+multiboot_info->mmap_length;mmap=(multiboot_mmape_t*)((unsigned long)mmap+mmap->size+sizeof(mmap->size))) {
  104e70:	a1 54 e9 10 00       	mov    0x10e954,%eax
  104e75:	8b 40 30             	mov    0x30(%eax),%eax
  104e78:	89 45 f8             	mov    %eax,-0x8(%ebp)
  104e7b:	eb 5d                	jmp    104eda <multiboot_get_mmap+0x91>
    if (i==item) {
  104e7d:	8b 45 08             	mov    0x8(%ebp),%eax
  104e80:	3b 45 fc             	cmp    -0x4(%ebp),%eax
  104e83:	75 46                	jne    104ecb <multiboot_get_mmap+0x82>
      if (addr!=NULL) *addr = (void*)((unsigned int)mmap->base);
  104e85:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
  104e89:	74 10                	je     104e9b <multiboot_get_mmap+0x52>
  104e8b:	8b 45 f8             	mov    -0x8(%ebp),%eax
  104e8e:	8b 50 08             	mov    0x8(%eax),%edx
  104e91:	8b 40 04             	mov    0x4(%eax),%eax
  104e94:	89 c2                	mov    %eax,%edx
  104e96:	8b 45 0c             	mov    0xc(%ebp),%eax
  104e99:	89 10                	mov    %edx,(%eax)
      if (length!=NULL) *length = mmap->length;
  104e9b:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
  104e9f:	74 10                	je     104eb1 <multiboot_get_mmap+0x68>
  104ea1:	8b 45 f8             	mov    -0x8(%ebp),%eax
  104ea4:	8b 50 10             	mov    0x10(%eax),%edx
  104ea7:	8b 40 0c             	mov    0xc(%eax),%eax
  104eaa:	89 c2                	mov    %eax,%edx
  104eac:	8b 45 10             	mov    0x10(%ebp),%eax
  104eaf:	89 10                	mov    %edx,(%eax)
      if (type!=NULL) *type = mmap->type;
  104eb1:	83 7d 14 00          	cmpl   $0x0,0x14(%ebp)
  104eb5:	74 0b                	je     104ec2 <multiboot_get_mmap+0x79>
  104eb7:	8b 45 f8             	mov    -0x8(%ebp),%eax
  104eba:	8b 50 14             	mov    0x14(%eax),%edx
  104ebd:	8b 45 14             	mov    0x14(%ebp),%eax
  104ec0:	89 10                	mov    %edx,(%eax)
      return 0;
  104ec2:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
  104ec9:	eb 30                	jmp    104efb <multiboot_get_mmap+0xb2>
    }
    i++;
  104ecb:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
int multiboot_get_mmap(int item,void **addr,size_t *length,multiboot_mmap_type_t *type) {
  if (!multiboot_checkflag(multiboot_info,6)) return -1;
  multiboot_mmape_t *mmap;
  size_t i = 0;

  for (mmap=(multiboot_mmape_t*)multiboot_info->mmap_addr;(unsigned long)mmap<multiboot_info->mmap_addr+multiboot_info->mmap_length;mmap=(multiboot_mmape_t*)((unsigned long)mmap+mmap->size+sizeof(mmap->size))) {
  104ecf:	8b 45 f8             	mov    -0x8(%ebp),%eax
  104ed2:	8b 00                	mov    (%eax),%eax
  104ed4:	83 c0 04             	add    $0x4,%eax
  104ed7:	01 45 f8             	add    %eax,-0x8(%ebp)
  104eda:	8b 4d f8             	mov    -0x8(%ebp),%ecx
  104edd:	a1 54 e9 10 00       	mov    0x10e954,%eax
  104ee2:	8b 50 30             	mov    0x30(%eax),%edx
  104ee5:	a1 54 e9 10 00       	mov    0x10e954,%eax
  104eea:	8b 40 2c             	mov    0x2c(%eax),%eax
  104eed:	8d 04 02             	lea    (%edx,%eax,1),%eax
  104ef0:	39 c1                	cmp    %eax,%ecx
  104ef2:	72 89                	jb     104e7d <multiboot_get_mmap+0x34>
      return 0;
    }
    i++;
  }

  return -1;
  104ef4:	c7 45 ec ff ff ff ff 	movl   $0xffffffff,-0x14(%ebp)
  104efb:	8b 45 ec             	mov    -0x14(%ebp),%eax
}
  104efe:	c9                   	leave  
  104eff:	c3                   	ret    

00104f00 <paging_init>:

/**
 * Initializes Paging
 *  @return 0=Success; -1=Failure
 */
int paging_init() {
  104f00:	55                   	push   %ebp
  104f01:	89 e5                	mov    %esp,%ebp
  104f03:	53                   	push   %ebx
  104f04:	83 ec 34             	sub    $0x34,%esp
  size_t i;

  paging_enabled = 0;
  104f07:	c7 05 5c e4 10 00 00 	movl   $0x0,0x10e45c
  104f0e:	00 00 00 
  paging_physrw_lastpage = NULL;
  104f11:	c7 05 48 e4 10 00 00 	movl   $0x0,0x10e448
  104f18:	00 00 00 
  paging_physrw_lastpd = NULL;
  104f1b:	c7 05 94 e1 10 00 00 	movl   $0x0,0x10e194
  104f22:	00 00 00 

  // write initial pagedir
  paging_kernelpd = (pd_t)KERNELPD_ADDRESS;
  104f25:	c7 05 64 e4 10 00 00 	movl   $0x300000,0x10e464
  104f2c:	00 30 00 
  paging_curpd = paging_kernelpd;
  104f2f:	a1 64 e4 10 00       	mov    0x10e464,%eax
  104f34:	a3 74 e4 10 00       	mov    %eax,0x10e474
  memset(paging_kernelpd,0,PAGE_SIZE);
  104f39:	a1 64 e4 10 00       	mov    0x10e464,%eax
  104f3e:	c7 44 24 08 00 10 00 	movl   $0x1000,0x8(%esp)
  104f45:	00 
  104f46:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  104f4d:	00 
  104f4e:	89 04 24             	mov    %eax,(%esp)
  104f51:	e8 0b 6e 00 00       	call   10bd61 <memset>
  paging_kernelpd[0].page = ADDR2PAGE(KERNELPD_ADDRESS+PAGE_SIZE);
  104f56:	8b 15 64 e4 10 00    	mov    0x10e464,%edx
  104f5c:	0f b6 42 01          	movzbl 0x1(%edx),%eax
  104f60:	83 e0 0f             	and    $0xf,%eax
  104f63:	83 c8 10             	or     $0x10,%eax
  104f66:	88 42 01             	mov    %al,0x1(%edx)
  104f69:	0f b6 42 02          	movzbl 0x2(%edx),%eax
  104f6d:	83 e0 00             	and    $0x0,%eax
  104f70:	83 c8 30             	or     $0x30,%eax
  104f73:	88 42 02             	mov    %al,0x2(%edx)
  104f76:	0f b6 42 03          	movzbl 0x3(%edx),%eax
  104f7a:	83 e0 00             	and    $0x0,%eax
  104f7d:	88 42 03             	mov    %al,0x3(%edx)
  paging_kernelpd[0].pagesize = PGSIZE_4K;
  104f80:	8b 15 64 e4 10 00    	mov    0x10e464,%edx
  104f86:	0f b6 02             	movzbl (%edx),%eax
  104f89:	83 e0 7f             	and    $0x7f,%eax
  104f8c:	88 02                	mov    %al,(%edx)
  paging_kernelpd[0].user = 1;
  104f8e:	8b 15 64 e4 10 00    	mov    0x10e464,%edx
  104f94:	0f b6 02             	movzbl (%edx),%eax
  104f97:	83 c8 04             	or     $0x4,%eax
  104f9a:	88 02                	mov    %al,(%edx)
  paging_kernelpd[0].writable = 1;
  104f9c:	8b 15 64 e4 10 00    	mov    0x10e464,%edx
  104fa2:	0f b6 02             	movzbl (%edx),%eax
  104fa5:	83 c8 02             	or     $0x2,%eax
  104fa8:	88 02                	mov    %al,(%edx)
  paging_kernelpd[0].exists = 1;
  104faa:	8b 15 64 e4 10 00    	mov    0x10e464,%edx
  104fb0:	0f b6 02             	movzbl (%edx),%eax
  104fb3:	83 c8 01             	or     $0x1,%eax
  104fb6:	88 02                	mov    %al,(%edx)
  paging_kernelpd[1].page = ADDR2PAGE(KERNELPD_ADDRESS+PAGE_SIZE*2);
  104fb8:	a1 64 e4 10 00       	mov    0x10e464,%eax
  104fbd:	8d 50 04             	lea    0x4(%eax),%edx
  104fc0:	0f b6 42 01          	movzbl 0x1(%edx),%eax
  104fc4:	83 e0 0f             	and    $0xf,%eax
  104fc7:	83 c8 20             	or     $0x20,%eax
  104fca:	88 42 01             	mov    %al,0x1(%edx)
  104fcd:	0f b6 42 02          	movzbl 0x2(%edx),%eax
  104fd1:	83 e0 00             	and    $0x0,%eax
  104fd4:	83 c8 30             	or     $0x30,%eax
  104fd7:	88 42 02             	mov    %al,0x2(%edx)
  104fda:	0f b6 42 03          	movzbl 0x3(%edx),%eax
  104fde:	83 e0 00             	and    $0x0,%eax
  104fe1:	88 42 03             	mov    %al,0x3(%edx)
  paging_kernelpd[1].pagesize = PGSIZE_4K;
  104fe4:	a1 64 e4 10 00       	mov    0x10e464,%eax
  104fe9:	8d 50 04             	lea    0x4(%eax),%edx
  104fec:	0f b6 02             	movzbl (%edx),%eax
  104fef:	83 e0 7f             	and    $0x7f,%eax
  104ff2:	88 02                	mov    %al,(%edx)
  paging_kernelpd[1].user = 1;
  104ff4:	a1 64 e4 10 00       	mov    0x10e464,%eax
  104ff9:	8d 50 04             	lea    0x4(%eax),%edx
  104ffc:	0f b6 02             	movzbl (%edx),%eax
  104fff:	83 c8 04             	or     $0x4,%eax
  105002:	88 02                	mov    %al,(%edx)
  paging_kernelpd[1].writable = 1;
  105004:	a1 64 e4 10 00       	mov    0x10e464,%eax
  105009:	8d 50 04             	lea    0x4(%eax),%edx
  10500c:	0f b6 02             	movzbl (%edx),%eax
  10500f:	83 c8 02             	or     $0x2,%eax
  105012:	88 02                	mov    %al,(%edx)
  paging_kernelpd[1].exists = 1;
  105014:	a1 64 e4 10 00       	mov    0x10e464,%eax
  105019:	8d 50 04             	lea    0x4(%eax),%edx
  10501c:	0f b6 02             	movzbl (%edx),%eax
  10501f:	83 c8 01             	or     $0x1,%eax
  105022:	88 02                	mov    %al,(%edx)
  // write initial pagetables
  memset((void*)(KERNELPD_ADDRESS+PAGE_SIZE),0,PAGE_SIZE);
  105024:	c7 44 24 08 00 10 00 	movl   $0x1000,0x8(%esp)
  10502b:	00 
  10502c:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  105033:	00 
  105034:	c7 04 24 00 10 30 00 	movl   $0x301000,(%esp)
  10503b:	e8 21 6d 00 00       	call   10bd61 <memset>
  for (i=0;i<KERNELCODE_ADDRESS+KERNELCODE_SIZE;i+=PAGE_SIZE) {
  105040:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
  105047:	e9 9a 00 00 00       	jmp    1050e6 <paging_init+0x1e6>
    if ((i>=IVT_ADDRESS && i<IVT_ADDRESS+IVT_SIZE) || (i>=BIOSCODE_ADDRESS && i<BIOSCODE_ADDRESS+BIOSCODE_SIZE)) paging_map((void*)i,(void*)i,1,0);
  10504c:	81 7d f8 ff 01 00 00 	cmpl   $0x1ff,-0x8(%ebp)
  105053:	76 12                	jbe    105067 <paging_init+0x167>
  105055:	81 7d f8 ff ff 0b 00 	cmpl   $0xbffff,-0x8(%ebp)
  10505c:	76 46                	jbe    1050a4 <paging_init+0x1a4>
  10505e:	81 7d f8 ff ff 0f 00 	cmpl   $0xfffff,-0x8(%ebp)
  105065:	77 3d                	ja     1050a4 <paging_init+0x1a4>
  105067:	a1 74 e4 10 00       	mov    0x10e474,%eax
  10506c:	8b 55 f8             	mov    -0x8(%ebp),%edx
  10506f:	8b 4d f8             	mov    -0x8(%ebp),%ecx
  105072:	89 44 24 18          	mov    %eax,0x18(%esp)
  105076:	c7 44 24 14 00 00 00 	movl   $0x0,0x14(%esp)
  10507d:	00 
  10507e:	c7 44 24 10 00 00 00 	movl   $0x0,0x10(%esp)
  105085:	00 
  105086:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
  10508d:	00 
  10508e:	c7 44 24 08 01 00 00 	movl   $0x1,0x8(%esp)
  105095:	00 
  105096:	89 54 24 04          	mov    %edx,0x4(%esp)
  10509a:	89 0c 24             	mov    %ecx,(%esp)
  10509d:	e8 9b 07 00 00       	call   10583d <paging_map_pd>
  1050a2:	eb 3b                	jmp    1050df <paging_init+0x1df>
    else paging_map((void*)i,(void*)i,0,1);
  1050a4:	a1 74 e4 10 00       	mov    0x10e474,%eax
  1050a9:	8b 55 f8             	mov    -0x8(%ebp),%edx
  1050ac:	8b 4d f8             	mov    -0x8(%ebp),%ecx
  1050af:	89 44 24 18          	mov    %eax,0x18(%esp)
  1050b3:	c7 44 24 14 00 00 00 	movl   $0x0,0x14(%esp)
  1050ba:	00 
  1050bb:	c7 44 24 10 00 00 00 	movl   $0x0,0x10(%esp)
  1050c2:	00 
  1050c3:	c7 44 24 0c 01 00 00 	movl   $0x1,0xc(%esp)
  1050ca:	00 
  1050cb:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  1050d2:	00 
  1050d3:	89 54 24 04          	mov    %edx,0x4(%esp)
  1050d7:	89 0c 24             	mov    %ecx,(%esp)
  1050da:	e8 5e 07 00 00       	call   10583d <paging_map_pd>
  paging_kernelpd[1].user = 1;
  paging_kernelpd[1].writable = 1;
  paging_kernelpd[1].exists = 1;
  // write initial pagetables
  memset((void*)(KERNELPD_ADDRESS+PAGE_SIZE),0,PAGE_SIZE);
  for (i=0;i<KERNELCODE_ADDRESS+KERNELCODE_SIZE;i+=PAGE_SIZE) {
  1050df:	81 45 f8 00 10 00 00 	addl   $0x1000,-0x8(%ebp)
  1050e6:	81 7d f8 ff ff 2f 00 	cmpl   $0x2fffff,-0x8(%ebp)
  1050ed:	0f 86 59 ff ff ff    	jbe    10504c <paging_init+0x14c>
    if ((i>=IVT_ADDRESS && i<IVT_ADDRESS+IVT_SIZE) || (i>=BIOSCODE_ADDRESS && i<BIOSCODE_ADDRESS+BIOSCODE_SIZE)) paging_map((void*)i,(void*)i,1,0);
    else paging_map((void*)i,(void*)i,0,1);
  }
  // write second pagetables (maybe needed by stack)
  memset((void*)(KERNELPD_ADDRESS+PAGE_SIZE*2),0,PAGE_SIZE);
  1050f3:	c7 44 24 08 00 10 00 	movl   $0x1000,0x8(%esp)
  1050fa:	00 
  1050fb:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  105102:	00 
  105103:	c7 04 24 00 20 30 00 	movl   $0x302000,(%esp)
  10510a:	e8 52 6c 00 00       	call   10bd61 <memset>

  // map pagedir as last pagetable
  memset(paging_kernelpd+1023,0,sizeof(pde_t));
  10510f:	a1 64 e4 10 00       	mov    0x10e464,%eax
  105114:	05 fc 0f 00 00       	add    $0xffc,%eax
  105119:	c7 44 24 08 04 00 00 	movl   $0x4,0x8(%esp)
  105120:	00 
  105121:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  105128:	00 
  105129:	89 04 24             	mov    %eax,(%esp)
  10512c:	e8 30 6c 00 00       	call   10bd61 <memset>
  paging_kernelpd[1023].page = ADDR2PAGE(paging_kernelpd);
  105131:	a1 64 e4 10 00       	mov    0x10e464,%eax
  105136:	8d 90 fc 0f 00 00    	lea    0xffc(%eax),%edx
  10513c:	a1 64 e4 10 00       	mov    0x10e464,%eax
  105141:	c1 e8 0c             	shr    $0xc,%eax
  105144:	89 c1                	mov    %eax,%ecx
  105146:	81 e1 ff ff 0f 00    	and    $0xfffff,%ecx
  10514c:	89 c8                	mov    %ecx,%eax
  10514e:	83 e0 0f             	and    $0xf,%eax
  105151:	89 c3                	mov    %eax,%ebx
  105153:	c1 e3 04             	shl    $0x4,%ebx
  105156:	0f b6 42 01          	movzbl 0x1(%edx),%eax
  10515a:	83 e0 0f             	and    $0xf,%eax
  10515d:	09 d8                	or     %ebx,%eax
  10515f:	88 42 01             	mov    %al,0x1(%edx)
  105162:	89 c8                	mov    %ecx,%eax
  105164:	c1 e8 04             	shr    $0x4,%eax
  105167:	0f b6 d8             	movzbl %al,%ebx
  10516a:	0f b6 42 02          	movzbl 0x2(%edx),%eax
  10516e:	83 e0 00             	and    $0x0,%eax
  105171:	09 d8                	or     %ebx,%eax
  105173:	88 42 02             	mov    %al,0x2(%edx)
  105176:	89 c8                	mov    %ecx,%eax
  105178:	c1 e8 0c             	shr    $0xc,%eax
  10517b:	0f b6 c8             	movzbl %al,%ecx
  10517e:	0f b6 42 03          	movzbl 0x3(%edx),%eax
  105182:	83 e0 00             	and    $0x0,%eax
  105185:	09 c8                	or     %ecx,%eax
  105187:	88 42 03             	mov    %al,0x3(%edx)
  paging_kernelpd[1023].pagesize = PGSIZE_4K;
  10518a:	a1 64 e4 10 00       	mov    0x10e464,%eax
  10518f:	8d 90 fc 0f 00 00    	lea    0xffc(%eax),%edx
  105195:	0f b6 02             	movzbl (%edx),%eax
  105198:	83 e0 7f             	and    $0x7f,%eax
  10519b:	88 02                	mov    %al,(%edx)
  paging_kernelpd[1023].user = 0;
  10519d:	a1 64 e4 10 00       	mov    0x10e464,%eax
  1051a2:	8d 90 fc 0f 00 00    	lea    0xffc(%eax),%edx
  1051a8:	0f b6 02             	movzbl (%edx),%eax
  1051ab:	83 e0 fb             	and    $0xfffffffb,%eax
  1051ae:	88 02                	mov    %al,(%edx)
  paging_kernelpd[1023].writable = 1;
  1051b0:	a1 64 e4 10 00       	mov    0x10e464,%eax
  1051b5:	8d 90 fc 0f 00 00    	lea    0xffc(%eax),%edx
  1051bb:	0f b6 02             	movzbl (%edx),%eax
  1051be:	83 c8 02             	or     $0x2,%eax
  1051c1:	88 02                	mov    %al,(%edx)
  paging_kernelpd[1023].exists = 1;
  1051c3:	a1 64 e4 10 00       	mov    0x10e464,%eax
  1051c8:	8d 90 fc 0f 00 00    	lea    0xffc(%eax),%edx
  1051ce:	0f b6 02             	movzbl (%edx),%eax
  1051d1:	83 c8 01             	or     $0x1,%eax
  1051d4:	88 02                	mov    %al,(%edx)

  // enable paging
  paging_loadpagedir(paging_kernelpd);
  1051d6:	a1 64 e4 10 00       	mov    0x10e464,%eax
  1051db:	89 04 24             	mov    %eax,(%esp)
  1051de:	e8 20 00 00 00       	call   105203 <paging_loadpagedir>
  asm("mov %cr0,%eax; or $0x80000000,%eax; mov %eax,%cr0;");
  1051e3:	0f 20 c0             	mov    %cr0,%eax
  1051e6:	0d 00 00 00 80       	or     $0x80000000,%eax
  1051eb:	0f 22 c0             	mov    %eax,%cr0
  paging_enabled = 1;
  1051ee:	c7 05 5c e4 10 00 01 	movl   $0x1,0x10e45c
  1051f5:	00 00 00 

  return 0;
  1051f8:	b8 00 00 00 00       	mov    $0x0,%eax
}
  1051fd:	83 c4 34             	add    $0x34,%esp
  105200:	5b                   	pop    %ebx
  105201:	5d                   	pop    %ebp
  105202:	c3                   	ret    

00105203 <paging_loadpagedir>:
/**
 * Loads pagedir
 *  @param pd Pagedir
 *  @return Success?
 */
int paging_loadpagedir(pd_t pd) {
  105203:	55                   	push   %ebp
  105204:	89 e5                	mov    %esp,%ebp
  asm("mov %0,%%cr3;"::"a"(pd));
  105206:	8b 45 08             	mov    0x8(%ebp),%eax
  105209:	0f 22 d8             	mov    %eax,%cr3
  paging_curpd = pd;
  10520c:	8b 45 08             	mov    0x8(%ebp),%eax
  10520f:	a3 74 e4 10 00       	mov    %eax,0x10e474
  return 0;
  105214:	b8 00 00 00 00       	mov    $0x0,%eax
}
  105219:	5d                   	pop    %ebp
  10521a:	c3                   	ret    

0010521b <paging_physread>:
 *  @param src Physical address as source
 *  @param count How many bytes to read
 *  @return How many bytes read
 *  @note Read does not work over page borders
 */
int paging_physread(void *dest,void *src,size_t count) {
  10521b:	55                   	push   %ebp
  10521c:	89 e5                	mov    %esp,%ebp
  10521e:	83 ec 38             	sub    $0x38,%esp
  void *src_rounded = PAGEDOWN(src);
  105221:	8b 45 0c             	mov    0xc(%ebp),%eax
  105224:	c1 e8 0c             	shr    $0xc,%eax
  105227:	c1 e0 0c             	shl    $0xc,%eax
  10522a:	89 45 fc             	mov    %eax,-0x4(%ebp)

  if (src_rounded!=paging_physrw_lastpage || paging_curpd!=paging_physrw_lastpd) {
  10522d:	a1 48 e4 10 00       	mov    0x10e448,%eax
  105232:	39 45 fc             	cmp    %eax,-0x4(%ebp)
  105235:	75 0f                	jne    105246 <paging_physread+0x2b>
  105237:	8b 15 74 e4 10 00    	mov    0x10e474,%edx
  10523d:	a1 94 e1 10 00       	mov    0x10e194,%eax
  105242:	39 c2                	cmp    %eax,%edx
  105244:	74 5b                	je     1052a1 <paging_physread+0x86>
    if (paging_map((void*)BUFPAGE_ADDRESS,src_rounded,0,1)<0) return 0;
  105246:	a1 74 e4 10 00       	mov    0x10e474,%eax
  10524b:	89 44 24 18          	mov    %eax,0x18(%esp)
  10524f:	c7 44 24 14 00 00 00 	movl   $0x0,0x14(%esp)
  105256:	00 
  105257:	c7 44 24 10 00 00 00 	movl   $0x0,0x10(%esp)
  10525e:	00 
  10525f:	c7 44 24 0c 01 00 00 	movl   $0x1,0xc(%esp)
  105266:	00 
  105267:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  10526e:	00 
  10526f:	8b 45 fc             	mov    -0x4(%ebp),%eax
  105272:	89 44 24 04          	mov    %eax,0x4(%esp)
  105276:	c7 04 24 00 f0 bf ff 	movl   $0xffbff000,(%esp)
  10527d:	e8 bb 05 00 00       	call   10583d <paging_map_pd>
  105282:	85 c0                	test   %eax,%eax
  105284:	79 09                	jns    10528f <paging_physread+0x74>
  105286:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
  10528d:	eb 3c                	jmp    1052cb <paging_physread+0xb0>
    paging_physrw_lastpage = src_rounded;
  10528f:	8b 45 fc             	mov    -0x4(%ebp),%eax
  105292:	a3 48 e4 10 00       	mov    %eax,0x10e448
    paging_physrw_lastpd = paging_curpd;
  105297:	a1 74 e4 10 00       	mov    0x10e474,%eax
  10529c:	a3 94 e1 10 00       	mov    %eax,0x10e194
  }
  memcpy(dest,((void*)BUFPAGE_ADDRESS)+PAGEOFF(src),count);
  1052a1:	8b 45 0c             	mov    0xc(%ebp),%eax
  1052a4:	25 ff 0f 00 00       	and    $0xfff,%eax
  1052a9:	8d 90 00 f0 bf ff    	lea    -0x401000(%eax),%edx
  1052af:	8b 45 10             	mov    0x10(%ebp),%eax
  1052b2:	89 44 24 08          	mov    %eax,0x8(%esp)
  1052b6:	89 54 24 04          	mov    %edx,0x4(%esp)
  1052ba:	8b 45 08             	mov    0x8(%ebp),%eax
  1052bd:	89 04 24             	mov    %eax,(%esp)
  1052c0:	e8 bf 68 00 00       	call   10bb84 <memcpy>
  return count;
  1052c5:	8b 45 10             	mov    0x10(%ebp),%eax
  1052c8:	89 45 ec             	mov    %eax,-0x14(%ebp)
  1052cb:	8b 45 ec             	mov    -0x14(%ebp),%eax
}
  1052ce:	c9                   	leave  
  1052cf:	c3                   	ret    

001052d0 <paging_physwrite>:
 *  @return How many bytes written
 *  @note Write does not work over page borders
 *  @todo Enable caching
 */
#include <memuser.h>
int paging_physwrite(void *dest,void *src,size_t count) {
  1052d0:	55                   	push   %ebp
  1052d1:	89 e5                	mov    %esp,%ebp
  1052d3:	83 ec 38             	sub    $0x38,%esp
  void *dest_rounded = PAGEDOWN(dest);
  1052d6:	8b 45 08             	mov    0x8(%ebp),%eax
  1052d9:	c1 e8 0c             	shr    $0xc,%eax
  1052dc:	c1 e0 0c             	shl    $0xc,%eax
  1052df:	89 45 fc             	mov    %eax,-0x4(%ebp)

  if (dest_rounded!=paging_physrw_lastpage || paging_curpd!=paging_physrw_lastpd || 1) {
    if (paging_map((void*)BUFPAGE_ADDRESS,dest_rounded,0,1)<0) return 0;
  1052e2:	a1 74 e4 10 00       	mov    0x10e474,%eax
  1052e7:	89 44 24 18          	mov    %eax,0x18(%esp)
  1052eb:	c7 44 24 14 00 00 00 	movl   $0x0,0x14(%esp)
  1052f2:	00 
  1052f3:	c7 44 24 10 00 00 00 	movl   $0x0,0x10(%esp)
  1052fa:	00 
  1052fb:	c7 44 24 0c 01 00 00 	movl   $0x1,0xc(%esp)
  105302:	00 
  105303:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  10530a:	00 
  10530b:	8b 45 fc             	mov    -0x4(%ebp),%eax
  10530e:	89 44 24 04          	mov    %eax,0x4(%esp)
  105312:	c7 04 24 00 f0 bf ff 	movl   $0xffbff000,(%esp)
  105319:	e8 1f 05 00 00       	call   10583d <paging_map_pd>
  10531e:	85 c0                	test   %eax,%eax
  105320:	79 09                	jns    10532b <paging_physwrite+0x5b>
  105322:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
  105329:	eb 3c                	jmp    105367 <paging_physwrite+0x97>
    paging_physrw_lastpage = dest_rounded;
  10532b:	8b 45 fc             	mov    -0x4(%ebp),%eax
  10532e:	a3 48 e4 10 00       	mov    %eax,0x10e448
    paging_physrw_lastpd = paging_curpd;
  105333:	a1 74 e4 10 00       	mov    0x10e474,%eax
  105338:	a3 94 e1 10 00       	mov    %eax,0x10e194
  }
  memcpy(((void*)BUFPAGE_ADDRESS)+PAGEOFF(dest),src,count);
  10533d:	8b 45 08             	mov    0x8(%ebp),%eax
  105340:	25 ff 0f 00 00       	and    $0xfff,%eax
  105345:	8d 90 00 f0 bf ff    	lea    -0x401000(%eax),%edx
  10534b:	8b 45 10             	mov    0x10(%ebp),%eax
  10534e:	89 44 24 08          	mov    %eax,0x8(%esp)
  105352:	8b 45 0c             	mov    0xc(%ebp),%eax
  105355:	89 44 24 04          	mov    %eax,0x4(%esp)
  105359:	89 14 24             	mov    %edx,(%esp)
  10535c:	e8 23 68 00 00       	call   10bb84 <memcpy>
  return count;
  105361:	8b 45 10             	mov    0x10(%ebp),%eax
  105364:	89 45 ec             	mov    %eax,-0x14(%ebp)
  105367:	8b 45 ec             	mov    -0x14(%ebp),%eax
}
  10536a:	c9                   	leave  
  10536b:	c3                   	ret    

0010536c <paging_cleanpage>:

/**
 * Clean a whole page
 *  @param page Physical address of page
 */
void *paging_cleanpage(void *page) {
  10536c:	55                   	push   %ebp
  10536d:	89 e5                	mov    %esp,%ebp
  10536f:	83 ec 38             	sub    $0x38,%esp
  if (paging_enabled) {
  105372:	a1 5c e4 10 00       	mov    0x10e45c,%eax
  105377:	85 c0                	test   %eax,%eax
  105379:	0f 84 9e 00 00 00    	je     10541d <paging_cleanpage+0xb1>
    void *page_rounded = PAGEDOWN(page);
  10537f:	8b 45 08             	mov    0x8(%ebp),%eax
  105382:	c1 e8 0c             	shr    $0xc,%eax
  105385:	c1 e0 0c             	shl    $0xc,%eax
  105388:	89 45 fc             	mov    %eax,-0x4(%ebp)
    if (page_rounded!=paging_physrw_lastpage || paging_curpd!=paging_physrw_lastpd) {
  10538b:	a1 48 e4 10 00       	mov    0x10e448,%eax
  105390:	39 45 fc             	cmp    %eax,-0x4(%ebp)
  105393:	75 0f                	jne    1053a4 <paging_cleanpage+0x38>
  105395:	8b 15 74 e4 10 00    	mov    0x10e474,%edx
  10539b:	a1 94 e1 10 00       	mov    0x10e194,%eax
  1053a0:	39 c2                	cmp    %eax,%edx
  1053a2:	74 5b                	je     1053ff <paging_cleanpage+0x93>
      if (paging_map((void*)BUFPAGE_ADDRESS,page_rounded,0,1)<0) return 0;
  1053a4:	a1 74 e4 10 00       	mov    0x10e474,%eax
  1053a9:	89 44 24 18          	mov    %eax,0x18(%esp)
  1053ad:	c7 44 24 14 00 00 00 	movl   $0x0,0x14(%esp)
  1053b4:	00 
  1053b5:	c7 44 24 10 00 00 00 	movl   $0x0,0x10(%esp)
  1053bc:	00 
  1053bd:	c7 44 24 0c 01 00 00 	movl   $0x1,0xc(%esp)
  1053c4:	00 
  1053c5:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  1053cc:	00 
  1053cd:	8b 45 fc             	mov    -0x4(%ebp),%eax
  1053d0:	89 44 24 04          	mov    %eax,0x4(%esp)
  1053d4:	c7 04 24 00 f0 bf ff 	movl   $0xffbff000,(%esp)
  1053db:	e8 5d 04 00 00       	call   10583d <paging_map_pd>
  1053e0:	85 c0                	test   %eax,%eax
  1053e2:	79 09                	jns    1053ed <paging_cleanpage+0x81>
  1053e4:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
  1053eb:	eb 51                	jmp    10543e <paging_cleanpage+0xd2>
      paging_physrw_lastpage = page_rounded;
  1053ed:	8b 45 fc             	mov    -0x4(%ebp),%eax
  1053f0:	a3 48 e4 10 00       	mov    %eax,0x10e448
      paging_physrw_lastpd = paging_curpd;
  1053f5:	a1 74 e4 10 00       	mov    0x10e474,%eax
  1053fa:	a3 94 e1 10 00       	mov    %eax,0x10e194
    }
    memset((void*)BUFPAGE_ADDRESS,0,PAGE_SIZE);
  1053ff:	c7 44 24 08 00 10 00 	movl   $0x1000,0x8(%esp)
  105406:	00 
  105407:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  10540e:	00 
  10540f:	c7 04 24 00 f0 bf ff 	movl   $0xffbff000,(%esp)
  105416:	e8 46 69 00 00       	call   10bd61 <memset>
  10541b:	eb 1b                	jmp    105438 <paging_cleanpage+0xcc>
  }
  else memset(page,0,PAGE_SIZE);
  10541d:	c7 44 24 08 00 10 00 	movl   $0x1000,0x8(%esp)
  105424:	00 
  105425:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  10542c:	00 
  10542d:	8b 45 08             	mov    0x8(%ebp),%eax
  105430:	89 04 24             	mov    %eax,(%esp)
  105433:	e8 29 69 00 00       	call   10bd61 <memset>
  return page;
  105438:	8b 45 08             	mov    0x8(%ebp),%eax
  10543b:	89 45 ec             	mov    %eax,-0x14(%ebp)
  10543e:	8b 45 ec             	mov    -0x14(%ebp),%eax
}
  105441:	c9                   	leave  
  105442:	c3                   	ret    

00105443 <paging_getpde>:
/**
 * Gets a PDE
 *  @param virt Virtual address
 *  @return PDE
 */
pde_t paging_getpde(void *virt) {
  105443:	55                   	push   %ebp
  105444:	89 e5                	mov    %esp,%ebp
  105446:	83 ec 10             	sub    $0x10,%esp
  pde_t pde;
  if (paging_enabled) pde = ((pd_t)PAGEDIR_ADDRESS)[ADDR2PDE(virt)];
  105449:	a1 5c e4 10 00       	mov    0x10e45c,%eax
  10544e:	85 c0                	test   %eax,%eax
  105450:	74 15                	je     105467 <paging_getpde+0x24>
  105452:	8b 45 0c             	mov    0xc(%ebp),%eax
  105455:	c1 e8 16             	shr    $0x16,%eax
  105458:	c1 e0 02             	shl    $0x2,%eax
  10545b:	2d 00 10 00 00       	sub    $0x1000,%eax
  105460:	8b 00                	mov    (%eax),%eax
  105462:	89 45 fc             	mov    %eax,-0x4(%ebp)
  105465:	eb 17                	jmp    10547e <paging_getpde+0x3b>
  else pde = paging_curpd[ADDR2PDE(virt)];
  105467:	8b 15 74 e4 10 00    	mov    0x10e474,%edx
  10546d:	8b 45 0c             	mov    0xc(%ebp),%eax
  105470:	c1 e8 16             	shr    $0x16,%eax
  105473:	c1 e0 02             	shl    $0x2,%eax
  105476:	8d 04 02             	lea    (%edx,%eax,1),%eax
  105479:	8b 00                	mov    (%eax),%eax
  10547b:	89 45 fc             	mov    %eax,-0x4(%ebp)
  return pde;
  10547e:	8b 45 fc             	mov    -0x4(%ebp),%eax
  105481:	8b 55 08             	mov    0x8(%ebp),%edx
  105484:	89 02                	mov    %eax,(%edx)
}
  105486:	8b 45 08             	mov    0x8(%ebp),%eax
  105489:	c9                   	leave  
  10548a:	c2 04 00             	ret    $0x4

0010548d <paging_setpde>:
 * Sets a PDE
 *  @param virt Virtual address
 *  @param pde PDE
 *  @return 0=Success; -1=Failure
 */
int paging_setpde(void *virt,pde_t pde) {
  10548d:	55                   	push   %ebp
  10548e:	89 e5                	mov    %esp,%ebp
  105490:	83 ec 08             	sub    $0x8,%esp
  if (paging_enabled) ((pd_t)PAGEDIR_ADDRESS)[ADDR2PDE(virt)] = pde;
  105493:	a1 5c e4 10 00       	mov    0x10e45c,%eax
  105498:	85 c0                	test   %eax,%eax
  10549a:	74 16                	je     1054b2 <paging_setpde+0x25>
  10549c:	8b 45 08             	mov    0x8(%ebp),%eax
  10549f:	c1 e8 16             	shr    $0x16,%eax
  1054a2:	c1 e0 02             	shl    $0x2,%eax
  1054a5:	8d 90 00 f0 ff ff    	lea    -0x1000(%eax),%edx
  1054ab:	8b 45 0c             	mov    0xc(%ebp),%eax
  1054ae:	89 02                	mov    %eax,(%edx)
  1054b0:	eb 16                	jmp    1054c8 <paging_setpde+0x3b>
  else paging_curpd[ADDR2PDE(virt)] = pde;
  1054b2:	8b 15 74 e4 10 00    	mov    0x10e474,%edx
  1054b8:	8b 45 08             	mov    0x8(%ebp),%eax
  1054bb:	c1 e8 16             	shr    $0x16,%eax
  1054be:	c1 e0 02             	shl    $0x2,%eax
  1054c1:	01 c2                	add    %eax,%edx
  1054c3:	8b 45 0c             	mov    0xc(%ebp),%eax
  1054c6:	89 02                	mov    %eax,(%edx)
  paging_flushtlb(virt);
  1054c8:	8b 45 08             	mov    0x8(%ebp),%eax
  1054cb:	89 04 24             	mov    %eax,(%esp)
  1054ce:	e8 07 00 00 00       	call   1054da <paging_flushtlb>
  return 0;
  1054d3:	b8 00 00 00 00       	mov    $0x0,%eax
}
  1054d8:	c9                   	leave  
  1054d9:	c3                   	ret    

001054da <paging_flushtlb>:
int paging_setpte_pd(void *virt,pte_t pte,pd_t pagedir);
int paging_map_pd(void *virt,void *phys,int user,int writable,int swappable,int cow,pd_t pagedir);
void *paging_unmap(void *virt);
void *paging_getphysaddr(void *virt);

static inline void paging_flushtlb(void *addr) {
  1054da:	55                   	push   %ebp
  1054db:	89 e5                	mov    %esp,%ebp
  asm("invlpg %0"::"m"(addr));
  1054dd:	0f 01 7d 08          	invlpg 0x8(%ebp)
}
  1054e1:	5d                   	pop    %ebp
  1054e2:	c3                   	ret    

001054e3 <paging_getpte>:
/**
 * Gets a PTE
 *  @param virt Virtual address
 *  @return PTE
 */
pte_t paging_getpte(void *virt) {
  1054e3:	55                   	push   %ebp
  1054e4:	89 e5                	mov    %esp,%ebp
  1054e6:	83 ec 28             	sub    $0x28,%esp
  pte_t pte;
  pde_t pde = paging_getpde(virt);
  1054e9:	8d 55 f8             	lea    -0x8(%ebp),%edx
  1054ec:	8b 45 0c             	mov    0xc(%ebp),%eax
  1054ef:	89 44 24 04          	mov    %eax,0x4(%esp)
  1054f3:	89 14 24             	mov    %edx,(%esp)
  1054f6:	e8 48 ff ff ff       	call   105443 <paging_getpde>
  1054fb:	83 ec 04             	sub    $0x4,%esp
  if (!pde.exists) memset(&pte,0,sizeof(pte));
  1054fe:	0f b6 45 f8          	movzbl -0x8(%ebp),%eax
  105502:	83 e0 01             	and    $0x1,%eax
  105505:	84 c0                	test   %al,%al
  105507:	75 1d                	jne    105526 <paging_getpte+0x43>
  105509:	c7 44 24 08 04 00 00 	movl   $0x4,0x8(%esp)
  105510:	00 
  105511:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  105518:	00 
  105519:	8d 45 fc             	lea    -0x4(%ebp),%eax
  10551c:	89 04 24             	mov    %eax,(%esp)
  10551f:	e8 3d 68 00 00       	call   10bd61 <memset>
  105524:	eb 53                	jmp    105579 <paging_getpte+0x96>
  else {
    if (paging_enabled) pte = ((pt_t)(PAGETABLES_ADDRESS+ADDR2PDE(virt)*PAGE_SIZE))[ADDR2PTE(virt)];
  105526:	a1 5c e4 10 00       	mov    0x10e45c,%eax
  10552b:	85 c0                	test   %eax,%eax
  10552d:	74 28                	je     105557 <paging_getpte+0x74>
  10552f:	8b 45 0c             	mov    0xc(%ebp),%eax
  105532:	c1 e8 16             	shr    $0x16,%eax
  105535:	89 c2                	mov    %eax,%edx
  105537:	c1 e2 0a             	shl    $0xa,%edx
  10553a:	8b 45 0c             	mov    0xc(%ebp),%eax
  10553d:	c1 e8 0c             	shr    $0xc,%eax
  105540:	25 ff 03 00 00       	and    $0x3ff,%eax
  105545:	8d 04 02             	lea    (%edx,%eax,1),%eax
  105548:	2d 00 00 10 00       	sub    $0x100000,%eax
  10554d:	c1 e0 02             	shl    $0x2,%eax
  105550:	8b 00                	mov    (%eax),%eax
  105552:	89 45 fc             	mov    %eax,-0x4(%ebp)
  105555:	eb 22                	jmp    105579 <paging_getpte+0x96>
    else pte = ((pt_t)PAGE2ADDR(pde.page))[ADDR2PTE(virt)];
  105557:	8b 45 0c             	mov    0xc(%ebp),%eax
  10555a:	c1 e8 0c             	shr    $0xc,%eax
  10555d:	89 c2                	mov    %eax,%edx
  10555f:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
  105565:	8b 45 f8             	mov    -0x8(%ebp),%eax
  105568:	c1 e8 0c             	shr    $0xc,%eax
  10556b:	c1 e0 0a             	shl    $0xa,%eax
  10556e:	8d 04 02             	lea    (%edx,%eax,1),%eax
  105571:	c1 e0 02             	shl    $0x2,%eax
  105574:	8b 00                	mov    (%eax),%eax
  105576:	89 45 fc             	mov    %eax,-0x4(%ebp)
  }
  return pte;
  105579:	8b 45 fc             	mov    -0x4(%ebp),%eax
  10557c:	8b 55 08             	mov    0x8(%ebp),%edx
  10557f:	89 02                	mov    %eax,(%edx)
}
  105581:	8b 45 08             	mov    0x8(%ebp),%eax
  105584:	c9                   	leave  
  105585:	c2 04 00             	ret    $0x4

00105588 <paging_setpte>:
 * Sets a PTE
 *  @param virt Virtual address
 *  @param pte PTE
 *  @return 0=Success; -1=Failure
 */
int paging_setpte(void *virt,pte_t pte) {
  105588:	55                   	push   %ebp
  105589:	89 e5                	mov    %esp,%ebp
  10558b:	83 ec 1c             	sub    $0x1c,%esp
  pde_t pde = paging_getpde(virt);
  10558e:	8d 55 fc             	lea    -0x4(%ebp),%edx
  105591:	8b 45 08             	mov    0x8(%ebp),%eax
  105594:	89 44 24 04          	mov    %eax,0x4(%esp)
  105598:	89 14 24             	mov    %edx,(%esp)
  10559b:	e8 a3 fe ff ff       	call   105443 <paging_getpde>
  1055a0:	83 ec 04             	sub    $0x4,%esp
  if (!pde.exists) return -1;
  1055a3:	0f b6 45 fc          	movzbl -0x4(%ebp),%eax
  1055a7:	83 e0 01             	and    $0x1,%eax
  1055aa:	84 c0                	test   %al,%al
  1055ac:	75 09                	jne    1055b7 <paging_setpte+0x2f>
  1055ae:	c7 45 ec ff ff ff ff 	movl   $0xffffffff,-0x14(%ebp)
  1055b5:	eb 69                	jmp    105620 <paging_setpte+0x98>
  else {
    if (paging_enabled) ((pt_t)(PAGETABLES_ADDRESS+ADDR2PDE(virt)*PAGE_SIZE))[ADDR2PTE(virt)] = pte;
  1055b7:	a1 5c e4 10 00       	mov    0x10e45c,%eax
  1055bc:	85 c0                	test   %eax,%eax
  1055be:	74 2a                	je     1055ea <paging_setpte+0x62>
  1055c0:	8b 45 08             	mov    0x8(%ebp),%eax
  1055c3:	c1 e8 16             	shr    $0x16,%eax
  1055c6:	89 c2                	mov    %eax,%edx
  1055c8:	c1 e2 0a             	shl    $0xa,%edx
  1055cb:	8b 45 08             	mov    0x8(%ebp),%eax
  1055ce:	c1 e8 0c             	shr    $0xc,%eax
  1055d1:	25 ff 03 00 00       	and    $0x3ff,%eax
  1055d6:	8d 04 02             	lea    (%edx,%eax,1),%eax
  1055d9:	2d 00 00 10 00       	sub    $0x100000,%eax
  1055de:	c1 e0 02             	shl    $0x2,%eax
  1055e1:	89 c2                	mov    %eax,%edx
  1055e3:	8b 45 0c             	mov    0xc(%ebp),%eax
  1055e6:	89 02                	mov    %eax,(%edx)
  1055e8:	eb 24                	jmp    10560e <paging_setpte+0x86>
    else ((pt_t)PAGE2ADDR(pde.page))[ADDR2PTE(virt)] = pte;
  1055ea:	8b 45 08             	mov    0x8(%ebp),%eax
  1055ed:	c1 e8 0c             	shr    $0xc,%eax
  1055f0:	89 c2                	mov    %eax,%edx
  1055f2:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
  1055f8:	8b 45 fc             	mov    -0x4(%ebp),%eax
  1055fb:	c1 e8 0c             	shr    $0xc,%eax
  1055fe:	c1 e0 0a             	shl    $0xa,%eax
  105601:	8d 04 02             	lea    (%edx,%eax,1),%eax
  105604:	c1 e0 02             	shl    $0x2,%eax
  105607:	89 c2                	mov    %eax,%edx
  105609:	8b 45 0c             	mov    0xc(%ebp),%eax
  10560c:	89 02                	mov    %eax,(%edx)
    paging_flushtlb(virt);
  10560e:	8b 45 08             	mov    0x8(%ebp),%eax
  105611:	89 04 24             	mov    %eax,(%esp)
  105614:	e8 c1 fe ff ff       	call   1054da <paging_flushtlb>
    return 0;
  105619:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
  105620:	8b 45 ec             	mov    -0x14(%ebp),%eax
  }
}
  105623:	c9                   	leave  
  105624:	c3                   	ret    

00105625 <paging_getpde_pd>:
 * Gets a PDE from not-loaded pagedir
 *  @param virt Virtual address
 *  @param pagedir Pagedir
 *  @return PDE
 */
pde_t paging_getpde_pd(void *virt,pd_t pagedir) {
  105625:	55                   	push   %ebp
  105626:	89 e5                	mov    %esp,%ebp
  105628:	83 ec 28             	sub    $0x28,%esp
  if (pagedir==paging_curpd) return paging_getpde(virt);
  10562b:	a1 74 e4 10 00       	mov    0x10e474,%eax
  105630:	39 45 10             	cmp    %eax,0x10(%ebp)
  105633:	75 17                	jne    10564c <paging_getpde_pd+0x27>
  105635:	8b 45 0c             	mov    0xc(%ebp),%eax
  105638:	89 44 24 04          	mov    %eax,0x4(%esp)
  10563c:	8b 45 08             	mov    0x8(%ebp),%eax
  10563f:	89 04 24             	mov    %eax,(%esp)
  105642:	e8 fc fd ff ff       	call   105443 <paging_getpde>
  105647:	83 ec 04             	sub    $0x4,%esp
  10564a:	eb 2b                	jmp    105677 <paging_getpde_pd+0x52>
  else {
    pde_t pde;
    paging_physread(&pde,pagedir+ADDR2PDE(virt),sizeof(pde));
  10564c:	8b 45 0c             	mov    0xc(%ebp),%eax
  10564f:	c1 e8 16             	shr    $0x16,%eax
  105652:	c1 e0 02             	shl    $0x2,%eax
  105655:	03 45 10             	add    0x10(%ebp),%eax
  105658:	c7 44 24 08 04 00 00 	movl   $0x4,0x8(%esp)
  10565f:	00 
  105660:	89 44 24 04          	mov    %eax,0x4(%esp)
  105664:	8d 45 fc             	lea    -0x4(%ebp),%eax
  105667:	89 04 24             	mov    %eax,(%esp)
  10566a:	e8 ac fb ff ff       	call   10521b <paging_physread>
    return pde;
  10566f:	8b 45 fc             	mov    -0x4(%ebp),%eax
  105672:	8b 55 08             	mov    0x8(%ebp),%edx
  105675:	89 02                	mov    %eax,(%edx)
  }
}
  105677:	8b 45 08             	mov    0x8(%ebp),%eax
  10567a:	c9                   	leave  
  10567b:	c2 04 00             	ret    $0x4

0010567e <paging_setpde_pd>:
 *  @param virt Virtual address
 *  @param pde PDE
 *  @param pd pagedir
 *  @return 0=Success; -1=Failure
 */
int paging_setpde_pd(void *virt,pde_t pde,pd_t pagedir) {
  10567e:	55                   	push   %ebp
  10567f:	89 e5                	mov    %esp,%ebp
  105681:	83 ec 18             	sub    $0x18,%esp
  if (pagedir==paging_curpd) return paging_setpde(virt,pde);
  105684:	a1 74 e4 10 00       	mov    0x10e474,%eax
  105689:	39 45 10             	cmp    %eax,0x10(%ebp)
  10568c:	75 17                	jne    1056a5 <paging_setpde_pd+0x27>
  10568e:	8b 45 0c             	mov    0xc(%ebp),%eax
  105691:	89 44 24 04          	mov    %eax,0x4(%esp)
  105695:	8b 45 08             	mov    0x8(%ebp),%eax
  105698:	89 04 24             	mov    %eax,(%esp)
  10569b:	e8 ed fd ff ff       	call   10548d <paging_setpde>
  1056a0:	89 45 f8             	mov    %eax,-0x8(%ebp)
  1056a3:	eb 40                	jmp    1056e5 <paging_setpde_pd+0x67>
  else return paging_physwrite(pagedir+ADDR2PDE(virt),&pde,sizeof(pde))==sizeof(pde)?0:-1;
  1056a5:	8b 45 08             	mov    0x8(%ebp),%eax
  1056a8:	c1 e8 16             	shr    $0x16,%eax
  1056ab:	c1 e0 02             	shl    $0x2,%eax
  1056ae:	89 c2                	mov    %eax,%edx
  1056b0:	03 55 10             	add    0x10(%ebp),%edx
  1056b3:	c7 44 24 08 04 00 00 	movl   $0x4,0x8(%esp)
  1056ba:	00 
  1056bb:	8d 45 0c             	lea    0xc(%ebp),%eax
  1056be:	89 44 24 04          	mov    %eax,0x4(%esp)
  1056c2:	89 14 24             	mov    %edx,(%esp)
  1056c5:	e8 06 fc ff ff       	call   1052d0 <paging_physwrite>
  1056ca:	83 f8 04             	cmp    $0x4,%eax
  1056cd:	75 09                	jne    1056d8 <paging_setpde_pd+0x5a>
  1056cf:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
  1056d6:	eb 07                	jmp    1056df <paging_setpde_pd+0x61>
  1056d8:	c7 45 fc ff ff ff ff 	movl   $0xffffffff,-0x4(%ebp)
  1056df:	8b 45 fc             	mov    -0x4(%ebp),%eax
  1056e2:	89 45 f8             	mov    %eax,-0x8(%ebp)
  1056e5:	8b 45 f8             	mov    -0x8(%ebp),%eax
}
  1056e8:	c9                   	leave  
  1056e9:	c3                   	ret    

001056ea <paging_getpte_pd>:
 * Gets a PTE from not-loaded pagedir
 *  @param virt Virtual address
 *  @param pagedir Pagedir
 *  @return PTE
 */
pte_t paging_getpte_pd(void *virt,pd_t pagedir) {
  1056ea:	55                   	push   %ebp
  1056eb:	89 e5                	mov    %esp,%ebp
  1056ed:	83 ec 28             	sub    $0x28,%esp
  if (pagedir==paging_curpd) return paging_getpte(virt);
  1056f0:	a1 74 e4 10 00       	mov    0x10e474,%eax
  1056f5:	39 45 10             	cmp    %eax,0x10(%ebp)
  1056f8:	75 17                	jne    105711 <paging_getpte_pd+0x27>
  1056fa:	8b 45 0c             	mov    0xc(%ebp),%eax
  1056fd:	89 44 24 04          	mov    %eax,0x4(%esp)
  105701:	8b 45 08             	mov    0x8(%ebp),%eax
  105704:	89 04 24             	mov    %eax,(%esp)
  105707:	e8 d7 fd ff ff       	call   1054e3 <paging_getpte>
  10570c:	83 ec 04             	sub    $0x4,%esp
  10570f:	eb 7b                	jmp    10578c <paging_getpte_pd+0xa2>
  else {
    pt_t pt = PAGE2ADDR(paging_getpde_pd(virt,pagedir).page);
  105711:	8d 55 f8             	lea    -0x8(%ebp),%edx
  105714:	8b 45 10             	mov    0x10(%ebp),%eax
  105717:	89 44 24 08          	mov    %eax,0x8(%esp)
  10571b:	8b 45 0c             	mov    0xc(%ebp),%eax
  10571e:	89 44 24 04          	mov    %eax,0x4(%esp)
  105722:	89 14 24             	mov    %edx,(%esp)
  105725:	e8 fb fe ff ff       	call   105625 <paging_getpde_pd>
  10572a:	83 ec 04             	sub    $0x4,%esp
  10572d:	8b 45 f8             	mov    -0x8(%ebp),%eax
  105730:	c1 e8 0c             	shr    $0xc,%eax
  105733:	c1 e0 0c             	shl    $0xc,%eax
  105736:	89 45 fc             	mov    %eax,-0x4(%ebp)
    pte_t pte;
    if (pt==NULL) memset(&pte,0,sizeof(pte));
  105739:	83 7d fc 00          	cmpl   $0x0,-0x4(%ebp)
  10573d:	75 1d                	jne    10575c <paging_getpte_pd+0x72>
  10573f:	c7 44 24 08 04 00 00 	movl   $0x4,0x8(%esp)
  105746:	00 
  105747:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  10574e:	00 
  10574f:	8d 45 f4             	lea    -0xc(%ebp),%eax
  105752:	89 04 24             	mov    %eax,(%esp)
  105755:	e8 07 66 00 00       	call   10bd61 <memset>
  10575a:	eb 28                	jmp    105784 <paging_getpte_pd+0x9a>
    else paging_physread(&pte,pt+ADDR2PTE(virt),sizeof(pte));
  10575c:	8b 45 0c             	mov    0xc(%ebp),%eax
  10575f:	c1 e8 0c             	shr    $0xc,%eax
  105762:	25 ff 03 00 00       	and    $0x3ff,%eax
  105767:	c1 e0 02             	shl    $0x2,%eax
  10576a:	03 45 fc             	add    -0x4(%ebp),%eax
  10576d:	c7 44 24 08 04 00 00 	movl   $0x4,0x8(%esp)
  105774:	00 
  105775:	89 44 24 04          	mov    %eax,0x4(%esp)
  105779:	8d 45 f4             	lea    -0xc(%ebp),%eax
  10577c:	89 04 24             	mov    %eax,(%esp)
  10577f:	e8 97 fa ff ff       	call   10521b <paging_physread>
    return pte;
  105784:	8b 45 f4             	mov    -0xc(%ebp),%eax
  105787:	8b 55 08             	mov    0x8(%ebp),%edx
  10578a:	89 02                	mov    %eax,(%edx)
  }
}
  10578c:	8b 45 08             	mov    0x8(%ebp),%eax
  10578f:	c9                   	leave  
  105790:	c2 04 00             	ret    $0x4

00105793 <paging_setpte_pd>:
 *  @param virt Virtual address
 *  @param pte PTE
 *  @param pd pagedir
 *  @return 0=Success; -1=Failure
 */
int paging_setpte_pd(void *virt,pte_t pte,pd_t pagedir) {
  105793:	55                   	push   %ebp
  105794:	89 e5                	mov    %esp,%ebp
  105796:	83 ec 28             	sub    $0x28,%esp
  if (pagedir==paging_curpd) return paging_setpte(virt,pte);
  105799:	a1 74 e4 10 00       	mov    0x10e474,%eax
  10579e:	39 45 10             	cmp    %eax,0x10(%ebp)
  1057a1:	75 17                	jne    1057ba <paging_setpte_pd+0x27>
  1057a3:	8b 45 0c             	mov    0xc(%ebp),%eax
  1057a6:	89 44 24 04          	mov    %eax,0x4(%esp)
  1057aa:	8b 45 08             	mov    0x8(%ebp),%eax
  1057ad:	89 04 24             	mov    %eax,(%esp)
  1057b0:	e8 d3 fd ff ff       	call   105588 <paging_setpte>
  1057b5:	89 45 e8             	mov    %eax,-0x18(%ebp)
  1057b8:	eb 7e                	jmp    105838 <paging_setpte_pd+0xa5>
  else {
    pt_t pt = PAGE2ADDR(paging_getpde_pd(virt,pagedir).page);
  1057ba:	8d 55 f4             	lea    -0xc(%ebp),%edx
  1057bd:	8b 45 10             	mov    0x10(%ebp),%eax
  1057c0:	89 44 24 08          	mov    %eax,0x8(%esp)
  1057c4:	8b 45 08             	mov    0x8(%ebp),%eax
  1057c7:	89 44 24 04          	mov    %eax,0x4(%esp)
  1057cb:	89 14 24             	mov    %edx,(%esp)
  1057ce:	e8 52 fe ff ff       	call   105625 <paging_getpde_pd>
  1057d3:	83 ec 04             	sub    $0x4,%esp
  1057d6:	8b 45 f4             	mov    -0xc(%ebp),%eax
  1057d9:	c1 e8 0c             	shr    $0xc,%eax
  1057dc:	c1 e0 0c             	shl    $0xc,%eax
  1057df:	89 45 f8             	mov    %eax,-0x8(%ebp)
    int ret = paging_physwrite(pt+ADDR2PTE(virt),&pte,sizeof(pte))==sizeof(pte)?0:-1;
  1057e2:	8b 45 08             	mov    0x8(%ebp),%eax
  1057e5:	c1 e8 0c             	shr    $0xc,%eax
  1057e8:	25 ff 03 00 00       	and    $0x3ff,%eax
  1057ed:	c1 e0 02             	shl    $0x2,%eax
  1057f0:	89 c2                	mov    %eax,%edx
  1057f2:	03 55 f8             	add    -0x8(%ebp),%edx
  1057f5:	c7 44 24 08 04 00 00 	movl   $0x4,0x8(%esp)
  1057fc:	00 
  1057fd:	8d 45 0c             	lea    0xc(%ebp),%eax
  105800:	89 44 24 04          	mov    %eax,0x4(%esp)
  105804:	89 14 24             	mov    %edx,(%esp)
  105807:	e8 c4 fa ff ff       	call   1052d0 <paging_physwrite>
  10580c:	83 f8 04             	cmp    $0x4,%eax
  10580f:	75 09                	jne    10581a <paging_setpte_pd+0x87>
  105811:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
  105818:	eb 07                	jmp    105821 <paging_setpte_pd+0x8e>
  10581a:	c7 45 ec ff ff ff ff 	movl   $0xffffffff,-0x14(%ebp)
  105821:	8b 45 ec             	mov    -0x14(%ebp),%eax
  105824:	89 45 fc             	mov    %eax,-0x4(%ebp)
    paging_flushtlb(virt);
  105827:	8b 45 08             	mov    0x8(%ebp),%eax
  10582a:	89 04 24             	mov    %eax,(%esp)
  10582d:	e8 a8 fc ff ff       	call   1054da <paging_flushtlb>
    return ret;
  105832:	8b 45 fc             	mov    -0x4(%ebp),%eax
  105835:	89 45 e8             	mov    %eax,-0x18(%ebp)
  105838:	8b 45 e8             	mov    -0x18(%ebp),%eax
  }
}
  10583b:	c9                   	leave  
  10583c:	c3                   	ret    

0010583d <paging_map_pd>:
 *  @param swappable Whether page is swappable
 *  @param cow Whether page is COW
 *  @param pagedir Pagedir to do mapping in
 *  @return 0=Success; -1=Failure
 */
int paging_map_pd(void *virt,void *phys,int user,int writable,int swappable,int cow,pd_t pagedir) {
  10583d:	55                   	push   %ebp
  10583e:	89 e5                	mov    %esp,%ebp
  105840:	83 ec 28             	sub    $0x28,%esp
  if (!paging_getpde_pd(virt,pagedir).exists) {
  105843:	8d 55 f8             	lea    -0x8(%ebp),%edx
  105846:	8b 45 20             	mov    0x20(%ebp),%eax
  105849:	89 44 24 08          	mov    %eax,0x8(%esp)
  10584d:	8b 45 08             	mov    0x8(%ebp),%eax
  105850:	89 44 24 04          	mov    %eax,0x4(%esp)
  105854:	89 14 24             	mov    %edx,(%esp)
  105857:	e8 c9 fd ff ff       	call   105625 <paging_getpde_pd>
  10585c:	83 ec 04             	sub    $0x4,%esp
  10585f:	0f b6 45 f8          	movzbl -0x8(%ebp),%eax
  105863:	83 e0 01             	and    $0x1,%eax
  105866:	84 c0                	test   %al,%al
  105868:	0f 85 d8 00 00 00    	jne    105946 <paging_map_pd+0x109>
    pt_t pagetable = (pt_t)(PAGETABLES_ADDRESS+ADDR2PDE(virt)*PAGE_SIZE);
  10586e:	8b 45 08             	mov    0x8(%ebp),%eax
  105871:	c1 e8 16             	shr    $0x16,%eax
  105874:	c1 e0 0c             	shl    $0xc,%eax
  105877:	2d 00 00 40 00       	sub    $0x400000,%eax
  10587c:	89 45 fc             	mov    %eax,-0x4(%ebp)
    pde_t new;
    memset(&new,0,sizeof(new));
  10587f:	c7 44 24 08 04 00 00 	movl   $0x4,0x8(%esp)
  105886:	00 
  105887:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  10588e:	00 
  10588f:	8d 45 f0             	lea    -0x10(%ebp),%eax
  105892:	89 04 24             	mov    %eax,(%esp)
  105895:	e8 c7 64 00 00       	call   10bd61 <memset>
    new.page = ADDR2PAGE(memphys_alloc());
  10589a:	e8 16 dc ff ff       	call   1034b5 <memphys_pop>
  10589f:	c1 e8 0c             	shr    $0xc,%eax
  1058a2:	25 ff ff 0f 00       	and    $0xfffff,%eax
  1058a7:	89 c2                	mov    %eax,%edx
  1058a9:	c1 e2 0c             	shl    $0xc,%edx
  1058ac:	8b 45 f0             	mov    -0x10(%ebp),%eax
  1058af:	25 ff 0f 00 00       	and    $0xfff,%eax
  1058b4:	09 d0                	or     %edx,%eax
  1058b6:	89 45 f0             	mov    %eax,-0x10(%ebp)
    new.pagesize = PGSIZE_4K;
  1058b9:	0f b6 45 f0          	movzbl -0x10(%ebp),%eax
  1058bd:	83 e0 7f             	and    $0x7f,%eax
  1058c0:	88 45 f0             	mov    %al,-0x10(%ebp)
    new.user = 1;
  1058c3:	0f b6 45 f0          	movzbl -0x10(%ebp),%eax
  1058c7:	83 c8 04             	or     $0x4,%eax
  1058ca:	88 45 f0             	mov    %al,-0x10(%ebp)
    new.writable = 1;
  1058cd:	0f b6 45 f0          	movzbl -0x10(%ebp),%eax
  1058d1:	83 c8 02             	or     $0x2,%eax
  1058d4:	88 45 f0             	mov    %al,-0x10(%ebp)
    new.exists = 1;
  1058d7:	0f b6 45 f0          	movzbl -0x10(%ebp),%eax
  1058db:	83 c8 01             	or     $0x1,%eax
  1058de:	88 45 f0             	mov    %al,-0x10(%ebp)
    if (paging_setpde_pd(virt,new,pagedir)<0) return -1;
  1058e1:	8b 45 20             	mov    0x20(%ebp),%eax
  1058e4:	89 44 24 08          	mov    %eax,0x8(%esp)
  1058e8:	8b 45 f0             	mov    -0x10(%ebp),%eax
  1058eb:	89 44 24 04          	mov    %eax,0x4(%esp)
  1058ef:	8b 45 08             	mov    0x8(%ebp),%eax
  1058f2:	89 04 24             	mov    %eax,(%esp)
  1058f5:	e8 84 fd ff ff       	call   10567e <paging_setpde_pd>
  1058fa:	85 c0                	test   %eax,%eax
  1058fc:	79 0c                	jns    10590a <paging_map_pd+0xcd>
  1058fe:	c7 45 ec ff ff ff ff 	movl   $0xffffffff,-0x14(%ebp)
  105905:	e9 48 01 00 00       	jmp    105a52 <paging_map_pd+0x215>
    paging_flushtlb(pagetable);
  10590a:	8b 45 fc             	mov    -0x4(%ebp),%eax
  10590d:	89 04 24             	mov    %eax,(%esp)
  105910:	e8 c5 fb ff ff       	call   1054da <paging_flushtlb>
    memset(pagetable,0,PAGE_SIZE);
  105915:	c7 44 24 08 00 10 00 	movl   $0x1000,0x8(%esp)
  10591c:	00 
  10591d:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  105924:	00 
  105925:	8b 45 fc             	mov    -0x4(%ebp),%eax
  105928:	89 04 24             	mov    %eax,(%esp)
  10592b:	e8 31 64 00 00       	call   10bd61 <memset>
    if (pagedir!=paging_curpd) kprintf("kernel: new pagetable\n");
  105930:	a1 74 e4 10 00       	mov    0x10e474,%eax
  105935:	39 45 20             	cmp    %eax,0x20(%ebp)
  105938:	74 0c                	je     105946 <paging_map_pd+0x109>
  10593a:	c7 04 24 7a d6 10 00 	movl   $0x10d67a,(%esp)
  105941:	e8 55 ca ff ff       	call   10239b <kprintf>
  }
  pte_t new;
  memset(&new,0,sizeof(new));
  105946:	c7 44 24 08 04 00 00 	movl   $0x4,0x8(%esp)
  10594d:	00 
  10594e:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  105955:	00 
  105956:	8d 45 f4             	lea    -0xc(%ebp),%eax
  105959:	89 04 24             	mov    %eax,(%esp)
  10595c:	e8 00 64 00 00       	call   10bd61 <memset>
  new.page = ADDR2PAGE(phys);
  105961:	8b 45 0c             	mov    0xc(%ebp),%eax
  105964:	c1 e8 0c             	shr    $0xc,%eax
  105967:	25 ff ff 0f 00       	and    $0xfffff,%eax
  10596c:	89 c2                	mov    %eax,%edx
  10596e:	c1 e2 0c             	shl    $0xc,%edx
  105971:	8b 45 f4             	mov    -0xc(%ebp),%eax
  105974:	25 ff 0f 00 00       	and    $0xfff,%eax
  105979:	09 d0                	or     %edx,%eax
  10597b:	89 45 f4             	mov    %eax,-0xc(%ebp)
  new.exists = 1;
  10597e:	0f b6 45 f5          	movzbl -0xb(%ebp),%eax
  105982:	83 c8 02             	or     $0x2,%eax
  105985:	88 45 f5             	mov    %al,-0xb(%ebp)
  new.user = user?1:0;
  105988:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
  10598c:	0f 95 c0             	setne  %al
  10598f:	83 e0 01             	and    $0x1,%eax
  105992:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
  105999:	0f b6 45 f4          	movzbl -0xc(%ebp),%eax
  10599d:	83 e0 fb             	and    $0xfffffffb,%eax
  1059a0:	09 d0                	or     %edx,%eax
  1059a2:	88 45 f4             	mov    %al,-0xc(%ebp)
  new.writable = writable?1:0;
  1059a5:	83 7d 14 00          	cmpl   $0x0,0x14(%ebp)
  1059a9:	0f 95 c0             	setne  %al
  1059ac:	83 e0 01             	and    $0x1,%eax
  1059af:	8d 14 00             	lea    (%eax,%eax,1),%edx
  1059b2:	0f b6 45 f4          	movzbl -0xc(%ebp),%eax
  1059b6:	83 e0 fd             	and    $0xfffffffd,%eax
  1059b9:	09 d0                	or     %edx,%eax
  1059bb:	88 45 f4             	mov    %al,-0xc(%ebp)
  new.in_memory = 1;
  1059be:	0f b6 45 f4          	movzbl -0xc(%ebp),%eax
  1059c2:	83 c8 01             	or     $0x1,%eax
  1059c5:	88 45 f4             	mov    %al,-0xc(%ebp)
  new.swappable = swappable;
  1059c8:	8b 45 18             	mov    0x18(%ebp),%eax
  1059cb:	83 e0 01             	and    $0x1,%eax
  1059ce:	83 e0 01             	and    $0x1,%eax
  1059d1:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
  1059d8:	0f b6 45 f5          	movzbl -0xb(%ebp),%eax
  1059dc:	83 e0 fb             	and    $0xfffffffb,%eax
  1059df:	09 d0                	or     %edx,%eax
  1059e1:	88 45 f5             	mov    %al,-0xb(%ebp)
  new.cow = cow;
  1059e4:	8b 45 1c             	mov    0x1c(%ebp),%eax
  1059e7:	83 e0 01             	and    $0x1,%eax
  1059ea:	89 c2                	mov    %eax,%edx
  1059ec:	c1 e2 07             	shl    $0x7,%edx
  1059ef:	0f b6 45 f4          	movzbl -0xc(%ebp),%eax
  1059f3:	83 e0 7f             	and    $0x7f,%eax
  1059f6:	09 d0                	or     %edx,%eax
  1059f8:	88 45 f4             	mov    %al,-0xc(%ebp)
  if (paging_setpte_pd(virt,new,pagedir)<0) return -1;
  1059fb:	8b 45 20             	mov    0x20(%ebp),%eax
  1059fe:	89 44 24 08          	mov    %eax,0x8(%esp)
  105a02:	8b 45 f4             	mov    -0xc(%ebp),%eax
  105a05:	89 44 24 04          	mov    %eax,0x4(%esp)
  105a09:	8b 45 08             	mov    0x8(%ebp),%eax
  105a0c:	89 04 24             	mov    %eax,(%esp)
  105a0f:	e8 7f fd ff ff       	call   105793 <paging_setpte_pd>
  105a14:	85 c0                	test   %eax,%eax
  105a16:	79 09                	jns    105a21 <paging_map_pd+0x1e4>
  105a18:	c7 45 ec ff ff ff ff 	movl   $0xffffffff,-0x14(%ebp)
  105a1f:	eb 31                	jmp    105a52 <paging_map_pd+0x215>
  if (pagedir!=paging_curpd) {
  105a21:	a1 74 e4 10 00       	mov    0x10e474,%eax
  105a26:	39 45 20             	cmp    %eax,0x20(%ebp)
  105a29:	74 20                	je     105a4b <paging_map_pd+0x20e>
    kprintf("kernel: mapped 0x%x to 0x%x\n",virt,PAGE2ADDR(new.page));
  105a2b:	8b 45 f4             	mov    -0xc(%ebp),%eax
  105a2e:	c1 e8 0c             	shr    $0xc,%eax
  105a31:	c1 e0 0c             	shl    $0xc,%eax
  105a34:	89 44 24 08          	mov    %eax,0x8(%esp)
  105a38:	8b 45 08             	mov    0x8(%ebp),%eax
  105a3b:	89 44 24 04          	mov    %eax,0x4(%esp)
  105a3f:	c7 04 24 91 d6 10 00 	movl   $0x10d691,(%esp)
  105a46:	e8 50 c9 ff ff       	call   10239b <kprintf>
  }
  return 0;
  105a4b:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
  105a52:	8b 45 ec             	mov    -0x14(%ebp),%eax
}
  105a55:	c9                   	leave  
  105a56:	c3                   	ret    

00105a57 <paging_unmap>:
/**
 * Unmaps a page and returns physical address of it
 *  @param virt Virtual address
 *  @return Physical address
 */
void *paging_unmap(void *virt) {
  105a57:	55                   	push   %ebp
  105a58:	89 e5                	mov    %esp,%ebp
  105a5a:	83 ec 28             	sub    $0x28,%esp
  void *addr = PAGE2ADDR(paging_getpte(virt).page);
  105a5d:	8d 55 f8             	lea    -0x8(%ebp),%edx
  105a60:	8b 45 08             	mov    0x8(%ebp),%eax
  105a63:	89 44 24 04          	mov    %eax,0x4(%esp)
  105a67:	89 14 24             	mov    %edx,(%esp)
  105a6a:	e8 74 fa ff ff       	call   1054e3 <paging_getpte>
  105a6f:	83 ec 04             	sub    $0x4,%esp
  105a72:	8b 45 f8             	mov    -0x8(%ebp),%eax
  105a75:	c1 e8 0c             	shr    $0xc,%eax
  105a78:	c1 e0 0c             	shl    $0xc,%eax
  105a7b:	89 45 fc             	mov    %eax,-0x4(%ebp)
  pte_t pte;
  if (!pte.in_memory) addr = NULL;
  105a7e:	0f b6 45 f4          	movzbl -0xc(%ebp),%eax
  105a82:	83 e0 01             	and    $0x1,%eax
  105a85:	84 c0                	test   %al,%al
  105a87:	75 07                	jne    105a90 <paging_unmap+0x39>
  105a89:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
  memset(&pte,0,sizeof(pte));
  105a90:	c7 44 24 08 04 00 00 	movl   $0x4,0x8(%esp)
  105a97:	00 
  105a98:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  105a9f:	00 
  105aa0:	8d 45 f4             	lea    -0xc(%ebp),%eax
  105aa3:	89 04 24             	mov    %eax,(%esp)
  105aa6:	e8 b6 62 00 00       	call   10bd61 <memset>
  paging_setpte(virt,pte);
  105aab:	8b 45 f4             	mov    -0xc(%ebp),%eax
  105aae:	89 44 24 04          	mov    %eax,0x4(%esp)
  105ab2:	8b 45 08             	mov    0x8(%ebp),%eax
  105ab5:	89 04 24             	mov    %eax,(%esp)
  105ab8:	e8 cb fa ff ff       	call   105588 <paging_setpte>
  return addr;
  105abd:	8b 45 fc             	mov    -0x4(%ebp),%eax
}
  105ac0:	c9                   	leave  
  105ac1:	c3                   	ret    

00105ac2 <paging_getphysaddr>:
/**
 * Gets physical address
 *  @param virt Virtual address
 *  @return Physical address
 */
void *paging_getphysaddr(void *virt) {
  105ac2:	55                   	push   %ebp
  105ac3:	89 e5                	mov    %esp,%ebp
  105ac5:	83 ec 28             	sub    $0x28,%esp
  pte_t pte = paging_getpte(virt);
  105ac8:	8d 55 fc             	lea    -0x4(%ebp),%edx
  105acb:	8b 45 08             	mov    0x8(%ebp),%eax
  105ace:	89 44 24 04          	mov    %eax,0x4(%esp)
  105ad2:	89 14 24             	mov    %edx,(%esp)
  105ad5:	e8 09 fa ff ff       	call   1054e3 <paging_getpte>
  105ada:	83 ec 04             	sub    $0x4,%esp
  if (pte.exists && pte.in_memory) return PAGE2ADDR(pte.page)+PAGEOFF(virt);
  105add:	0f b6 45 fd          	movzbl -0x3(%ebp),%eax
  105ae1:	83 e0 02             	and    $0x2,%eax
  105ae4:	84 c0                	test   %al,%al
  105ae6:	74 27                	je     105b0f <paging_getphysaddr+0x4d>
  105ae8:	0f b6 45 fc          	movzbl -0x4(%ebp),%eax
  105aec:	83 e0 01             	and    $0x1,%eax
  105aef:	84 c0                	test   %al,%al
  105af1:	74 1c                	je     105b0f <paging_getphysaddr+0x4d>
  105af3:	8b 45 08             	mov    0x8(%ebp),%eax
  105af6:	89 c2                	mov    %eax,%edx
  105af8:	81 e2 ff 0f 00 00    	and    $0xfff,%edx
  105afe:	8b 45 fc             	mov    -0x4(%ebp),%eax
  105b01:	c1 e8 0c             	shr    $0xc,%eax
  105b04:	c1 e0 0c             	shl    $0xc,%eax
  105b07:	8d 04 02             	lea    (%edx,%eax,1),%eax
  105b0a:	89 45 ec             	mov    %eax,-0x14(%ebp)
  105b0d:	eb 07                	jmp    105b16 <paging_getphysaddr+0x54>
  else return NULL;
  105b0f:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
  105b16:	8b 45 ec             	mov    -0x14(%ebp),%eax
}
  105b19:	c9                   	leave  
  105b1a:	c3                   	ret    
	...

00105b1c <pic_init>:
*/

#include <pic.h>
#include <ioport.h>

int pic_init() {
  105b1c:	55                   	push   %ebp
  105b1d:	89 e5                	mov    %esp,%ebp
  105b1f:	83 ec 18             	sub    $0x18,%esp
  int offset1 = 0x20;
  105b22:	c7 45 f4 20 00 00 00 	movl   $0x20,-0xc(%ebp)
  int offset2 = 0x28;
  105b29:	c7 45 f8 28 00 00 00 	movl   $0x28,-0x8(%ebp)
  char a1,a2;
  a1 = inb(PIC1_DATA);                     // save masks
  105b30:	c7 04 24 21 00 00 00 	movl   $0x21,(%esp)
  105b37:	e8 eb 00 00 00       	call   105c27 <inb>
  105b3c:	88 45 fe             	mov    %al,-0x2(%ebp)
  a2 = inb(PIC2_DATA);
  105b3f:	c7 04 24 a1 00 00 00 	movl   $0xa1,(%esp)
  105b46:	e8 dc 00 00 00       	call   105c27 <inb>
  105b4b:	88 45 ff             	mov    %al,-0x1(%ebp)

  outb(PIC1_COMMAND,ICW1_INIT+ICW1_ICW4);  // starts the initialization sequence
  105b4e:	c7 44 24 04 11 00 00 	movl   $0x11,0x4(%esp)
  105b55:	00 
  105b56:	c7 04 24 20 00 00 00 	movl   $0x20,(%esp)
  105b5d:	e8 e0 00 00 00       	call   105c42 <outb>
  outb(PIC2_COMMAND,ICW1_INIT+ICW1_ICW4);
  105b62:	c7 44 24 04 11 00 00 	movl   $0x11,0x4(%esp)
  105b69:	00 
  105b6a:	c7 04 24 a0 00 00 00 	movl   $0xa0,(%esp)
  105b71:	e8 cc 00 00 00       	call   105c42 <outb>
  outb(PIC1_DATA,offset1);                 // define the PIC vectors
  105b76:	8b 45 f4             	mov    -0xc(%ebp),%eax
  105b79:	0f b6 c0             	movzbl %al,%eax
  105b7c:	89 44 24 04          	mov    %eax,0x4(%esp)
  105b80:	c7 04 24 21 00 00 00 	movl   $0x21,(%esp)
  105b87:	e8 b6 00 00 00       	call   105c42 <outb>
  outb(PIC2_DATA,offset2);
  105b8c:	8b 45 f8             	mov    -0x8(%ebp),%eax
  105b8f:	0f b6 c0             	movzbl %al,%eax
  105b92:	89 44 24 04          	mov    %eax,0x4(%esp)
  105b96:	c7 04 24 a1 00 00 00 	movl   $0xa1,(%esp)
  105b9d:	e8 a0 00 00 00       	call   105c42 <outb>
  outb(PIC1_DATA,4);                       // continue initialization sequence
  105ba2:	c7 44 24 04 04 00 00 	movl   $0x4,0x4(%esp)
  105ba9:	00 
  105baa:	c7 04 24 21 00 00 00 	movl   $0x21,(%esp)
  105bb1:	e8 8c 00 00 00       	call   105c42 <outb>
  outb(PIC2_DATA,2);
  105bb6:	c7 44 24 04 02 00 00 	movl   $0x2,0x4(%esp)
  105bbd:	00 
  105bbe:	c7 04 24 a1 00 00 00 	movl   $0xa1,(%esp)
  105bc5:	e8 78 00 00 00       	call   105c42 <outb>
  outb(PIC1_DATA,ICW4_8086);
  105bca:	c7 44 24 04 01 00 00 	movl   $0x1,0x4(%esp)
  105bd1:	00 
  105bd2:	c7 04 24 21 00 00 00 	movl   $0x21,(%esp)
  105bd9:	e8 64 00 00 00       	call   105c42 <outb>
  outb(PIC2_DATA,ICW4_8086);
  105bde:	c7 44 24 04 01 00 00 	movl   $0x1,0x4(%esp)
  105be5:	00 
  105be6:	c7 04 24 a1 00 00 00 	movl   $0xa1,(%esp)
  105bed:	e8 50 00 00 00       	call   105c42 <outb>

  outb(PIC1_DATA,a1);   // restore saved masks.
  105bf2:	0f b6 45 fe          	movzbl -0x2(%ebp),%eax
  105bf6:	0f b6 c0             	movzbl %al,%eax
  105bf9:	89 44 24 04          	mov    %eax,0x4(%esp)
  105bfd:	c7 04 24 21 00 00 00 	movl   $0x21,(%esp)
  105c04:	e8 39 00 00 00       	call   105c42 <outb>
  outb(PIC2_DATA,a2);
  105c09:	0f b6 45 ff          	movzbl -0x1(%ebp),%eax
  105c0d:	0f b6 c0             	movzbl %al,%eax
  105c10:	89 44 24 04          	mov    %eax,0x4(%esp)
  105c14:	c7 04 24 a1 00 00 00 	movl   $0xa1,(%esp)
  105c1b:	e8 22 00 00 00       	call   105c42 <outb>

  return 0;
  105c20:	b8 00 00 00 00       	mov    $0x0,%eax
}
  105c25:	c9                   	leave  
  105c26:	c3                   	ret    

00105c27 <inb>:

#define IOPORT_MAXNUM 0x10000

int *iopb_general;

static inline uint8_t inb(uint16_t _port) {
  105c27:	55                   	push   %ebp
  105c28:	89 e5                	mov    %esp,%ebp
  105c2a:	83 ec 14             	sub    $0x14,%esp
  105c2d:	8b 45 08             	mov    0x8(%ebp),%eax
  105c30:	66 89 45 ec          	mov    %ax,-0x14(%ebp)
  uint8_t _result;
  __asm__("inb %1, %0":"=a"(_result):"Nd"(_port));
  105c34:	0f b7 55 ec          	movzwl -0x14(%ebp),%edx
  105c38:	ec                   	in     (%dx),%al
  105c39:	88 45 ff             	mov    %al,-0x1(%ebp)
  return _result;
  105c3c:	0f b6 45 ff          	movzbl -0x1(%ebp),%eax
}
  105c40:	c9                   	leave  
  105c41:	c3                   	ret    

00105c42 <outb>:

static inline void outw(uint16_t _port,uint16_t _data) {
  __asm__("outw %0, %1"::"a"(_data),"Nd"(_port));
}

static inline void outb(uint16_t _port,uint8_t _data) {
  105c42:	55                   	push   %ebp
  105c43:	89 e5                	mov    %esp,%ebp
  105c45:	83 ec 08             	sub    $0x8,%esp
  105c48:	8b 45 08             	mov    0x8(%ebp),%eax
  105c4b:	8b 55 0c             	mov    0xc(%ebp),%edx
  105c4e:	66 89 45 fc          	mov    %ax,-0x4(%ebp)
  105c52:	88 55 f8             	mov    %dl,-0x8(%ebp)
  __asm__("outb %0, %1"::"a"(_data),"Nd"(_port));
  105c55:	0f b6 45 f8          	movzbl -0x8(%ebp),%eax
  105c59:	0f b7 55 fc          	movzwl -0x4(%ebp),%edx
  105c5d:	ee                   	out    %al,(%dx)
}
  105c5e:	c9                   	leave  
  105c5f:	c3                   	ret    

00105c60 <pic_getmask>:
/**
 * Gets IRQ mask
 *  @param irq IRQ
 *  @return IRQ mask
 */
unsigned int pic_getmask(int irq) {
  105c60:	55                   	push   %ebp
  105c61:	89 e5                	mov    %esp,%ebp
  105c63:	83 ec 14             	sub    $0x14,%esp
  unsigned int mask = inb(PIC1_DATA);
  105c66:	c7 04 24 21 00 00 00 	movl   $0x21,(%esp)
  105c6d:	e8 b5 ff ff ff       	call   105c27 <inb>
  105c72:	0f b6 c0             	movzbl %al,%eax
  105c75:	89 45 fc             	mov    %eax,-0x4(%ebp)
  mask |= inb(PIC2_DATA)<<8;
  105c78:	c7 04 24 a1 00 00 00 	movl   $0xa1,(%esp)
  105c7f:	e8 a3 ff ff ff       	call   105c27 <inb>
  105c84:	0f b6 c0             	movzbl %al,%eax
  105c87:	c1 e0 08             	shl    $0x8,%eax
  105c8a:	09 45 fc             	or     %eax,-0x4(%ebp)
  return mask;
  105c8d:	8b 45 fc             	mov    -0x4(%ebp),%eax
}
  105c90:	c9                   	leave  
  105c91:	c3                   	ret    

00105c92 <pic_setmask>:
/**
 * Sets IRQ mask
 *  @param irq IRQ
 *  @param mask IRQ mask
 */
void pic_setmask(int irq,unsigned int mask) {
  105c92:	55                   	push   %ebp
  105c93:	89 e5                	mov    %esp,%ebp
  105c95:	83 ec 08             	sub    $0x8,%esp
  outb(PIC1_DATA,mask);
  105c98:	8b 45 0c             	mov    0xc(%ebp),%eax
  105c9b:	0f b6 c0             	movzbl %al,%eax
  105c9e:	89 44 24 04          	mov    %eax,0x4(%esp)
  105ca2:	c7 04 24 21 00 00 00 	movl   $0x21,(%esp)
  105ca9:	e8 94 ff ff ff       	call   105c42 <outb>
  outb(PIC2_DATA,mask>>8);
  105cae:	8b 45 0c             	mov    0xc(%ebp),%eax
  105cb1:	c1 e8 08             	shr    $0x8,%eax
  105cb4:	0f b6 c0             	movzbl %al,%eax
  105cb7:	89 44 24 04          	mov    %eax,0x4(%esp)
  105cbb:	c7 04 24 a1 00 00 00 	movl   $0xa1,(%esp)
  105cc2:	e8 7b ff ff ff       	call   105c42 <outb>
}
  105cc7:	c9                   	leave  
  105cc8:	c3                   	ret    

00105cc9 <pic_eoi>:

/**
 * Sends EOI to PIC
 *  @param irq IRQ
 */
void pic_eoi(int irq) {
  105cc9:	55                   	push   %ebp
  105cca:	89 e5                	mov    %esp,%ebp
  105ccc:	83 ec 08             	sub    $0x8,%esp
  if (irq>=8) outb(PIC2_COMMAND,PIC_EOI);
  105ccf:	83 7d 08 07          	cmpl   $0x7,0x8(%ebp)
  105cd3:	7e 14                	jle    105ce9 <pic_eoi+0x20>
  105cd5:	c7 44 24 04 20 00 00 	movl   $0x20,0x4(%esp)
  105cdc:	00 
  105cdd:	c7 04 24 a0 00 00 00 	movl   $0xa0,(%esp)
  105ce4:	e8 59 ff ff ff       	call   105c42 <outb>
  outb(PIC1_COMMAND,PIC_EOI);
  105ce9:	c7 44 24 04 20 00 00 	movl   $0x20,0x4(%esp)
  105cf0:	00 
  105cf1:	c7 04 24 20 00 00 00 	movl   $0x20,(%esp)
  105cf8:	e8 45 ff ff ff       	call   105c42 <outb>
}
  105cfd:	c9                   	leave  
  105cfe:	c3                   	ret    

00105cff <pic_pit_setinterval>:
 * Sets interval of PIT
 *  @param interval Interval
 *  @param channel Channel
 *  @return 0=Success; -1=Failure
 */
int pic_pit_setinterval(int channel,unsigned int interval) {
  105cff:	55                   	push   %ebp
  105d00:	89 e5                	mov    %esp,%ebp
  105d02:	83 ec 20             	sub    $0x20,%esp
  unsigned int val = PIT_FREQ*interval/1000;
  105d05:	8b 45 0c             	mov    0xc(%ebp),%eax
  105d08:	69 d0 dc 34 12 00    	imul   $0x1234dc,%eax,%edx
  105d0e:	c7 45 e8 d3 4d 62 10 	movl   $0x10624dd3,-0x18(%ebp)
  105d15:	8b 45 e8             	mov    -0x18(%ebp),%eax
  105d18:	f7 e2                	mul    %edx
  105d1a:	89 d0                	mov    %edx,%eax
  105d1c:	c1 e8 06             	shr    $0x6,%eax
  105d1f:	89 45 fc             	mov    %eax,-0x4(%ebp)
  if (channel<4) {
  105d22:	83 7d 08 03          	cmpl   $0x3,0x8(%ebp)
  105d26:	7f 42                	jg     105d6a <pic_pit_setinterval+0x6b>
    outb(PIT_CHANNELS+channel,val);
  105d28:	8b 45 fc             	mov    -0x4(%ebp),%eax
  105d2b:	0f b6 d0             	movzbl %al,%edx
  105d2e:	8b 45 08             	mov    0x8(%ebp),%eax
  105d31:	83 c0 40             	add    $0x40,%eax
  105d34:	0f b7 c0             	movzwl %ax,%eax
  105d37:	89 54 24 04          	mov    %edx,0x4(%esp)
  105d3b:	89 04 24             	mov    %eax,(%esp)
  105d3e:	e8 ff fe ff ff       	call   105c42 <outb>
    outb(PIT_CHANNELS+channel,(val>>8));
  105d43:	8b 45 fc             	mov    -0x4(%ebp),%eax
  105d46:	c1 e8 08             	shr    $0x8,%eax
  105d49:	0f b6 d0             	movzbl %al,%edx
  105d4c:	8b 45 08             	mov    0x8(%ebp),%eax
  105d4f:	83 c0 40             	add    $0x40,%eax
  105d52:	0f b7 c0             	movzwl %ax,%eax
  105d55:	89 54 24 04          	mov    %edx,0x4(%esp)
  105d59:	89 04 24             	mov    %eax,(%esp)
  105d5c:	e8 e1 fe ff ff       	call   105c42 <outb>
    return 0;
  105d61:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
  105d68:	eb 07                	jmp    105d71 <pic_pit_setinterval+0x72>
  }
  else return -1;
  105d6a:	c7 45 ec ff ff ff ff 	movl   $0xffffffff,-0x14(%ebp)
  105d71:	8b 45 ec             	mov    -0x14(%ebp),%eax
}
  105d74:	c9                   	leave  
  105d75:	c3                   	ret    
	...

00105d78 <proc_init>:

/**
 * Initializes process management
 *  @return -1=Success; 0=Failure
 */
int proc_init() {
  105d78:	55                   	push   %ebp
  105d79:	89 e5                	mov    %esp,%ebp
  105d7b:	83 ec 18             	sub    $0x18,%esp
  proc_all = llist_create();
  105d7e:	e8 51 4b 00 00       	call   10a8d4 <llist_create>
  105d83:	a3 80 e1 10 00       	mov    %eax,0x10e180
  proc_running = llist_create();
  105d88:	e8 47 4b 00 00       	call   10a8d4 <llist_create>
  105d8d:	a3 9c e1 10 00       	mov    %eax,0x10e19c
  proc_sleeping = llist_create();
  105d92:	e8 3d 4b 00 00       	call   10a8d4 <llist_create>
  105d97:	a3 50 e4 10 00       	mov    %eax,0x10e450
  proc_nextpid = 1;
  105d9c:	c7 05 60 e4 10 00 01 	movl   $0x1,0x10e460
  105da3:	00 00 00 
  proc_current = NULL;
  105da6:	c7 05 a0 e1 10 00 00 	movl   $0x0,0x10e1a0
  105dad:	00 00 00 
  if (syscall_create(SYSCALL_PROC_GETPID,proc_getpid,0)==-1) return -1;
  105db0:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  105db7:	00 
  105db8:	c7 44 24 04 25 6a 10 	movl   $0x106a25,0x4(%esp)
  105dbf:	00 
  105dc0:	c7 04 24 28 00 00 00 	movl   $0x28,(%esp)
  105dc7:	e8 6e 40 00 00       	call   109e3a <syscall_create>
  105dcc:	83 f8 ff             	cmp    $0xffffffff,%eax
  105dcf:	75 0c                	jne    105ddd <proc_init+0x65>
  105dd1:	c7 45 fc ff ff ff ff 	movl   $0xffffffff,-0x4(%ebp)
  105dd8:	e9 90 04 00 00       	jmp    10626d <proc_init+0x4f5>
  if (syscall_create(SYSCALL_PROC_GETUID,proc_getuid,1)==-1) return -1;
  105ddd:	c7 44 24 08 01 00 00 	movl   $0x1,0x8(%esp)
  105de4:	00 
  105de5:	c7 44 24 04 d2 6a 10 	movl   $0x106ad2,0x4(%esp)
  105dec:	00 
  105ded:	c7 04 24 29 00 00 00 	movl   $0x29,(%esp)
  105df4:	e8 41 40 00 00       	call   109e3a <syscall_create>
  105df9:	83 f8 ff             	cmp    $0xffffffff,%eax
  105dfc:	75 0c                	jne    105e0a <proc_init+0x92>
  105dfe:	c7 45 fc ff ff ff ff 	movl   $0xffffffff,-0x4(%ebp)
  105e05:	e9 63 04 00 00       	jmp    10626d <proc_init+0x4f5>
  if (syscall_create(SYSCALL_PROC_GETGID,proc_getgid,1)==-1) return -1;
  105e0a:	c7 44 24 08 01 00 00 	movl   $0x1,0x8(%esp)
  105e11:	00 
  105e12:	c7 44 24 04 74 6b 10 	movl   $0x106b74,0x4(%esp)
  105e19:	00 
  105e1a:	c7 04 24 2a 00 00 00 	movl   $0x2a,(%esp)
  105e21:	e8 14 40 00 00       	call   109e3a <syscall_create>
  105e26:	83 f8 ff             	cmp    $0xffffffff,%eax
  105e29:	75 0c                	jne    105e37 <proc_init+0xbf>
  105e2b:	c7 45 fc ff ff ff ff 	movl   $0xffffffff,-0x4(%ebp)
  105e32:	e9 36 04 00 00       	jmp    10626d <proc_init+0x4f5>
  if (syscall_create(SYSCALL_PROC_SETUID,proc_setuid,2)==-1) return -1;
  105e37:	c7 44 24 08 02 00 00 	movl   $0x2,0x8(%esp)
  105e3e:	00 
  105e3f:	c7 44 24 04 29 6b 10 	movl   $0x106b29,0x4(%esp)
  105e46:	00 
  105e47:	c7 04 24 2b 00 00 00 	movl   $0x2b,(%esp)
  105e4e:	e8 e7 3f 00 00       	call   109e3a <syscall_create>
  105e53:	83 f8 ff             	cmp    $0xffffffff,%eax
  105e56:	75 0c                	jne    105e64 <proc_init+0xec>
  105e58:	c7 45 fc ff ff ff ff 	movl   $0xffffffff,-0x4(%ebp)
  105e5f:	e9 09 04 00 00       	jmp    10626d <proc_init+0x4f5>
  if (syscall_create(SYSCALL_PROC_SETGID,proc_setgid,2)==-1) return -1;
  105e64:	c7 44 24 08 02 00 00 	movl   $0x2,0x8(%esp)
  105e6b:	00 
  105e6c:	c7 44 24 04 cb 6b 10 	movl   $0x106bcb,0x4(%esp)
  105e73:	00 
  105e74:	c7 04 24 2c 00 00 00 	movl   $0x2c,(%esp)
  105e7b:	e8 ba 3f 00 00       	call   109e3a <syscall_create>
  105e80:	83 f8 ff             	cmp    $0xffffffff,%eax
  105e83:	75 0c                	jne    105e91 <proc_init+0x119>
  105e85:	c7 45 fc ff ff ff ff 	movl   $0xffffffff,-0x4(%ebp)
  105e8c:	e9 dc 03 00 00       	jmp    10626d <proc_init+0x4f5>
  if (syscall_create(SYSCALL_PROC_GETPARENT,proc_getparent,1)==-1) return -1;
  105e91:	c7 44 24 08 01 00 00 	movl   $0x1,0x8(%esp)
  105e98:	00 
  105e99:	c7 44 24 04 31 6a 10 	movl   $0x106a31,0x4(%esp)
  105ea0:	00 
  105ea1:	c7 04 24 2d 00 00 00 	movl   $0x2d,(%esp)
  105ea8:	e8 8d 3f 00 00       	call   109e3a <syscall_create>
  105ead:	83 f8 ff             	cmp    $0xffffffff,%eax
  105eb0:	75 0c                	jne    105ebe <proc_init+0x146>
  105eb2:	c7 45 fc ff ff ff ff 	movl   $0xffffffff,-0x4(%ebp)
  105eb9:	e9 af 03 00 00       	jmp    10626d <proc_init+0x4f5>
  if (syscall_create(SYSCALL_PROC_GETCHILD,proc_getchild,2)==-1) return -1;
  105ebe:	c7 44 24 08 02 00 00 	movl   $0x2,0x8(%esp)
  105ec5:	00 
  105ec6:	c7 44 24 04 6e 6a 10 	movl   $0x106a6e,0x4(%esp)
  105ecd:	00 
  105ece:	c7 04 24 2e 00 00 00 	movl   $0x2e,(%esp)
  105ed5:	e8 60 3f 00 00       	call   109e3a <syscall_create>
  105eda:	83 f8 ff             	cmp    $0xffffffff,%eax
  105edd:	75 0c                	jne    105eeb <proc_init+0x173>
  105edf:	c7 45 fc ff ff ff ff 	movl   $0xffffffff,-0x4(%ebp)
  105ee6:	e9 82 03 00 00       	jmp    10626d <proc_init+0x4f5>
  if (syscall_create(SYSCALL_PROC_GETNAME,proc_getname,3)==-1) return -1;
  105eeb:	c7 44 24 08 03 00 00 	movl   $0x3,0x8(%esp)
  105ef2:	00 
  105ef3:	c7 44 24 04 16 6c 10 	movl   $0x106c16,0x4(%esp)
  105efa:	00 
  105efb:	c7 04 24 2f 00 00 00 	movl   $0x2f,(%esp)
  105f02:	e8 33 3f 00 00       	call   109e3a <syscall_create>
  105f07:	83 f8 ff             	cmp    $0xffffffff,%eax
  105f0a:	75 0c                	jne    105f18 <proc_init+0x1a0>
  105f0c:	c7 45 fc ff ff ff ff 	movl   $0xffffffff,-0x4(%ebp)
  105f13:	e9 55 03 00 00       	jmp    10626d <proc_init+0x4f5>
  if (syscall_create(SYSCALL_PROC_SETNAME,proc_setname,2)==-1) return -1;
  105f18:	c7 44 24 08 02 00 00 	movl   $0x2,0x8(%esp)
  105f1f:	00 
  105f20:	c7 44 24 04 7d 6c 10 	movl   $0x106c7d,0x4(%esp)
  105f27:	00 
  105f28:	c7 04 24 30 00 00 00 	movl   $0x30,(%esp)
  105f2f:	e8 06 3f 00 00       	call   109e3a <syscall_create>
  105f34:	83 f8 ff             	cmp    $0xffffffff,%eax
  105f37:	75 0c                	jne    105f45 <proc_init+0x1cd>
  105f39:	c7 45 fc ff ff ff ff 	movl   $0xffffffff,-0x4(%ebp)
  105f40:	e9 28 03 00 00       	jmp    10626d <proc_init+0x4f5>
  if (syscall_create(SYSCALL_PROC_GETPIDBYNAME,proc_getpidbyname,1)==-1) return -1;
  105f45:	c7 44 24 08 01 00 00 	movl   $0x1,0x8(%esp)
  105f4c:	00 
  105f4d:	c7 44 24 04 d5 6c 10 	movl   $0x106cd5,0x4(%esp)
  105f54:	00 
  105f55:	c7 04 24 31 00 00 00 	movl   $0x31,(%esp)
  105f5c:	e8 d9 3e 00 00       	call   109e3a <syscall_create>
  105f61:	83 f8 ff             	cmp    $0xffffffff,%eax
  105f64:	75 0c                	jne    105f72 <proc_init+0x1fa>
  105f66:	c7 45 fc ff ff ff ff 	movl   $0xffffffff,-0x4(%ebp)
  105f6d:	e9 fb 02 00 00       	jmp    10626d <proc_init+0x4f5>
  if (syscall_create(SYSCALL_PROC_GETVAR,proc_getvar,1)==-1) return -1;
  105f72:	c7 44 24 08 01 00 00 	movl   $0x1,0x8(%esp)
  105f79:	00 
  105f7a:	c7 44 24 04 34 6d 10 	movl   $0x106d34,0x4(%esp)
  105f81:	00 
  105f82:	c7 04 24 32 00 00 00 	movl   $0x32,(%esp)
  105f89:	e8 ac 3e 00 00       	call   109e3a <syscall_create>
  105f8e:	83 f8 ff             	cmp    $0xffffffff,%eax
  105f91:	75 0c                	jne    105f9f <proc_init+0x227>
  105f93:	c7 45 fc ff ff ff ff 	movl   $0xffffffff,-0x4(%ebp)
  105f9a:	e9 ce 02 00 00       	jmp    10626d <proc_init+0x4f5>
  if (syscall_create(SYSCALL_PROC_SETVAR,proc_setvar,2)==-1) return -1;
  105f9f:	c7 44 24 08 02 00 00 	movl   $0x2,0x8(%esp)
  105fa6:	00 
  105fa7:	c7 44 24 04 7e 6d 10 	movl   $0x106d7e,0x4(%esp)
  105fae:	00 
  105faf:	c7 04 24 33 00 00 00 	movl   $0x33,(%esp)
  105fb6:	e8 7f 3e 00 00       	call   109e3a <syscall_create>
  105fbb:	83 f8 ff             	cmp    $0xffffffff,%eax
  105fbe:	75 0c                	jne    105fcc <proc_init+0x254>
  105fc0:	c7 45 fc ff ff ff ff 	movl   $0xffffffff,-0x4(%ebp)
  105fc7:	e9 a1 02 00 00       	jmp    10626d <proc_init+0x4f5>
  if (syscall_create(SYSCALL_PROC_EXIT,proc_exit,1)==-1) return -1;
  105fcc:	c7 44 24 08 01 00 00 	movl   $0x1,0x8(%esp)
  105fd3:	00 
  105fd4:	c7 44 24 04 38 6e 10 	movl   $0x106e38,0x4(%esp)
  105fdb:	00 
  105fdc:	c7 04 24 34 00 00 00 	movl   $0x34,(%esp)
  105fe3:	e8 52 3e 00 00       	call   109e3a <syscall_create>
  105fe8:	83 f8 ff             	cmp    $0xffffffff,%eax
  105feb:	75 0c                	jne    105ff9 <proc_init+0x281>
  105fed:	c7 45 fc ff ff ff ff 	movl   $0xffffffff,-0x4(%ebp)
  105ff4:	e9 74 02 00 00       	jmp    10626d <proc_init+0x4f5>
  if (syscall_create(SYSCALL_PROC_ABORT,proc_abort,0)==-1) return -1;
  105ff9:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  106000:	00 
  106001:	c7 44 24 04 95 6f 10 	movl   $0x106f95,0x4(%esp)
  106008:	00 
  106009:	c7 04 24 35 00 00 00 	movl   $0x35,(%esp)
  106010:	e8 25 3e 00 00       	call   109e3a <syscall_create>
  106015:	83 f8 ff             	cmp    $0xffffffff,%eax
  106018:	75 0c                	jne    106026 <proc_init+0x2ae>
  10601a:	c7 45 fc ff ff ff ff 	movl   $0xffffffff,-0x4(%ebp)
  106021:	e9 47 02 00 00       	jmp    10626d <proc_init+0x4f5>
  if (syscall_create(SYSCALL_PROC_STOP,proc_stop,0)==-1) return -1;
  106026:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  10602d:	00 
  10602e:	c7 44 24 04 a9 6f 10 	movl   $0x106fa9,0x4(%esp)
  106035:	00 
  106036:	c7 04 24 36 00 00 00 	movl   $0x36,(%esp)
  10603d:	e8 f8 3d 00 00       	call   109e3a <syscall_create>
  106042:	83 f8 ff             	cmp    $0xffffffff,%eax
  106045:	75 0c                	jne    106053 <proc_init+0x2db>
  106047:	c7 45 fc ff ff ff ff 	movl   $0xffffffff,-0x4(%ebp)
  10604e:	e9 1a 02 00 00       	jmp    10626d <proc_init+0x4f5>
  if (syscall_create(SYSCALL_PROC_CREATE,proc_create_syscall,4)==-1) return -1;
  106053:	c7 44 24 08 04 00 00 	movl   $0x4,0x8(%esp)
  10605a:	00 
  10605b:	c7 44 24 04 5c 71 10 	movl   $0x10715c,0x4(%esp)
  106062:	00 
  106063:	c7 04 24 37 00 00 00 	movl   $0x37,(%esp)
  10606a:	e8 cb 3d 00 00       	call   109e3a <syscall_create>
  10606f:	83 f8 ff             	cmp    $0xffffffff,%eax
  106072:	75 0c                	jne    106080 <proc_init+0x308>
  106074:	c7 45 fc ff ff ff ff 	movl   $0xffffffff,-0x4(%ebp)
  10607b:	e9 ed 01 00 00       	jmp    10626d <proc_init+0x4f5>
  if (syscall_create(SYSCALL_PROC_DESTROY,proc_destroy_syscall,1)==-1) return -1;
  106080:	c7 44 24 08 01 00 00 	movl   $0x1,0x8(%esp)
  106087:	00 
  106088:	c7 44 24 04 e0 71 10 	movl   $0x1071e0,0x4(%esp)
  10608f:	00 
  106090:	c7 04 24 38 00 00 00 	movl   $0x38,(%esp)
  106097:	e8 9e 3d 00 00       	call   109e3a <syscall_create>
  10609c:	83 f8 ff             	cmp    $0xffffffff,%eax
  10609f:	75 0c                	jne    1060ad <proc_init+0x335>
  1060a1:	c7 45 fc ff ff ff ff 	movl   $0xffffffff,-0x4(%ebp)
  1060a8:	e9 c0 01 00 00       	jmp    10626d <proc_init+0x4f5>
  if (syscall_create(SYSCALL_PROC_MEMMAP,proc_memmap,6)==-1) return -1;
  1060ad:	c7 44 24 08 06 00 00 	movl   $0x6,0x8(%esp)
  1060b4:	00 
  1060b5:	c7 44 24 04 2c 72 10 	movl   $0x10722c,0x4(%esp)
  1060bc:	00 
  1060bd:	c7 04 24 39 00 00 00 	movl   $0x39,(%esp)
  1060c4:	e8 71 3d 00 00       	call   109e3a <syscall_create>
  1060c9:	83 f8 ff             	cmp    $0xffffffff,%eax
  1060cc:	75 0c                	jne    1060da <proc_init+0x362>
  1060ce:	c7 45 fc ff ff ff ff 	movl   $0xffffffff,-0x4(%ebp)
  1060d5:	e9 93 01 00 00       	jmp    10626d <proc_init+0x4f5>
  if (syscall_create(SYSCALL_PROC_MEMALLOC,proc_memalloc,4)==-1) return -1;
  1060da:	c7 44 24 08 04 00 00 	movl   $0x4,0x8(%esp)
  1060e1:	00 
  1060e2:	c7 44 24 04 50 73 10 	movl   $0x107350,0x4(%esp)
  1060e9:	00 
  1060ea:	c7 04 24 3a 00 00 00 	movl   $0x3a,(%esp)
  1060f1:	e8 44 3d 00 00       	call   109e3a <syscall_create>
  1060f6:	83 f8 ff             	cmp    $0xffffffff,%eax
  1060f9:	75 0c                	jne    106107 <proc_init+0x38f>
  1060fb:	c7 45 fc ff ff ff ff 	movl   $0xffffffff,-0x4(%ebp)
  106102:	e9 66 01 00 00       	jmp    10626d <proc_init+0x4f5>
  if (syscall_create(SYSCALL_PROC_MEMUNMAP,proc_memunmap,2)==-1) return -1;
  106107:	c7 44 24 08 02 00 00 	movl   $0x2,0x8(%esp)
  10610e:	00 
  10610f:	c7 44 24 04 b1 73 10 	movl   $0x1073b1,0x4(%esp)
  106116:	00 
  106117:	c7 04 24 3b 00 00 00 	movl   $0x3b,(%esp)
  10611e:	e8 17 3d 00 00       	call   109e3a <syscall_create>
  106123:	83 f8 ff             	cmp    $0xffffffff,%eax
  106126:	75 0c                	jne    106134 <proc_init+0x3bc>
  106128:	c7 45 fc ff ff ff ff 	movl   $0xffffffff,-0x4(%ebp)
  10612f:	e9 39 01 00 00       	jmp    10626d <proc_init+0x4f5>
  if (syscall_create(SYSCALL_PROC_MEMFREE,proc_memfree,2)==-1) return -1;
  106134:	c7 44 24 08 02 00 00 	movl   $0x2,0x8(%esp)
  10613b:	00 
  10613c:	c7 44 24 04 44 74 10 	movl   $0x107444,0x4(%esp)
  106143:	00 
  106144:	c7 04 24 3c 00 00 00 	movl   $0x3c,(%esp)
  10614b:	e8 ea 3c 00 00       	call   109e3a <syscall_create>
  106150:	83 f8 ff             	cmp    $0xffffffff,%eax
  106153:	75 0c                	jne    106161 <proc_init+0x3e9>
  106155:	c7 45 fc ff ff ff ff 	movl   $0xffffffff,-0x4(%ebp)
  10615c:	e9 0c 01 00 00       	jmp    10626d <proc_init+0x4f5>
  if (syscall_create(SYSCALL_PROC_MEMGET,proc_memget,6)==-1) return -1;
  106161:	c7 44 24 08 06 00 00 	movl   $0x6,0x8(%esp)
  106168:	00 
  106169:	c7 44 24 04 df 74 10 	movl   $0x1074df,0x4(%esp)
  106170:	00 
  106171:	c7 04 24 3e 00 00 00 	movl   $0x3e,(%esp)
  106178:	e8 bd 3c 00 00       	call   109e3a <syscall_create>
  10617d:	83 f8 ff             	cmp    $0xffffffff,%eax
  106180:	75 0c                	jne    10618e <proc_init+0x416>
  106182:	c7 45 fc ff ff ff ff 	movl   $0xffffffff,-0x4(%ebp)
  106189:	e9 df 00 00 00       	jmp    10626d <proc_init+0x4f5>
  if (syscall_create(SYSCALL_PROC_MEMPAGELIST,proc_mempagelist,6)==-1) return -1;
  10618e:	c7 44 24 08 06 00 00 	movl   $0x6,0x8(%esp)
  106195:	00 
  106196:	c7 44 24 04 c7 75 10 	movl   $0x1075c7,0x4(%esp)
  10619d:	00 
  10619e:	c7 04 24 3f 00 00 00 	movl   $0x3f,(%esp)
  1061a5:	e8 90 3c 00 00       	call   109e3a <syscall_create>
  1061aa:	83 f8 ff             	cmp    $0xffffffff,%eax
  1061ad:	75 0c                	jne    1061bb <proc_init+0x443>
  1061af:	c7 45 fc ff ff ff ff 	movl   $0xffffffff,-0x4(%ebp)
  1061b6:	e9 b2 00 00 00       	jmp    10626d <proc_init+0x4f5>
  if (syscall_create(SYSCALL_PROC_SYSTEM,proc_system,2)==-1) return -1;
  1061bb:	c7 44 24 08 02 00 00 	movl   $0x2,0x8(%esp)
  1061c2:	00 
  1061c3:	c7 44 24 04 40 77 10 	movl   $0x107740,0x4(%esp)
  1061ca:	00 
  1061cb:	c7 04 24 40 00 00 00 	movl   $0x40,(%esp)
  1061d2:	e8 63 3c 00 00       	call   109e3a <syscall_create>
  1061d7:	83 f8 ff             	cmp    $0xffffffff,%eax
  1061da:	75 0c                	jne    1061e8 <proc_init+0x470>
  1061dc:	c7 45 fc ff ff ff ff 	movl   $0xffffffff,-0x4(%ebp)
  1061e3:	e9 85 00 00 00       	jmp    10626d <proc_init+0x4f5>
  if (syscall_create(SYSCALL_PROC_JUMP,proc_jump,2)==-1) return -1;
  1061e8:	c7 44 24 08 02 00 00 	movl   $0x2,0x8(%esp)
  1061ef:	00 
  1061f0:	c7 44 24 04 a3 77 10 	movl   $0x1077a3,0x4(%esp)
  1061f7:	00 
  1061f8:	c7 04 24 41 00 00 00 	movl   $0x41,(%esp)
  1061ff:	e8 36 3c 00 00       	call   109e3a <syscall_create>
  106204:	83 f8 ff             	cmp    $0xffffffff,%eax
  106207:	75 09                	jne    106212 <proc_init+0x49a>
  106209:	c7 45 fc ff ff ff ff 	movl   $0xffffffff,-0x4(%ebp)
  106210:	eb 5b                	jmp    10626d <proc_init+0x4f5>
  if (syscall_create(SYSCALL_PROC_CREATESTACK,proc_createstack,1)==-1) return -1;
  106212:	c7 44 24 08 01 00 00 	movl   $0x1,0x8(%esp)
  106219:	00 
  10621a:	c7 44 24 04 e7 77 10 	movl   $0x1077e7,0x4(%esp)
  106221:	00 
  106222:	c7 04 24 42 00 00 00 	movl   $0x42,(%esp)
  106229:	e8 0c 3c 00 00       	call   109e3a <syscall_create>
  10622e:	83 f8 ff             	cmp    $0xffffffff,%eax
  106231:	75 09                	jne    10623c <proc_init+0x4c4>
  106233:	c7 45 fc ff ff ff ff 	movl   $0xffffffff,-0x4(%ebp)
  10623a:	eb 31                	jmp    10626d <proc_init+0x4f5>
  if (syscall_create(SYSCALL_PROC_WAITPID,proc_waitpid,3)==-1) return -1;
  10623c:	c7 44 24 08 03 00 00 	movl   $0x3,0x8(%esp)
  106243:	00 
  106244:	c7 44 24 04 a6 6d 10 	movl   $0x106da6,0x4(%esp)
  10624b:	00 
  10624c:	c7 04 24 43 00 00 00 	movl   $0x43,(%esp)
  106253:	e8 e2 3b 00 00       	call   109e3a <syscall_create>
  106258:	83 f8 ff             	cmp    $0xffffffff,%eax
  10625b:	75 09                	jne    106266 <proc_init+0x4ee>
  10625d:	c7 45 fc ff ff ff ff 	movl   $0xffffffff,-0x4(%ebp)
  106264:	eb 07                	jmp    10626d <proc_init+0x4f5>
  return 0;
  106266:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
  10626d:	8b 45 fc             	mov    -0x4(%ebp),%eax
}
  106270:	c9                   	leave  
  106271:	c3                   	ret    

00106272 <proc_create>:
/**
 * Creates a new process
 *  @param name Process name
 *  @return Process
 */
proc_t *proc_create(char *name,uid_t uid,gid_t gid,proc_t *parent,int running,int system) {
  106272:	55                   	push   %ebp
  106273:	89 e5                	mov    %esp,%ebp
  106275:	83 ec 28             	sub    $0x28,%esp
  proc_t *new = malloc(sizeof(proc_t));
  106278:	c7 04 24 b4 00 00 00 	movl   $0xb4,(%esp)
  10627f:	e8 e5 cc ff ff       	call   102f69 <malloc>
  106284:	89 45 fc             	mov    %eax,-0x4(%ebp)

  new->pid = proc_nextpid++;
  106287:	8b 15 60 e4 10 00    	mov    0x10e460,%edx
  10628d:	8b 45 fc             	mov    -0x4(%ebp),%eax
  106290:	89 10                	mov    %edx,(%eax)
  106292:	8d 42 01             	lea    0x1(%edx),%eax
  106295:	a3 60 e4 10 00       	mov    %eax,0x10e460
  new->uid = uid;
  10629a:	8b 55 fc             	mov    -0x4(%ebp),%edx
  10629d:	8b 45 0c             	mov    0xc(%ebp),%eax
  1062a0:	89 42 04             	mov    %eax,0x4(%edx)
  new->euid = uid;
  1062a3:	8b 55 fc             	mov    -0x4(%ebp),%edx
  1062a6:	8b 45 0c             	mov    0xc(%ebp),%eax
  1062a9:	89 42 08             	mov    %eax,0x8(%edx)
  new->suid = uid;
  1062ac:	8b 55 fc             	mov    -0x4(%ebp),%edx
  1062af:	8b 45 0c             	mov    0xc(%ebp),%eax
  1062b2:	89 42 0c             	mov    %eax,0xc(%edx)
  new->gid = gid;
  1062b5:	8b 55 fc             	mov    -0x4(%ebp),%edx
  1062b8:	8b 45 10             	mov    0x10(%ebp),%eax
  1062bb:	89 42 10             	mov    %eax,0x10(%edx)
  new->egid = gid;
  1062be:	8b 55 fc             	mov    -0x4(%ebp),%edx
  1062c1:	8b 45 10             	mov    0x10(%ebp),%eax
  1062c4:	89 42 14             	mov    %eax,0x14(%edx)
  new->sgid = gid;
  1062c7:	8b 55 fc             	mov    -0x4(%ebp),%edx
  1062ca:	8b 45 10             	mov    0x10(%ebp),%eax
  1062cd:	89 42 18             	mov    %eax,0x18(%edx)
  new->name = strdup(name);
  1062d0:	8b 45 08             	mov    0x8(%ebp),%eax
  1062d3:	89 04 24             	mov    %eax,(%esp)
  1062d6:	e8 16 5c 00 00       	call   10bef1 <strdup>
  1062db:	89 c2                	mov    %eax,%edx
  1062dd:	8b 45 fc             	mov    -0x4(%ebp),%eax
  1062e0:	89 50 20             	mov    %edx,0x20(%eax)
  new->system = system;
  1062e3:	8b 55 fc             	mov    -0x4(%ebp),%edx
  1062e6:	8b 45 1c             	mov    0x1c(%ebp),%eax
  1062e9:	89 42 1c             	mov    %eax,0x1c(%edx)
  new->parent = parent;
  1062ec:	8b 55 fc             	mov    -0x4(%ebp),%edx
  1062ef:	8b 45 14             	mov    0x14(%ebp),%eax
  1062f2:	89 42 24             	mov    %eax,0x24(%edx)
  if (parent!=NULL) llist_push(parent->children,new);
  1062f5:	83 7d 14 00          	cmpl   $0x0,0x14(%ebp)
  1062f9:	74 15                	je     106310 <proc_create+0x9e>
  1062fb:	8b 45 14             	mov    0x14(%ebp),%eax
  1062fe:	8b 50 28             	mov    0x28(%eax),%edx
  106301:	8b 45 fc             	mov    -0x4(%ebp),%eax
  106304:	89 44 24 04          	mov    %eax,0x4(%esp)
  106308:	89 14 24             	mov    %edx,(%esp)
  10630b:	e8 3f 46 00 00       	call   10a94f <llist_push>
  new->children = llist_create();
  106310:	e8 bf 45 00 00       	call   10a8d4 <llist_create>
  106315:	89 c2                	mov    %eax,%edx
  106317:	8b 45 fc             	mov    -0x4(%ebp),%eax
  10631a:	89 50 28             	mov    %edx,0x28(%eax)
  memset(&(new->registers),0,sizeof(new->registers));
  10631d:	8b 45 fc             	mov    -0x4(%ebp),%eax
  106320:	83 c0 2c             	add    $0x2c,%eax
  106323:	c7 44 24 08 40 00 00 	movl   $0x40,0x8(%esp)
  10632a:	00 
  10632b:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  106332:	00 
  106333:	89 04 24             	mov    %eax,(%esp)
  106336:	e8 26 5a 00 00       	call   10bd61 <memset>
  new->registers.efl = 0x202;
  10633b:	8b 45 fc             	mov    -0x4(%ebp),%eax
  10633e:	c7 40 50 02 02 00 00 	movl   $0x202,0x50(%eax)
  new->registers.cs = IDX2SEL(3,PRIV_USER);
  106345:	8b 45 fc             	mov    -0x4(%ebp),%eax
  106348:	c7 40 54 1b 00 00 00 	movl   $0x1b,0x54(%eax)
  new->registers.ds = IDX2SEL(4,PRIV_USER);
  10634f:	8b 45 fc             	mov    -0x4(%ebp),%eax
  106352:	c7 40 58 23 00 00 00 	movl   $0x23,0x58(%eax)
  new->registers.es = IDX2SEL(4,PRIV_USER);
  106359:	8b 45 fc             	mov    -0x4(%ebp),%eax
  10635c:	c7 40 5c 23 00 00 00 	movl   $0x23,0x5c(%eax)
  new->registers.fs = IDX2SEL(4,PRIV_USER);
  106363:	8b 45 fc             	mov    -0x4(%ebp),%eax
  106366:	c7 40 60 23 00 00 00 	movl   $0x23,0x60(%eax)
  new->registers.gs = IDX2SEL(4,PRIV_USER);
  10636d:	8b 45 fc             	mov    -0x4(%ebp),%eax
  106370:	c7 40 64 23 00 00 00 	movl   $0x23,0x64(%eax)
  new->registers.ss = IDX2SEL(4,PRIV_USER);
  106377:	8b 45 fc             	mov    -0x4(%ebp),%eax
  10637a:	c7 40 68 23 00 00 00 	movl   $0x23,0x68(%eax)
  new->addrspace = memuser_create_addrspace(new);
  106381:	8b 45 fc             	mov    -0x4(%ebp),%eax
  106384:	89 04 24             	mov    %eax,(%esp)
  106387:	e8 35 d7 ff ff       	call   103ac1 <memuser_create_addrspace>
  10638c:	89 c2                	mov    %eax,%edx
  10638e:	8b 45 fc             	mov    -0x4(%ebp),%eax
  106391:	89 50 6c             	mov    %edx,0x6c(%eax)
  new->time_handler = llist_create();
  106394:	e8 3b 45 00 00       	call   10a8d4 <llist_create>
  106399:	89 c2                	mov    %eax,%edx
  10639b:	8b 45 fc             	mov    -0x4(%ebp),%eax
  10639e:	89 50 70             	mov    %edx,0x70(%eax)
  new->nice = 0;
  1063a1:	8b 45 fc             	mov    -0x4(%ebp),%eax
  1063a4:	c7 40 74 00 00 00 00 	movl   $0x0,0x74(%eax)
  new->ticks_rem = NICE2TICKS(new->nice);
  1063ab:	8b 45 fc             	mov    -0x4(%ebp),%eax
  1063ae:	c7 40 78 01 00 00 00 	movl   $0x1,0x78(%eax)
  new->var = -1;
  1063b5:	8b 45 fc             	mov    -0x4(%ebp),%eax
  1063b8:	c7 80 80 00 00 00 ff 	movl   $0xffffffff,0x80(%eax)
  1063bf:	ff ff ff 
  new->defunc = 0;
  1063c2:	8b 45 fc             	mov    -0x4(%ebp),%eax
  1063c5:	c7 80 84 00 00 00 00 	movl   $0x0,0x84(%eax)
  1063cc:	00 00 00 
  new->is_sleeping = !running;
  1063cf:	83 7d 18 00          	cmpl   $0x0,0x18(%ebp)
  1063d3:	0f 94 c0             	sete   %al
  1063d6:	0f b6 d0             	movzbl %al,%edx
  1063d9:	8b 45 fc             	mov    -0x4(%ebp),%eax
  1063dc:	89 50 7c             	mov    %edx,0x7c(%eax)
  new->signal = NULL;
  1063df:	8b 45 fc             	mov    -0x4(%ebp),%eax
  1063e2:	c7 80 8c 00 00 00 00 	movl   $0x0,0x8c(%eax)
  1063e9:	00 00 00 
  new->is_vm86 = 0;
  1063ec:	8b 45 fc             	mov    -0x4(%ebp),%eax
  1063ef:	c7 80 90 00 00 00 00 	movl   $0x0,0x90(%eax)
  1063f6:	00 00 00 

  llist_push(proc_all,new);
  1063f9:	8b 15 80 e1 10 00    	mov    0x10e180,%edx
  1063ff:	8b 45 fc             	mov    -0x4(%ebp),%eax
  106402:	89 44 24 04          	mov    %eax,0x4(%esp)
  106406:	89 14 24             	mov    %edx,(%esp)
  106409:	e8 41 45 00 00       	call   10a94f <llist_push>
  llist_push(running?proc_running:proc_sleeping,new);
  10640e:	83 7d 18 00          	cmpl   $0x0,0x18(%ebp)
  106412:	74 0a                	je     10641e <proc_create+0x1ac>
  106414:	a1 9c e1 10 00       	mov    0x10e19c,%eax
  106419:	89 45 ec             	mov    %eax,-0x14(%ebp)
  10641c:	eb 08                	jmp    106426 <proc_create+0x1b4>
  10641e:	a1 50 e4 10 00       	mov    0x10e450,%eax
  106423:	89 45 ec             	mov    %eax,-0x14(%ebp)
  106426:	8b 45 fc             	mov    -0x4(%ebp),%eax
  106429:	89 44 24 04          	mov    %eax,0x4(%esp)
  10642d:	8b 45 ec             	mov    -0x14(%ebp),%eax
  106430:	89 04 24             	mov    %eax,(%esp)
  106433:	e8 17 45 00 00       	call   10a94f <llist_push>
  return new;
  106438:	8b 45 fc             	mov    -0x4(%ebp),%eax
}
  10643b:	c9                   	leave  
  10643c:	c3                   	ret    

0010643d <proc_destroy>:
/**
 * Destroys a process
 *  @param proc Process
 *  @return Success?
 */
int proc_destroy(proc_t *proc) {
  10643d:	55                   	push   %ebp
  10643e:	89 e5                	mov    %esp,%ebp
  106440:	83 ec 18             	sub    $0x18,%esp
  proc_t *child;

  free(proc->name);
  106443:	8b 45 08             	mov    0x8(%ebp),%eax
  106446:	8b 40 20             	mov    0x20(%eax),%eax
  106449:	89 04 24             	mov    %eax,(%esp)
  10644c:	e8 4c cb ff ff       	call   102f9d <free>
  106451:	eb 0c                	jmp    10645f <proc_destroy+0x22>
  while ((child = llist_pop(proc->children))) child->parent = proc->parent;
  106453:	8b 45 08             	mov    0x8(%ebp),%eax
  106456:	8b 50 24             	mov    0x24(%eax),%edx
  106459:	8b 45 fc             	mov    -0x4(%ebp),%eax
  10645c:	89 50 24             	mov    %edx,0x24(%eax)
  10645f:	8b 45 08             	mov    0x8(%ebp),%eax
  106462:	8b 40 28             	mov    0x28(%eax),%eax
  106465:	89 04 24             	mov    %eax,(%esp)
  106468:	e8 3b 45 00 00       	call   10a9a8 <llist_pop>
  10646d:	89 45 fc             	mov    %eax,-0x4(%ebp)
  106470:	83 7d fc 00          	cmpl   $0x0,-0x4(%ebp)
  106474:	75 dd                	jne    106453 <proc_destroy+0x16>
  llist_destroy(proc->children);
  106476:	8b 45 08             	mov    0x8(%ebp),%eax
  106479:	8b 40 28             	mov    0x28(%eax),%eax
  10647c:	89 04 24             	mov    %eax,(%esp)
  10647f:	e8 7d 44 00 00       	call   10a901 <llist_destroy>
  if (proc->parent!=NULL) llist_remove(proc->parent->children,llist_find(proc->parent->children,proc));
  106484:	8b 45 08             	mov    0x8(%ebp),%eax
  106487:	8b 40 24             	mov    0x24(%eax),%eax
  10648a:	85 c0                	test   %eax,%eax
  10648c:	74 2f                	je     1064bd <proc_destroy+0x80>
  10648e:	8b 45 08             	mov    0x8(%ebp),%eax
  106491:	8b 40 24             	mov    0x24(%eax),%eax
  106494:	8b 50 28             	mov    0x28(%eax),%edx
  106497:	8b 45 08             	mov    0x8(%ebp),%eax
  10649a:	89 44 24 04          	mov    %eax,0x4(%esp)
  10649e:	89 14 24             	mov    %edx,(%esp)
  1064a1:	e8 7b 47 00 00       	call   10ac21 <llist_find>
  1064a6:	89 c2                	mov    %eax,%edx
  1064a8:	8b 45 08             	mov    0x8(%ebp),%eax
  1064ab:	8b 40 24             	mov    0x24(%eax),%eax
  1064ae:	8b 40 28             	mov    0x28(%eax),%eax
  1064b1:	89 54 24 04          	mov    %edx,0x4(%esp)
  1064b5:	89 04 24             	mov    %eax,(%esp)
  1064b8:	e8 9c 46 00 00       	call   10ab59 <llist_remove>
  if (proc->addrspace!=NULL) memuser_destroy_addrspace(proc->addrspace);
  1064bd:	8b 45 08             	mov    0x8(%ebp),%eax
  1064c0:	8b 40 6c             	mov    0x6c(%eax),%eax
  1064c3:	85 c0                	test   %eax,%eax
  1064c5:	74 0e                	je     1064d5 <proc_destroy+0x98>
  1064c7:	8b 45 08             	mov    0x8(%ebp),%eax
  1064ca:	8b 40 6c             	mov    0x6c(%eax),%eax
  1064cd:	89 04 24             	mov    %eax,(%esp)
  1064d0:	e8 4c d6 ff ff       	call   103b21 <memuser_destroy_addrspace>
  llist_destroy(proc->time_handler);
  1064d5:	8b 45 08             	mov    0x8(%ebp),%eax
  1064d8:	8b 40 70             	mov    0x70(%eax),%eax
  1064db:	89 04 24             	mov    %eax,(%esp)
  1064de:	e8 1e 44 00 00       	call   10a901 <llist_destroy>

  llist_remove(proc_all,llist_find(proc_all,proc));
  1064e3:	8b 15 80 e1 10 00    	mov    0x10e180,%edx
  1064e9:	8b 45 08             	mov    0x8(%ebp),%eax
  1064ec:	89 44 24 04          	mov    %eax,0x4(%esp)
  1064f0:	89 14 24             	mov    %edx,(%esp)
  1064f3:	e8 29 47 00 00       	call   10ac21 <llist_find>
  1064f8:	8b 15 80 e1 10 00    	mov    0x10e180,%edx
  1064fe:	89 44 24 04          	mov    %eax,0x4(%esp)
  106502:	89 14 24             	mov    %edx,(%esp)
  106505:	e8 4f 46 00 00       	call   10ab59 <llist_remove>
  if (llist_remove(proc_running,llist_find(proc_running,proc))!=proc) llist_remove(proc_sleeping,llist_find(proc_sleeping,proc));
  10650a:	8b 15 9c e1 10 00    	mov    0x10e19c,%edx
  106510:	8b 45 08             	mov    0x8(%ebp),%eax
  106513:	89 44 24 04          	mov    %eax,0x4(%esp)
  106517:	89 14 24             	mov    %edx,(%esp)
  10651a:	e8 02 47 00 00       	call   10ac21 <llist_find>
  10651f:	8b 15 9c e1 10 00    	mov    0x10e19c,%edx
  106525:	89 44 24 04          	mov    %eax,0x4(%esp)
  106529:	89 14 24             	mov    %edx,(%esp)
  10652c:	e8 28 46 00 00       	call   10ab59 <llist_remove>
  106531:	3b 45 08             	cmp    0x8(%ebp),%eax
  106534:	74 27                	je     10655d <proc_destroy+0x120>
  106536:	8b 15 50 e4 10 00    	mov    0x10e450,%edx
  10653c:	8b 45 08             	mov    0x8(%ebp),%eax
  10653f:	89 44 24 04          	mov    %eax,0x4(%esp)
  106543:	89 14 24             	mov    %edx,(%esp)
  106546:	e8 d6 46 00 00       	call   10ac21 <llist_find>
  10654b:	8b 15 50 e4 10 00    	mov    0x10e450,%edx
  106551:	89 44 24 04          	mov    %eax,0x4(%esp)
  106555:	89 14 24             	mov    %edx,(%esp)
  106558:	e8 fc 45 00 00       	call   10ab59 <llist_remove>
  free(proc);
  10655d:	8b 45 08             	mov    0x8(%ebp),%eax
  106560:	89 04 24             	mov    %eax,(%esp)
  106563:	e8 35 ca ff ff       	call   102f9d <free>
  return 0;
  106568:	b8 00 00 00 00       	mov    $0x0,%eax
}
  10656d:	c9                   	leave  
  10656e:	c3                   	ret    

0010656f <proc_find>:
/**
 * Finds a process by PID
 *  @param PID
 *  @return Process
 */
proc_t *proc_find(pid_t pid) {
  10656f:	55                   	push   %ebp
  106570:	89 e5                	mov    %esp,%ebp
  106572:	83 ec 28             	sub    $0x28,%esp
  size_t i;
  proc_t *proc;
  if (proc_current->pid==pid) return proc_current;
  106575:	a1 a0 e1 10 00       	mov    0x10e1a0,%eax
  10657a:	8b 00                	mov    (%eax),%eax
  10657c:	3b 45 08             	cmp    0x8(%ebp),%eax
  10657f:	75 0a                	jne    10658b <proc_find+0x1c>
  106581:	a1 a0 e1 10 00       	mov    0x10e1a0,%eax
  106586:	89 45 ec             	mov    %eax,-0x14(%ebp)
  106589:	eb 43                	jmp    1065ce <proc_find+0x5f>
  for (i=0;(proc = llist_get(proc_all,i));i++) {
  10658b:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
  106592:	eb 16                	jmp    1065aa <proc_find+0x3b>
    if (proc->pid==pid) return proc;
  106594:	8b 45 fc             	mov    -0x4(%ebp),%eax
  106597:	8b 00                	mov    (%eax),%eax
  106599:	3b 45 08             	cmp    0x8(%ebp),%eax
  10659c:	75 08                	jne    1065a6 <proc_find+0x37>
  10659e:	8b 45 fc             	mov    -0x4(%ebp),%eax
  1065a1:	89 45 ec             	mov    %eax,-0x14(%ebp)
  1065a4:	eb 28                	jmp    1065ce <proc_find+0x5f>
 */
proc_t *proc_find(pid_t pid) {
  size_t i;
  proc_t *proc;
  if (proc_current->pid==pid) return proc_current;
  for (i=0;(proc = llist_get(proc_all,i));i++) {
  1065a6:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
  1065aa:	a1 80 e1 10 00       	mov    0x10e180,%eax
  1065af:	8b 55 f8             	mov    -0x8(%ebp),%edx
  1065b2:	89 54 24 04          	mov    %edx,0x4(%esp)
  1065b6:	89 04 24             	mov    %eax,(%esp)
  1065b9:	e8 c9 44 00 00       	call   10aa87 <llist_get>
  1065be:	89 45 fc             	mov    %eax,-0x4(%ebp)
  1065c1:	83 7d fc 00          	cmpl   $0x0,-0x4(%ebp)
  1065c5:	75 cd                	jne    106594 <proc_find+0x25>
    if (proc->pid==pid) return proc;
  }
  return NULL;
  1065c7:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
  1065ce:	8b 45 ec             	mov    -0x14(%ebp),%eax
}
  1065d1:	c9                   	leave  
  1065d2:	c3                   	ret    

001065d3 <proc_ischild>:
 * Checks if proc is a child of parent
 *  @param parent Parent process
 *  @param proc Process to check if it's a child of proc
 *  @return If proc is a child of parent
 */
int proc_ischild(proc_t *parent,proc_t *proc) {
  1065d3:	55                   	push   %ebp
  1065d4:	89 e5                	mov    %esp,%ebp
  1065d6:	83 ec 28             	sub    $0x28,%esp
  proc_t *child;
  size_t i;

  for (i=0;(child = llist_get(parent->children,i));i++) {
  1065d9:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
  1065e0:	eb 15                	jmp    1065f7 <proc_ischild+0x24>
    if (proc==child) return 1;
  1065e2:	8b 45 0c             	mov    0xc(%ebp),%eax
  1065e5:	3b 45 f8             	cmp    -0x8(%ebp),%eax
  1065e8:	75 09                	jne    1065f3 <proc_ischild+0x20>
  1065ea:	c7 45 ec 01 00 00 00 	movl   $0x1,-0x14(%ebp)
  1065f1:	eb 29                	jmp    10661c <proc_ischild+0x49>
 */
int proc_ischild(proc_t *parent,proc_t *proc) {
  proc_t *child;
  size_t i;

  for (i=0;(child = llist_get(parent->children,i));i++) {
  1065f3:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
  1065f7:	8b 45 08             	mov    0x8(%ebp),%eax
  1065fa:	8b 50 28             	mov    0x28(%eax),%edx
  1065fd:	8b 45 fc             	mov    -0x4(%ebp),%eax
  106600:	89 44 24 04          	mov    %eax,0x4(%esp)
  106604:	89 14 24             	mov    %edx,(%esp)
  106607:	e8 7b 44 00 00       	call   10aa87 <llist_get>
  10660c:	89 45 f8             	mov    %eax,-0x8(%ebp)
  10660f:	83 7d f8 00          	cmpl   $0x0,-0x8(%ebp)
  106613:	75 cd                	jne    1065e2 <proc_ischild+0xf>
    if (proc==child) return 1;
  }
  return 0;
  106615:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
  10661c:	8b 45 ec             	mov    -0x14(%ebp),%eax
}
  10661f:	c9                   	leave  
  106620:	c3                   	ret    

00106621 <proc_sleep>:
 * Sends a process sleeping
 *  @param proc Process
 *  @param sleep Reference to sleep variable
 *  @return Success?
 */
int proc_sleep(proc_t *proc) {
  106621:	55                   	push   %ebp
  106622:	89 e5                	mov    %esp,%ebp
  106624:	83 ec 08             	sub    $0x8,%esp
  if (!proc->is_sleeping) {
  106627:	8b 45 08             	mov    0x8(%ebp),%eax
  10662a:	8b 40 7c             	mov    0x7c(%eax),%eax
  10662d:	85 c0                	test   %eax,%eax
  10662f:	75 55                	jne    106686 <proc_sleep+0x65>
    llist_remove(proc_running,llist_find(proc_running,proc));
  106631:	8b 15 9c e1 10 00    	mov    0x10e19c,%edx
  106637:	8b 45 08             	mov    0x8(%ebp),%eax
  10663a:	89 44 24 04          	mov    %eax,0x4(%esp)
  10663e:	89 14 24             	mov    %edx,(%esp)
  106641:	e8 db 45 00 00       	call   10ac21 <llist_find>
  106646:	8b 15 9c e1 10 00    	mov    0x10e19c,%edx
  10664c:	89 44 24 04          	mov    %eax,0x4(%esp)
  106650:	89 14 24             	mov    %edx,(%esp)
  106653:	e8 01 45 00 00       	call   10ab59 <llist_remove>
    llist_push(proc_sleeping,proc);
  106658:	8b 15 50 e4 10 00    	mov    0x10e450,%edx
  10665e:	8b 45 08             	mov    0x8(%ebp),%eax
  106661:	89 44 24 04          	mov    %eax,0x4(%esp)
  106665:	89 14 24             	mov    %edx,(%esp)
  106668:	e8 e2 42 00 00       	call   10a94f <llist_push>
    proc->is_sleeping = 1;
  10666d:	8b 45 08             	mov    0x8(%ebp),%eax
  106670:	c7 40 7c 01 00 00 00 	movl   $0x1,0x7c(%eax)
    if (proc==proc_current) proc_shedule();
  106677:	a1 a0 e1 10 00       	mov    0x10e1a0,%eax
  10667c:	39 45 08             	cmp    %eax,0x8(%ebp)
  10667f:	75 05                	jne    106686 <proc_sleep+0x65>
  106681:	e8 5e 02 00 00       	call   1068e4 <proc_shedule>
  }
  return 0;
  106686:	b8 00 00 00 00       	mov    $0x0,%eax
}
  10668b:	c9                   	leave  
  10668c:	c3                   	ret    

0010668d <proc_wake>:
/**
 * Wakes a process
 *  @param proc Process
 *  @return Success?
 */
int proc_wake(proc_t *proc) {
  10668d:	55                   	push   %ebp
  10668e:	89 e5                	mov    %esp,%ebp
  106690:	83 ec 08             	sub    $0x8,%esp
  if (proc->is_sleeping) {
  106693:	8b 45 08             	mov    0x8(%ebp),%eax
  106696:	8b 40 7c             	mov    0x7c(%eax),%eax
  106699:	85 c0                	test   %eax,%eax
  10669b:	74 46                	je     1066e3 <proc_wake+0x56>
    llist_remove(proc_sleeping,llist_find(proc_sleeping,proc));
  10669d:	8b 15 50 e4 10 00    	mov    0x10e450,%edx
  1066a3:	8b 45 08             	mov    0x8(%ebp),%eax
  1066a6:	89 44 24 04          	mov    %eax,0x4(%esp)
  1066aa:	89 14 24             	mov    %edx,(%esp)
  1066ad:	e8 6f 45 00 00       	call   10ac21 <llist_find>
  1066b2:	8b 15 50 e4 10 00    	mov    0x10e450,%edx
  1066b8:	89 44 24 04          	mov    %eax,0x4(%esp)
  1066bc:	89 14 24             	mov    %edx,(%esp)
  1066bf:	e8 95 44 00 00       	call   10ab59 <llist_remove>
    llist_push(proc_running,proc);
  1066c4:	8b 15 9c e1 10 00    	mov    0x10e19c,%edx
  1066ca:	8b 45 08             	mov    0x8(%ebp),%eax
  1066cd:	89 44 24 04          	mov    %eax,0x4(%esp)
  1066d1:	89 14 24             	mov    %edx,(%esp)
  1066d4:	e8 76 42 00 00       	call   10a94f <llist_push>
    proc->is_sleeping = 0;
  1066d9:	8b 45 08             	mov    0x8(%ebp),%eax
  1066dc:	c7 40 7c 00 00 00 00 	movl   $0x0,0x7c(%eax)
  }
  return 0;
  1066e3:	b8 00 00 00 00       	mov    $0x0,%eax
}
  1066e8:	c9                   	leave  
  1066e9:	c3                   	ret    

001066ea <proc_regs_save>:
/**
 * Save registers of process
 *  @param proc Process
 *  @return Success?
 */
int proc_regs_save(proc_t *proc) {
  1066ea:	55                   	push   %ebp
  1066eb:	89 e5                	mov    %esp,%ebp
  1066ed:	83 ec 08             	sub    $0x8,%esp
  proc->registers.eax = *interrupt_curregs.eax;
  1066f0:	a1 20 e7 10 00       	mov    0x10e720,%eax
  1066f5:	8b 10                	mov    (%eax),%edx
  1066f7:	8b 45 08             	mov    0x8(%ebp),%eax
  1066fa:	89 50 2c             	mov    %edx,0x2c(%eax)
  proc->registers.ebx = *interrupt_curregs.ebx;
  1066fd:	a1 24 e7 10 00       	mov    0x10e724,%eax
  106702:	8b 10                	mov    (%eax),%edx
  106704:	8b 45 08             	mov    0x8(%ebp),%eax
  106707:	89 50 30             	mov    %edx,0x30(%eax)
  proc->registers.ecx = *interrupt_curregs.ecx;
  10670a:	a1 28 e7 10 00       	mov    0x10e728,%eax
  10670f:	8b 10                	mov    (%eax),%edx
  106711:	8b 45 08             	mov    0x8(%ebp),%eax
  106714:	89 50 34             	mov    %edx,0x34(%eax)
  proc->registers.edx = *interrupt_curregs.edx;
  106717:	a1 2c e7 10 00       	mov    0x10e72c,%eax
  10671c:	8b 10                	mov    (%eax),%edx
  10671e:	8b 45 08             	mov    0x8(%ebp),%eax
  106721:	89 50 38             	mov    %edx,0x38(%eax)
  proc->registers.esi = *interrupt_curregs.esi;
  106724:	a1 30 e7 10 00       	mov    0x10e730,%eax
  106729:	8b 10                	mov    (%eax),%edx
  10672b:	8b 45 08             	mov    0x8(%ebp),%eax
  10672e:	89 50 3c             	mov    %edx,0x3c(%eax)
  proc->registers.edi = *interrupt_curregs.edi;
  106731:	a1 34 e7 10 00       	mov    0x10e734,%eax
  106736:	8b 10                	mov    (%eax),%edx
  106738:	8b 45 08             	mov    0x8(%ebp),%eax
  10673b:	89 50 40             	mov    %edx,0x40(%eax)
  proc->registers.ebp = *interrupt_curregs.ebp;
  10673e:	a1 38 e7 10 00       	mov    0x10e738,%eax
  106743:	8b 10                	mov    (%eax),%edx
  106745:	8b 45 08             	mov    0x8(%ebp),%eax
  106748:	89 50 44             	mov    %edx,0x44(%eax)
  proc->registers.esp = *interrupt_curregs.esp;
  10674b:	a1 3c e7 10 00       	mov    0x10e73c,%eax
  106750:	8b 10                	mov    (%eax),%edx
  106752:	8b 45 08             	mov    0x8(%ebp),%eax
  106755:	89 50 48             	mov    %edx,0x48(%eax)
  proc->registers.eip = *interrupt_curregs.eip;
  106758:	a1 40 e7 10 00       	mov    0x10e740,%eax
  10675d:	8b 10                	mov    (%eax),%edx
  10675f:	8b 45 08             	mov    0x8(%ebp),%eax
  106762:	89 50 4c             	mov    %edx,0x4c(%eax)
  proc->registers.efl = *interrupt_curregs.efl;
  106765:	a1 44 e7 10 00       	mov    0x10e744,%eax
  10676a:	8b 10                	mov    (%eax),%edx
  10676c:	8b 45 08             	mov    0x8(%ebp),%eax
  10676f:	89 50 50             	mov    %edx,0x50(%eax)
  proc->registers.cs = *interrupt_curregs.cs;
  106772:	a1 48 e7 10 00       	mov    0x10e748,%eax
  106777:	8b 10                	mov    (%eax),%edx
  106779:	8b 45 08             	mov    0x8(%ebp),%eax
  10677c:	89 50 54             	mov    %edx,0x54(%eax)
  proc->registers.ds = *interrupt_curregs.ds;
  10677f:	a1 4c e7 10 00       	mov    0x10e74c,%eax
  106784:	8b 10                	mov    (%eax),%edx
  106786:	8b 45 08             	mov    0x8(%ebp),%eax
  106789:	89 50 58             	mov    %edx,0x58(%eax)
  proc->registers.es = *interrupt_curregs.es;
  10678c:	a1 50 e7 10 00       	mov    0x10e750,%eax
  106791:	8b 10                	mov    (%eax),%edx
  106793:	8b 45 08             	mov    0x8(%ebp),%eax
  106796:	89 50 5c             	mov    %edx,0x5c(%eax)
  proc->registers.fs = *interrupt_curregs.fs;
  106799:	a1 54 e7 10 00       	mov    0x10e754,%eax
  10679e:	8b 10                	mov    (%eax),%edx
  1067a0:	8b 45 08             	mov    0x8(%ebp),%eax
  1067a3:	89 50 60             	mov    %edx,0x60(%eax)
  proc->registers.gs = *interrupt_curregs.gs;
  1067a6:	a1 58 e7 10 00       	mov    0x10e758,%eax
  1067ab:	8b 10                	mov    (%eax),%edx
  1067ad:	8b 45 08             	mov    0x8(%ebp),%eax
  1067b0:	89 50 64             	mov    %edx,0x64(%eax)
  proc->registers.ss = *interrupt_curregs.ss;
  1067b3:	a1 5c e7 10 00       	mov    0x10e75c,%eax
  1067b8:	8b 10                	mov    (%eax),%edx
  1067ba:	8b 45 08             	mov    0x8(%ebp),%eax
  1067bd:	89 50 68             	mov    %edx,0x68(%eax)
  if (proc->is_vm86) vm86_save_segregs(proc);
  1067c0:	8b 45 08             	mov    0x8(%ebp),%eax
  1067c3:	8b 80 90 00 00 00    	mov    0x90(%eax),%eax
  1067c9:	85 c0                	test   %eax,%eax
  1067cb:	74 0b                	je     1067d8 <proc_regs_save+0xee>
  1067cd:	8b 45 08             	mov    0x8(%ebp),%eax
  1067d0:	89 04 24             	mov    %eax,(%esp)
  1067d3:	e8 80 3d 00 00       	call   10a558 <vm86_save_segregs>
  return 0;
  1067d8:	b8 00 00 00 00       	mov    $0x0,%eax
}
  1067dd:	c9                   	leave  
  1067de:	c3                   	ret    

001067df <proc_regs_load>:
/**
 * Load registers of process
 *  @param proc Process
 *  @return Success?
 */
int proc_regs_load(proc_t *proc) {
  1067df:	55                   	push   %ebp
  1067e0:	89 e5                	mov    %esp,%ebp
  1067e2:	83 ec 08             	sub    $0x8,%esp
  *interrupt_curregs.eax = proc->registers.eax;
  1067e5:	8b 15 20 e7 10 00    	mov    0x10e720,%edx
  1067eb:	8b 45 08             	mov    0x8(%ebp),%eax
  1067ee:	8b 40 2c             	mov    0x2c(%eax),%eax
  1067f1:	89 02                	mov    %eax,(%edx)
  *interrupt_curregs.ebx = proc->registers.ebx;
  1067f3:	8b 15 24 e7 10 00    	mov    0x10e724,%edx
  1067f9:	8b 45 08             	mov    0x8(%ebp),%eax
  1067fc:	8b 40 30             	mov    0x30(%eax),%eax
  1067ff:	89 02                	mov    %eax,(%edx)
  *interrupt_curregs.ecx = proc->registers.ecx;
  106801:	8b 15 28 e7 10 00    	mov    0x10e728,%edx
  106807:	8b 45 08             	mov    0x8(%ebp),%eax
  10680a:	8b 40 34             	mov    0x34(%eax),%eax
  10680d:	89 02                	mov    %eax,(%edx)
  *interrupt_curregs.edx = proc->registers.edx;
  10680f:	8b 15 2c e7 10 00    	mov    0x10e72c,%edx
  106815:	8b 45 08             	mov    0x8(%ebp),%eax
  106818:	8b 40 38             	mov    0x38(%eax),%eax
  10681b:	89 02                	mov    %eax,(%edx)
  *interrupt_curregs.esi = proc->registers.esi;
  10681d:	8b 15 30 e7 10 00    	mov    0x10e730,%edx
  106823:	8b 45 08             	mov    0x8(%ebp),%eax
  106826:	8b 40 3c             	mov    0x3c(%eax),%eax
  106829:	89 02                	mov    %eax,(%edx)
  *interrupt_curregs.edi = proc->registers.edi;
  10682b:	8b 15 34 e7 10 00    	mov    0x10e734,%edx
  106831:	8b 45 08             	mov    0x8(%ebp),%eax
  106834:	8b 40 40             	mov    0x40(%eax),%eax
  106837:	89 02                	mov    %eax,(%edx)
  *interrupt_curregs.ebp = proc->registers.ebp;
  106839:	8b 15 38 e7 10 00    	mov    0x10e738,%edx
  10683f:	8b 45 08             	mov    0x8(%ebp),%eax
  106842:	8b 40 44             	mov    0x44(%eax),%eax
  106845:	89 02                	mov    %eax,(%edx)
  *interrupt_curregs.esp = proc->registers.esp;
  106847:	8b 15 3c e7 10 00    	mov    0x10e73c,%edx
  10684d:	8b 45 08             	mov    0x8(%ebp),%eax
  106850:	8b 40 48             	mov    0x48(%eax),%eax
  106853:	89 02                	mov    %eax,(%edx)
  *interrupt_curregs.eip = proc->registers.eip;
  106855:	8b 15 40 e7 10 00    	mov    0x10e740,%edx
  10685b:	8b 45 08             	mov    0x8(%ebp),%eax
  10685e:	8b 40 4c             	mov    0x4c(%eax),%eax
  106861:	89 02                	mov    %eax,(%edx)
  *interrupt_curregs.efl = proc->registers.efl;
  106863:	8b 15 44 e7 10 00    	mov    0x10e744,%edx
  106869:	8b 45 08             	mov    0x8(%ebp),%eax
  10686c:	8b 40 50             	mov    0x50(%eax),%eax
  10686f:	89 02                	mov    %eax,(%edx)
  *interrupt_curregs.cs = proc->registers.cs;
  106871:	8b 15 48 e7 10 00    	mov    0x10e748,%edx
  106877:	8b 45 08             	mov    0x8(%ebp),%eax
  10687a:	8b 40 54             	mov    0x54(%eax),%eax
  10687d:	89 02                	mov    %eax,(%edx)
  *interrupt_curregs.ds = proc->registers.ds;
  10687f:	8b 15 4c e7 10 00    	mov    0x10e74c,%edx
  106885:	8b 45 08             	mov    0x8(%ebp),%eax
  106888:	8b 40 58             	mov    0x58(%eax),%eax
  10688b:	89 02                	mov    %eax,(%edx)
  *interrupt_curregs.es = proc->registers.es;
  10688d:	8b 15 50 e7 10 00    	mov    0x10e750,%edx
  106893:	8b 45 08             	mov    0x8(%ebp),%eax
  106896:	8b 40 5c             	mov    0x5c(%eax),%eax
  106899:	89 02                	mov    %eax,(%edx)
  *interrupt_curregs.fs = proc->registers.fs;
  10689b:	8b 15 54 e7 10 00    	mov    0x10e754,%edx
  1068a1:	8b 45 08             	mov    0x8(%ebp),%eax
  1068a4:	8b 40 60             	mov    0x60(%eax),%eax
  1068a7:	89 02                	mov    %eax,(%edx)
  *interrupt_curregs.gs = proc->registers.gs;
  1068a9:	8b 15 58 e7 10 00    	mov    0x10e758,%edx
  1068af:	8b 45 08             	mov    0x8(%ebp),%eax
  1068b2:	8b 40 64             	mov    0x64(%eax),%eax
  1068b5:	89 02                	mov    %eax,(%edx)
  *interrupt_curregs.ss = proc->registers.ss;
  1068b7:	8b 15 5c e7 10 00    	mov    0x10e75c,%edx
  1068bd:	8b 45 08             	mov    0x8(%ebp),%eax
  1068c0:	8b 40 68             	mov    0x68(%eax),%eax
  1068c3:	89 02                	mov    %eax,(%edx)
  if (proc->is_vm86) vm86_load_segregs(proc);
  1068c5:	8b 45 08             	mov    0x8(%ebp),%eax
  1068c8:	8b 80 90 00 00 00    	mov    0x90(%eax),%eax
  1068ce:	85 c0                	test   %eax,%eax
  1068d0:	74 0b                	je     1068dd <proc_regs_load+0xfe>
  1068d2:	8b 45 08             	mov    0x8(%ebp),%eax
  1068d5:	89 04 24             	mov    %eax,(%esp)
  1068d8:	e8 c0 3c 00 00       	call   10a59d <vm86_load_segregs>
  return 0;
  1068dd:	b8 00 00 00 00       	mov    $0x0,%eax
}
  1068e2:	c9                   	leave  
  1068e3:	c3                   	ret    

001068e4 <proc_shedule>:

/**
 * Loads next process for execution
 */
void proc_shedule() {
  1068e4:	55                   	push   %ebp
  1068e5:	89 e5                	mov    %esp,%ebp
  1068e7:	83 ec 18             	sub    $0x18,%esp
  size_t i;
  proc_t *proc;
  proc_t *proc_old = proc_current;
  1068ea:	a1 a0 e1 10 00       	mov    0x10e1a0,%eax
  1068ef:	89 45 fc             	mov    %eax,-0x4(%ebp)

  // if no processes running hold machine (until next interrupt)
  if (llist_empty(proc_running)) {
  1068f2:	a1 9c e1 10 00       	mov    0x10e19c,%eax
  1068f7:	89 04 24             	mov    %eax,(%esp)
  1068fa:	e8 24 40 00 00       	call   10a923 <llist_size>
  1068ff:	85 c0                	test   %eax,%eax
  106901:	75 34                	jne    106937 <proc_shedule+0x53>
    // if no processes at all, shutdown
    if (llist_empty(proc_sleeping)) cpu_shutdown();
  106903:	a1 50 e4 10 00       	mov    0x10e450,%eax
  106908:	89 04 24             	mov    %eax,(%esp)
  10690b:	e8 13 40 00 00       	call   10a923 <llist_size>
  106910:	85 c0                	test   %eax,%eax
  106912:	75 07                	jne    10691b <proc_shedule+0x37>
  106914:	e8 08 9b ff ff       	call   100421 <cpu_shutdown>
  106919:	eb 1c                	jmp    106937 <proc_shedule+0x53>
    else {
      /// @todo maybe put these 2 lines in proc_idle
      proc_regs_save(proc_current);
  10691b:	a1 a0 e1 10 00       	mov    0x10e1a0,%eax
  106920:	89 04 24             	mov    %eax,(%esp)
  106923:	e8 c2 fd ff ff       	call   1066ea <proc_regs_save>
      proc_current = NULL;
  106928:	c7 05 a0 e1 10 00 00 	movl   $0x0,0x10e1a0
  10692f:	00 00 00 
      proc_idle();
  106932:	e8 e9 07 00 00       	call   107120 <proc_idle>
    }
  }

  // Process finished its time slice
  if (proc_current!=NULL) {
  106937:	a1 a0 e1 10 00       	mov    0x10e1a0,%eax
  10693c:	85 c0                	test   %eax,%eax
  10693e:	74 18                	je     106958 <proc_shedule+0x74>
    proc_current->ticks_rem--;
  106940:	a1 a0 e1 10 00       	mov    0x10e1a0,%eax
  106945:	8b 50 78             	mov    0x78(%eax),%edx
  106948:	83 ea 01             	sub    $0x1,%edx
  10694b:	89 50 78             	mov    %edx,0x78(%eax)
    proc_current = NULL;
  10694e:	c7 05 a0 e1 10 00 00 	movl   $0x0,0x10e1a0
  106955:	00 00 00 
  }

//kprintf("running=%d; sleeping=%d\r",llist_size(proc_running),llist_size(proc_sleeping));

  // Search for process that still has time
  for (i=0;(proc = llist_get(proc_running,i));i++) {
  106958:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  10695f:	eb 16                	jmp    106977 <proc_shedule+0x93>
    if (proc->ticks_rem>0) proc_current = proc;
  106961:	8b 45 f8             	mov    -0x8(%ebp),%eax
  106964:	8b 40 78             	mov    0x78(%eax),%eax
  106967:	85 c0                	test   %eax,%eax
  106969:	74 08                	je     106973 <proc_shedule+0x8f>
  10696b:	8b 45 f8             	mov    -0x8(%ebp),%eax
  10696e:	a3 a0 e1 10 00       	mov    %eax,0x10e1a0
  }

//kprintf("running=%d; sleeping=%d\r",llist_size(proc_running),llist_size(proc_sleeping));

  // Search for process that still has time
  for (i=0;(proc = llist_get(proc_running,i));i++) {
  106973:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
  106977:	a1 9c e1 10 00       	mov    0x10e19c,%eax
  10697c:	8b 55 f4             	mov    -0xc(%ebp),%edx
  10697f:	89 54 24 04          	mov    %edx,0x4(%esp)
  106983:	89 04 24             	mov    %eax,(%esp)
  106986:	e8 fc 40 00 00       	call   10aa87 <llist_get>
  10698b:	89 45 f8             	mov    %eax,-0x8(%ebp)
  10698e:	83 7d f8 00          	cmpl   $0x0,-0x8(%ebp)
  106992:	75 cd                	jne    106961 <proc_shedule+0x7d>
    if (proc->ticks_rem>0) proc_current = proc;
  }

  // If no processes with time, fill time slices
  if (proc_current==NULL) {
  106994:	a1 a0 e1 10 00       	mov    0x10e1a0,%eax
  106999:	85 c0                	test   %eax,%eax
  10699b:	75 4e                	jne    1069eb <proc_shedule+0x107>
    //kprintf("Refilling time slices\n");
    for (i=0;(proc = llist_get(proc_running,i));i++) proc->ticks_rem = NICE2TICKS(proc->nice);
  10699d:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  1069a4:	eb 0e                	jmp    1069b4 <proc_shedule+0xd0>
  1069a6:	8b 45 f8             	mov    -0x8(%ebp),%eax
  1069a9:	c7 40 78 01 00 00 00 	movl   $0x1,0x78(%eax)
  1069b0:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
  1069b4:	a1 9c e1 10 00       	mov    0x10e19c,%eax
  1069b9:	8b 55 f4             	mov    -0xc(%ebp),%edx
  1069bc:	89 54 24 04          	mov    %edx,0x4(%esp)
  1069c0:	89 04 24             	mov    %eax,(%esp)
  1069c3:	e8 bf 40 00 00       	call   10aa87 <llist_get>
  1069c8:	89 45 f8             	mov    %eax,-0x8(%ebp)
  1069cb:	83 7d f8 00          	cmpl   $0x0,-0x8(%ebp)
  1069cf:	75 d5                	jne    1069a6 <proc_shedule+0xc2>
    proc_current = llist_get(proc_running,0);
  1069d1:	a1 9c e1 10 00       	mov    0x10e19c,%eax
  1069d6:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  1069dd:	00 
  1069de:	89 04 24             	mov    %eax,(%esp)
  1069e1:	e8 a1 40 00 00       	call   10aa87 <llist_get>
  1069e6:	a3 a0 e1 10 00       	mov    %eax,0x10e1a0
  }

  // Set context and load address space
  if (proc_old!=proc_current) {
  1069eb:	a1 a0 e1 10 00       	mov    0x10e1a0,%eax
  1069f0:	39 45 fc             	cmp    %eax,-0x4(%ebp)
  1069f3:	74 2e                	je     106a23 <proc_shedule+0x13f>
    if (proc_old!=NULL) proc_regs_save(proc_old);
  1069f5:	83 7d fc 00          	cmpl   $0x0,-0x4(%ebp)
  1069f9:	74 0b                	je     106a06 <proc_shedule+0x122>
  1069fb:	8b 45 fc             	mov    -0x4(%ebp),%eax
  1069fe:	89 04 24             	mov    %eax,(%esp)
  106a01:	e8 e4 fc ff ff       	call   1066ea <proc_regs_save>
    proc_regs_load(proc_current);
  106a06:	a1 a0 e1 10 00       	mov    0x10e1a0,%eax
  106a0b:	89 04 24             	mov    %eax,(%esp)
  106a0e:	e8 cc fd ff ff       	call   1067df <proc_regs_load>
    memuser_load_addrspace(proc_current->addrspace);
  106a13:	a1 a0 e1 10 00       	mov    0x10e1a0,%eax
  106a18:	8b 40 6c             	mov    0x6c(%eax),%eax
  106a1b:	89 04 24             	mov    %eax,(%esp)
  106a1e:	e8 f8 d1 ff ff       	call   103c1b <memuser_load_addrspace>
  }
}
  106a23:	c9                   	leave  
  106a24:	c3                   	ret    

00106a25 <proc_getpid>:

/**
 * Gets PID (Syscall)
 *  @return PID
 */
pid_t proc_getpid() {
  106a25:	55                   	push   %ebp
  106a26:	89 e5                	mov    %esp,%ebp
  return proc_current->pid;
  106a28:	a1 a0 e1 10 00       	mov    0x10e1a0,%eax
  106a2d:	8b 00                	mov    (%eax),%eax
}
  106a2f:	5d                   	pop    %ebp
  106a30:	c3                   	ret    

00106a31 <proc_getparent>:
/**
 * Gets Parent PID (Syscall)
 *  @param pid Process to get parent's PID of
 *  @return Parent's PID
 */
pid_t proc_getparent(pid_t pid) {
  106a31:	55                   	push   %ebp
  106a32:	89 e5                	mov    %esp,%ebp
  106a34:	83 ec 18             	sub    $0x18,%esp
  proc_t *proc = proc_find(pid);
  106a37:	8b 45 08             	mov    0x8(%ebp),%eax
  106a3a:	89 04 24             	mov    %eax,(%esp)
  106a3d:	e8 2d fb ff ff       	call   10656f <proc_find>
  106a42:	89 45 fc             	mov    %eax,-0x4(%ebp)
  if (proc!=NULL) {
  106a45:	83 7d fc 00          	cmpl   $0x0,-0x4(%ebp)
  106a49:	74 17                	je     106a62 <proc_getparent+0x31>
    if (proc->parent!=NULL) return proc->parent->pid;
  106a4b:	8b 45 fc             	mov    -0x4(%ebp),%eax
  106a4e:	8b 40 24             	mov    0x24(%eax),%eax
  106a51:	85 c0                	test   %eax,%eax
  106a53:	74 0d                	je     106a62 <proc_getparent+0x31>
  106a55:	8b 45 fc             	mov    -0x4(%ebp),%eax
  106a58:	8b 40 24             	mov    0x24(%eax),%eax
  106a5b:	8b 00                	mov    (%eax),%eax
  106a5d:	89 45 ec             	mov    %eax,-0x14(%ebp)
  106a60:	eb 07                	jmp    106a69 <proc_getparent+0x38>
  }
  return 0;
  106a62:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
  106a69:	8b 45 ec             	mov    -0x14(%ebp),%eax
}
  106a6c:	c9                   	leave  
  106a6d:	c3                   	ret    

00106a6e <proc_getchild>:
 * Gets PID of a child (Syscall)
 *  @param pid Process to get child's PID of
 *  @param i Number of child
 *  @return Child's PID
 */
pid_t proc_getchild(pid_t pid,size_t i) {
  106a6e:	55                   	push   %ebp
  106a6f:	89 e5                	mov    %esp,%ebp
  106a71:	83 ec 28             	sub    $0x28,%esp
  proc_t *proc = proc_find(pid);
  106a74:	8b 45 08             	mov    0x8(%ebp),%eax
  106a77:	89 04 24             	mov    %eax,(%esp)
  106a7a:	e8 f0 fa ff ff       	call   10656f <proc_find>
  106a7f:	89 45 f8             	mov    %eax,-0x8(%ebp)
  if (proc!=NULL) {
  106a82:	83 7d f8 00          	cmpl   $0x0,-0x8(%ebp)
  106a86:	74 3e                	je     106ac6 <proc_getchild+0x58>
    if (proc->parent!=NULL) {
  106a88:	8b 45 f8             	mov    -0x8(%ebp),%eax
  106a8b:	8b 40 24             	mov    0x24(%eax),%eax
  106a8e:	85 c0                	test   %eax,%eax
  106a90:	74 34                	je     106ac6 <proc_getchild+0x58>
      proc_t *child = llist_get(proc->parent->children,i);
  106a92:	8b 45 f8             	mov    -0x8(%ebp),%eax
  106a95:	8b 40 24             	mov    0x24(%eax),%eax
  106a98:	8b 50 28             	mov    0x28(%eax),%edx
  106a9b:	8b 45 0c             	mov    0xc(%ebp),%eax
  106a9e:	89 44 24 04          	mov    %eax,0x4(%esp)
  106aa2:	89 14 24             	mov    %edx,(%esp)
  106aa5:	e8 dd 3f 00 00       	call   10aa87 <llist_get>
  106aaa:	89 45 fc             	mov    %eax,-0x4(%ebp)
      if (child==NULL) return -1;
  106aad:	83 7d fc 00          	cmpl   $0x0,-0x4(%ebp)
  106ab1:	75 09                	jne    106abc <proc_getchild+0x4e>
  106ab3:	c7 45 ec ff ff ff ff 	movl   $0xffffffff,-0x14(%ebp)
  106aba:	eb 11                	jmp    106acd <proc_getchild+0x5f>
      else return child->pid;
  106abc:	8b 45 fc             	mov    -0x4(%ebp),%eax
  106abf:	8b 00                	mov    (%eax),%eax
  106ac1:	89 45 ec             	mov    %eax,-0x14(%ebp)
  106ac4:	eb 07                	jmp    106acd <proc_getchild+0x5f>
    }
  }
  return 0;
  106ac6:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
  106acd:	8b 45 ec             	mov    -0x14(%ebp),%eax
}
  106ad0:	c9                   	leave  
  106ad1:	c3                   	ret    

00106ad2 <proc_getuid>:
/**
 * Gets UID (Syscall)
 *  @param idmask Which ID to return
 *  @return UID
 */
uid_t proc_getuid(int idmask) {
  106ad2:	55                   	push   %ebp
  106ad3:	89 e5                	mov    %esp,%ebp
  106ad5:	83 ec 04             	sub    $0x4,%esp
  if ((idmask&1)) return proc_current->uid;
  106ad8:	8b 45 08             	mov    0x8(%ebp),%eax
  106adb:	83 e0 01             	and    $0x1,%eax
  106ade:	84 c0                	test   %al,%al
  106ae0:	74 0d                	je     106aef <proc_getuid+0x1d>
  106ae2:	a1 a0 e1 10 00       	mov    0x10e1a0,%eax
  106ae7:	8b 40 04             	mov    0x4(%eax),%eax
  106aea:	89 45 fc             	mov    %eax,-0x4(%ebp)
  106aed:	eb 35                	jmp    106b24 <proc_getuid+0x52>
  else if ((idmask&2)) return proc_current->euid;
  106aef:	8b 45 08             	mov    0x8(%ebp),%eax
  106af2:	83 e0 02             	and    $0x2,%eax
  106af5:	85 c0                	test   %eax,%eax
  106af7:	74 0d                	je     106b06 <proc_getuid+0x34>
  106af9:	a1 a0 e1 10 00       	mov    0x10e1a0,%eax
  106afe:	8b 40 08             	mov    0x8(%eax),%eax
  106b01:	89 45 fc             	mov    %eax,-0x4(%ebp)
  106b04:	eb 1e                	jmp    106b24 <proc_getuid+0x52>
  else if ((idmask&4)) return proc_current->suid;
  106b06:	8b 45 08             	mov    0x8(%ebp),%eax
  106b09:	83 e0 04             	and    $0x4,%eax
  106b0c:	85 c0                	test   %eax,%eax
  106b0e:	74 0d                	je     106b1d <proc_getuid+0x4b>
  106b10:	a1 a0 e1 10 00       	mov    0x10e1a0,%eax
  106b15:	8b 40 0c             	mov    0xc(%eax),%eax
  106b18:	89 45 fc             	mov    %eax,-0x4(%ebp)
  106b1b:	eb 07                	jmp    106b24 <proc_getuid+0x52>
  else return 0;
  106b1d:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
  106b24:	8b 45 fc             	mov    -0x4(%ebp),%eax
}
  106b27:	c9                   	leave  
  106b28:	c3                   	ret    

00106b29 <proc_setuid>:
 * Sets UID (Syscall)
 *  @param idmask Which ID to set
 *  @param uid New UID
 *  @todo Check permissions
 */
void proc_setuid(int idmask,uid_t uid) {
  106b29:	55                   	push   %ebp
  106b2a:	89 e5                	mov    %esp,%ebp
  if ((idmask&1)) proc_current->uid = uid;
  106b2c:	8b 45 08             	mov    0x8(%ebp),%eax
  106b2f:	83 e0 01             	and    $0x1,%eax
  106b32:	84 c0                	test   %al,%al
  106b34:	74 0e                	je     106b44 <proc_setuid+0x1b>
  106b36:	8b 15 a0 e1 10 00    	mov    0x10e1a0,%edx
  106b3c:	8b 45 0c             	mov    0xc(%ebp),%eax
  106b3f:	89 42 04             	mov    %eax,0x4(%edx)
  106b42:	eb 2e                	jmp    106b72 <proc_setuid+0x49>
  else if ((idmask&2)) proc_current->euid = uid;
  106b44:	8b 45 08             	mov    0x8(%ebp),%eax
  106b47:	83 e0 02             	and    $0x2,%eax
  106b4a:	85 c0                	test   %eax,%eax
  106b4c:	74 0e                	je     106b5c <proc_setuid+0x33>
  106b4e:	8b 15 a0 e1 10 00    	mov    0x10e1a0,%edx
  106b54:	8b 45 0c             	mov    0xc(%ebp),%eax
  106b57:	89 42 08             	mov    %eax,0x8(%edx)
  106b5a:	eb 16                	jmp    106b72 <proc_setuid+0x49>
  else if ((idmask&4)) proc_current->suid = uid;
  106b5c:	8b 45 08             	mov    0x8(%ebp),%eax
  106b5f:	83 e0 04             	and    $0x4,%eax
  106b62:	85 c0                	test   %eax,%eax
  106b64:	74 0c                	je     106b72 <proc_setuid+0x49>
  106b66:	8b 15 a0 e1 10 00    	mov    0x10e1a0,%edx
  106b6c:	8b 45 0c             	mov    0xc(%ebp),%eax
  106b6f:	89 42 0c             	mov    %eax,0xc(%edx)
}
  106b72:	5d                   	pop    %ebp
  106b73:	c3                   	ret    

00106b74 <proc_getgid>:
/**
 * Gets GID (Syscall)
 *  @param idmask Which ID to return
 *  @return GID
 */
gid_t proc_getgid(int idmask) {
  106b74:	55                   	push   %ebp
  106b75:	89 e5                	mov    %esp,%ebp
  106b77:	83 ec 04             	sub    $0x4,%esp
  if ((idmask&1)) return proc_current->gid;
  106b7a:	8b 45 08             	mov    0x8(%ebp),%eax
  106b7d:	83 e0 01             	and    $0x1,%eax
  106b80:	84 c0                	test   %al,%al
  106b82:	74 0d                	je     106b91 <proc_getgid+0x1d>
  106b84:	a1 a0 e1 10 00       	mov    0x10e1a0,%eax
  106b89:	8b 40 10             	mov    0x10(%eax),%eax
  106b8c:	89 45 fc             	mov    %eax,-0x4(%ebp)
  106b8f:	eb 35                	jmp    106bc6 <proc_getgid+0x52>
  else if ((idmask&2)) return proc_current->egid;
  106b91:	8b 45 08             	mov    0x8(%ebp),%eax
  106b94:	83 e0 02             	and    $0x2,%eax
  106b97:	85 c0                	test   %eax,%eax
  106b99:	74 0d                	je     106ba8 <proc_getgid+0x34>
  106b9b:	a1 a0 e1 10 00       	mov    0x10e1a0,%eax
  106ba0:	8b 40 14             	mov    0x14(%eax),%eax
  106ba3:	89 45 fc             	mov    %eax,-0x4(%ebp)
  106ba6:	eb 1e                	jmp    106bc6 <proc_getgid+0x52>
  else if ((idmask&4)) return proc_current->sgid;
  106ba8:	8b 45 08             	mov    0x8(%ebp),%eax
  106bab:	83 e0 04             	and    $0x4,%eax
  106bae:	85 c0                	test   %eax,%eax
  106bb0:	74 0d                	je     106bbf <proc_getgid+0x4b>
  106bb2:	a1 a0 e1 10 00       	mov    0x10e1a0,%eax
  106bb7:	8b 40 18             	mov    0x18(%eax),%eax
  106bba:	89 45 fc             	mov    %eax,-0x4(%ebp)
  106bbd:	eb 07                	jmp    106bc6 <proc_getgid+0x52>
  else return 0;
  106bbf:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
  106bc6:	8b 45 fc             	mov    -0x4(%ebp),%eax
}
  106bc9:	c9                   	leave  
  106bca:	c3                   	ret    

00106bcb <proc_setgid>:
 * Sets GID (Syscall)
 *  @param idmask Which ID to set
 *  @param uid New GID
 *  @todo Check permissions
 */
void proc_setgid(int idmask,gid_t gid) {
  106bcb:	55                   	push   %ebp
  106bcc:	89 e5                	mov    %esp,%ebp
  if ((idmask&1)) proc_current->gid = gid;
  106bce:	8b 45 08             	mov    0x8(%ebp),%eax
  106bd1:	83 e0 01             	and    $0x1,%eax
  106bd4:	84 c0                	test   %al,%al
  106bd6:	74 0e                	je     106be6 <proc_setgid+0x1b>
  106bd8:	8b 15 a0 e1 10 00    	mov    0x10e1a0,%edx
  106bde:	8b 45 0c             	mov    0xc(%ebp),%eax
  106be1:	89 42 10             	mov    %eax,0x10(%edx)
  106be4:	eb 2e                	jmp    106c14 <proc_setgid+0x49>
  else if ((idmask&2)) proc_current->egid = gid;
  106be6:	8b 45 08             	mov    0x8(%ebp),%eax
  106be9:	83 e0 02             	and    $0x2,%eax
  106bec:	85 c0                	test   %eax,%eax
  106bee:	74 0e                	je     106bfe <proc_setgid+0x33>
  106bf0:	8b 15 a0 e1 10 00    	mov    0x10e1a0,%edx
  106bf6:	8b 45 0c             	mov    0xc(%ebp),%eax
  106bf9:	89 42 14             	mov    %eax,0x14(%edx)
  106bfc:	eb 16                	jmp    106c14 <proc_setgid+0x49>
  else if ((idmask&4)) proc_current->sgid = gid;
  106bfe:	8b 45 08             	mov    0x8(%ebp),%eax
  106c01:	83 e0 04             	and    $0x4,%eax
  106c04:	85 c0                	test   %eax,%eax
  106c06:	74 0c                	je     106c14 <proc_setgid+0x49>
  106c08:	8b 15 a0 e1 10 00    	mov    0x10e1a0,%edx
  106c0e:	8b 45 0c             	mov    0xc(%ebp),%eax
  106c11:	89 42 18             	mov    %eax,0x18(%edx)
}
  106c14:	5d                   	pop    %ebp
  106c15:	c3                   	ret    

00106c16 <proc_getname>:
 *  @param pid PID
 *  @param buf Buffer for name
 *  @param maxlen Maximal length of name
 *  @return Success? (if buf==NULL length of name is returned)
 */
ssize_t proc_getname(pid_t pid,char *buf,size_t maxlen) {
  106c16:	55                   	push   %ebp
  106c17:	89 e5                	mov    %esp,%ebp
  106c19:	83 ec 28             	sub    $0x28,%esp
  proc_t *proc = proc_find(pid);
  106c1c:	8b 45 08             	mov    0x8(%ebp),%eax
  106c1f:	89 04 24             	mov    %eax,(%esp)
  106c22:	e8 48 f9 ff ff       	call   10656f <proc_find>
  106c27:	89 45 fc             	mov    %eax,-0x4(%ebp)
  if (proc!=NULL) {
  106c2a:	83 7d fc 00          	cmpl   $0x0,-0x4(%ebp)
  106c2e:	74 41                	je     106c71 <proc_getname+0x5b>
    if (buf!=NULL) {
  106c30:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
  106c34:	74 25                	je     106c5b <proc_getname+0x45>
      strncpy(buf,proc->name,maxlen);
  106c36:	8b 45 fc             	mov    -0x4(%ebp),%eax
  106c39:	8b 50 20             	mov    0x20(%eax),%edx
  106c3c:	8b 45 10             	mov    0x10(%ebp),%eax
  106c3f:	89 44 24 08          	mov    %eax,0x8(%esp)
  106c43:	89 54 24 04          	mov    %edx,0x4(%esp)
  106c47:	8b 45 0c             	mov    0xc(%ebp),%eax
  106c4a:	89 04 24             	mov    %eax,(%esp)
  106c4d:	e8 2a 54 00 00       	call   10c07c <strncpy>
      return 0;
  106c52:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
  106c59:	eb 1d                	jmp    106c78 <proc_getname+0x62>
    }
    else return strlen(proc->name)+1;
  106c5b:	8b 45 fc             	mov    -0x4(%ebp),%eax
  106c5e:	8b 40 20             	mov    0x20(%eax),%eax
  106c61:	89 04 24             	mov    %eax,(%esp)
  106c64:	e8 d3 52 00 00       	call   10bf3c <strlen>
  106c69:	83 c0 01             	add    $0x1,%eax
  106c6c:	89 45 ec             	mov    %eax,-0x14(%ebp)
  106c6f:	eb 07                	jmp    106c78 <proc_getname+0x62>
  }
  else return -1;
  106c71:	c7 45 ec ff ff ff ff 	movl   $0xffffffff,-0x14(%ebp)
  106c78:	8b 45 ec             	mov    -0x14(%ebp),%eax
}
  106c7b:	c9                   	leave  
  106c7c:	c3                   	ret    

00106c7d <proc_setname>:
 * Sets new process name (Syscall)
 *  @param proc_pid PID
 *  @param name New process name
 *  @return Success?
 */
int proc_setname(pid_t proc_pid,const char *name) {
  106c7d:	55                   	push   %ebp
  106c7e:	89 e5                	mov    %esp,%ebp
  106c80:	83 ec 18             	sub    $0x18,%esp
  if (proc_current->system) {
  106c83:	a1 a0 e1 10 00       	mov    0x10e1a0,%eax
  106c88:	8b 40 1c             	mov    0x1c(%eax),%eax
  106c8b:	85 c0                	test   %eax,%eax
  106c8d:	74 3f                	je     106cce <proc_setname+0x51>
    proc_t *proc = proc_find(proc_pid);
  106c8f:	8b 45 08             	mov    0x8(%ebp),%eax
  106c92:	89 04 24             	mov    %eax,(%esp)
  106c95:	e8 d5 f8 ff ff       	call   10656f <proc_find>
  106c9a:	89 45 fc             	mov    %eax,-0x4(%ebp)
    if (proc!=NULL && proc!=proc_current) {
  106c9d:	83 7d fc 00          	cmpl   $0x0,-0x4(%ebp)
  106ca1:	74 2b                	je     106cce <proc_setname+0x51>
  106ca3:	a1 a0 e1 10 00       	mov    0x10e1a0,%eax
  106ca8:	39 45 fc             	cmp    %eax,-0x4(%ebp)
  106cab:	74 21                	je     106cce <proc_setname+0x51>
      free(proc->name);
  106cad:	8b 45 fc             	mov    -0x4(%ebp),%eax
  106cb0:	8b 40 20             	mov    0x20(%eax),%eax
  106cb3:	89 04 24             	mov    %eax,(%esp)
  106cb6:	e8 e2 c2 ff ff       	call   102f9d <free>
      proc->name = strdup(name);
  106cbb:	8b 45 0c             	mov    0xc(%ebp),%eax
  106cbe:	89 04 24             	mov    %eax,(%esp)
  106cc1:	e8 2b 52 00 00       	call   10bef1 <strdup>
  106cc6:	89 c2                	mov    %eax,%edx
  106cc8:	8b 45 fc             	mov    -0x4(%ebp),%eax
  106ccb:	89 50 20             	mov    %edx,0x20(%eax)
    }
  }
  return -1;
  106cce:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
}
  106cd3:	c9                   	leave  
  106cd4:	c3                   	ret    

00106cd5 <proc_getpidbyname>:
/**
 * Gets PID by process name
 *  @param name Process name
 *  @return PID of process
 */
pid_t proc_getpidbyname(const char *name) {
  106cd5:	55                   	push   %ebp
  106cd6:	89 e5                	mov    %esp,%ebp
  106cd8:	83 ec 28             	sub    $0x28,%esp
  size_t i;
  proc_t *proc;
  for (i=0;(proc = llist_get(proc_all,i));i++) {
  106cdb:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
  106ce2:	eb 27                	jmp    106d0b <proc_getpidbyname+0x36>
    if (strcmp(proc->name,name)==0) return proc->pid;
  106ce4:	8b 45 fc             	mov    -0x4(%ebp),%eax
  106ce7:	8b 50 20             	mov    0x20(%eax),%edx
  106cea:	8b 45 08             	mov    0x8(%ebp),%eax
  106ced:	89 44 24 04          	mov    %eax,0x4(%esp)
  106cf1:	89 14 24             	mov    %edx,(%esp)
  106cf4:	e8 23 51 00 00       	call   10be1c <strcmp>
  106cf9:	85 c0                	test   %eax,%eax
  106cfb:	75 0a                	jne    106d07 <proc_getpidbyname+0x32>
  106cfd:	8b 45 fc             	mov    -0x4(%ebp),%eax
  106d00:	8b 00                	mov    (%eax),%eax
  106d02:	89 45 ec             	mov    %eax,-0x14(%ebp)
  106d05:	eb 28                	jmp    106d2f <proc_getpidbyname+0x5a>
 *  @return PID of process
 */
pid_t proc_getpidbyname(const char *name) {
  size_t i;
  proc_t *proc;
  for (i=0;(proc = llist_get(proc_all,i));i++) {
  106d07:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
  106d0b:	a1 80 e1 10 00       	mov    0x10e180,%eax
  106d10:	8b 55 f8             	mov    -0x8(%ebp),%edx
  106d13:	89 54 24 04          	mov    %edx,0x4(%esp)
  106d17:	89 04 24             	mov    %eax,(%esp)
  106d1a:	e8 68 3d 00 00       	call   10aa87 <llist_get>
  106d1f:	89 45 fc             	mov    %eax,-0x4(%ebp)
  106d22:	83 7d fc 00          	cmpl   $0x0,-0x4(%ebp)
  106d26:	75 bc                	jne    106ce4 <proc_getpidbyname+0xf>
    if (strcmp(proc->name,name)==0) return proc->pid;
  }
  return -1;
  106d28:	c7 45 ec ff ff ff ff 	movl   $0xffffffff,-0x14(%ebp)
  106d2f:	8b 45 ec             	mov    -0x14(%ebp),%eax
}
  106d32:	c9                   	leave  
  106d33:	c3                   	ret    

00106d34 <proc_getvar>:
/**
 * Gets private variable
 *  @param pid Process' PID
 *  @return private variable
 */
int proc_getvar(pid_t pid) {
  106d34:	55                   	push   %ebp
  106d35:	89 e5                	mov    %esp,%ebp
  106d37:	83 ec 18             	sub    $0x18,%esp
  proc_t *proc = proc_find(pid);
  106d3a:	8b 45 08             	mov    0x8(%ebp),%eax
  106d3d:	89 04 24             	mov    %eax,(%esp)
  106d40:	e8 2a f8 ff ff       	call   10656f <proc_find>
  106d45:	89 45 fc             	mov    %eax,-0x4(%ebp)
  if (proc!=NULL && (proc_current->system || proc_current==proc)) return proc->var;
  106d48:	83 7d fc 00          	cmpl   $0x0,-0x4(%ebp)
  106d4c:	74 24                	je     106d72 <proc_getvar+0x3e>
  106d4e:	a1 a0 e1 10 00       	mov    0x10e1a0,%eax
  106d53:	8b 40 1c             	mov    0x1c(%eax),%eax
  106d56:	85 c0                	test   %eax,%eax
  106d58:	75 0a                	jne    106d64 <proc_getvar+0x30>
  106d5a:	a1 a0 e1 10 00       	mov    0x10e1a0,%eax
  106d5f:	3b 45 fc             	cmp    -0x4(%ebp),%eax
  106d62:	75 0e                	jne    106d72 <proc_getvar+0x3e>
  106d64:	8b 45 fc             	mov    -0x4(%ebp),%eax
  106d67:	8b 80 80 00 00 00    	mov    0x80(%eax),%eax
  106d6d:	89 45 ec             	mov    %eax,-0x14(%ebp)
  106d70:	eb 07                	jmp    106d79 <proc_getvar+0x45>
  else return -1;
  106d72:	c7 45 ec ff ff ff ff 	movl   $0xffffffff,-0x14(%ebp)
  106d79:	8b 45 ec             	mov    -0x14(%ebp),%eax
}
  106d7c:	c9                   	leave  
  106d7d:	c3                   	ret    

00106d7e <proc_setvar>:
/**
 * Sets private variable
 *  @param pid Process' PID
 *  @param var New private variable
 */
void proc_setvar(pid_t pid,int var) {
  106d7e:	55                   	push   %ebp
  106d7f:	89 e5                	mov    %esp,%ebp
  106d81:	83 ec 18             	sub    $0x18,%esp
  proc_t *proc = proc_find(pid);
  106d84:	8b 45 08             	mov    0x8(%ebp),%eax
  106d87:	89 04 24             	mov    %eax,(%esp)
  106d8a:	e8 e0 f7 ff ff       	call   10656f <proc_find>
  106d8f:	89 45 fc             	mov    %eax,-0x4(%ebp)
  if (proc!=NULL) proc->var = var;
  106d92:	83 7d fc 00          	cmpl   $0x0,-0x4(%ebp)
  106d96:	74 0c                	je     106da4 <proc_setvar+0x26>
  106d98:	8b 55 fc             	mov    -0x4(%ebp),%edx
  106d9b:	8b 45 0c             	mov    0xc(%ebp),%eax
  106d9e:	89 82 80 00 00 00    	mov    %eax,0x80(%edx)
}
  106da4:	c9                   	leave  
  106da5:	c3                   	ret    

00106da6 <proc_waitpid>:
 * Waits for child(ren)
 *  @param pid PID of child to wait for (-1 for all childs)
 *  @param stat_loc Reference for status
 *  @param options Options
 */
pid_t proc_waitpid(pid_t pid,int *stat_loc,int options) {
  106da6:	55                   	push   %ebp
  106da7:	89 e5                	mov    %esp,%ebp
  106da9:	83 ec 18             	sub    $0x18,%esp
  if (pid>0) {
  106dac:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
  106db0:	7e 40                	jle    106df2 <proc_waitpid+0x4c>
    proc_t *proc = proc_find(pid);
  106db2:	8b 45 08             	mov    0x8(%ebp),%eax
  106db5:	89 04 24             	mov    %eax,(%esp)
  106db8:	e8 b2 f7 ff ff       	call   10656f <proc_find>
  106dbd:	89 45 fc             	mov    %eax,-0x4(%ebp)
    if (proc!=NULL) {
  106dc0:	83 7d fc 00          	cmpl   $0x0,-0x4(%ebp)
  106dc4:	74 23                	je     106de9 <proc_waitpid+0x43>
      if (proc->defunc) {
  106dc6:	8b 45 fc             	mov    -0x4(%ebp),%eax
  106dc9:	8b 80 84 00 00 00    	mov    0x84(%eax),%eax
  106dcf:	85 c0                	test   %eax,%eax
  106dd1:	74 1f                	je     106df2 <proc_waitpid+0x4c>
        *stat_loc = proc->ret;
  106dd3:	8b 45 fc             	mov    -0x4(%ebp),%eax
  106dd6:	8b 90 88 00 00 00    	mov    0x88(%eax),%edx
  106ddc:	8b 45 0c             	mov    0xc(%ebp),%eax
  106ddf:	89 10                	mov    %edx,(%eax)
        /// @todo remove child
        return pid;
  106de1:	8b 45 08             	mov    0x8(%ebp),%eax
  106de4:	89 45 ec             	mov    %eax,-0x14(%ebp)
  106de7:	eb 4a                	jmp    106e33 <proc_waitpid+0x8d>
      }
    }
    else return -1;
  106de9:	c7 45 ec ff ff ff ff 	movl   $0xffffffff,-0x14(%ebp)
  106df0:	eb 41                	jmp    106e33 <proc_waitpid+0x8d>
  }
  proc_current->wait_pid = pid;
  106df2:	8b 15 a0 e1 10 00    	mov    0x10e1a0,%edx
  106df8:	8b 45 08             	mov    0x8(%ebp),%eax
  106dfb:	89 82 9c 00 00 00    	mov    %eax,0x9c(%edx)
  proc_current->wait_stat = stat_loc;
  106e01:	8b 15 a0 e1 10 00    	mov    0x10e1a0,%edx
  106e07:	8b 45 0c             	mov    0xc(%ebp),%eax
  106e0a:	89 82 a0 00 00 00    	mov    %eax,0xa0(%edx)
  proc_current->wait = 1;
  106e10:	a1 a0 e1 10 00       	mov    0x10e1a0,%eax
  106e15:	c7 80 98 00 00 00 01 	movl   $0x1,0x98(%eax)
  106e1c:	00 00 00 
  proc_sleep(proc_current);
  106e1f:	a1 a0 e1 10 00       	mov    0x10e1a0,%eax
  106e24:	89 04 24             	mov    %eax,(%esp)
  106e27:	e8 f5 f7 ff ff       	call   106621 <proc_sleep>
  return -1;
  106e2c:	c7 45 ec ff ff ff ff 	movl   $0xffffffff,-0x14(%ebp)
  106e33:	8b 45 ec             	mov    -0x14(%ebp),%eax
}
  106e36:	c9                   	leave  
  106e37:	c3                   	ret    

00106e38 <proc_exit>:

/**
 * Exits process (Syscall)
 *  @param ret Return value
 */
void proc_exit(int ret) {
  106e38:	55                   	push   %ebp
  106e39:	89 e5                	mov    %esp,%ebp
  106e3b:	83 ec 18             	sub    $0x18,%esp
  if (proc_current->parent!=NULL) {
  106e3e:	a1 a0 e1 10 00       	mov    0x10e1a0,%eax
  106e43:	8b 40 24             	mov    0x24(%eax),%eax
  106e46:	85 c0                	test   %eax,%eax
  106e48:	0f 84 ef 00 00 00    	je     106f3d <proc_exit+0x105>
    if (proc_current->parent->wait) {
  106e4e:	a1 a0 e1 10 00       	mov    0x10e1a0,%eax
  106e53:	8b 40 24             	mov    0x24(%eax),%eax
  106e56:	8b 80 98 00 00 00    	mov    0x98(%eax),%eax
  106e5c:	85 c0                	test   %eax,%eax
  106e5e:	0f 84 d9 00 00 00    	je     106f3d <proc_exit+0x105>
      pid_t pid = proc_current->parent->wait_pid;
  106e64:	a1 a0 e1 10 00       	mov    0x10e1a0,%eax
  106e69:	8b 40 24             	mov    0x24(%eax),%eax
  106e6c:	8b 80 9c 00 00 00    	mov    0x9c(%eax),%eax
  106e72:	89 45 fc             	mov    %eax,-0x4(%ebp)
      if (pid==-1 || pid==proc_current->pid || (pid==0 && proc_current->gid==proc_current->parent->gid) || (pid<-1 && -pid==proc_current->gid)) {
  106e75:	83 7d fc ff          	cmpl   $0xffffffff,-0x4(%ebp)
  106e79:	74 46                	je     106ec1 <proc_exit+0x89>
  106e7b:	a1 a0 e1 10 00       	mov    0x10e1a0,%eax
  106e80:	8b 00                	mov    (%eax),%eax
  106e82:	3b 45 fc             	cmp    -0x4(%ebp),%eax
  106e85:	74 3a                	je     106ec1 <proc_exit+0x89>
  106e87:	83 7d fc 00          	cmpl   $0x0,-0x4(%ebp)
  106e8b:	75 17                	jne    106ea4 <proc_exit+0x6c>
  106e8d:	a1 a0 e1 10 00       	mov    0x10e1a0,%eax
  106e92:	8b 50 10             	mov    0x10(%eax),%edx
  106e95:	a1 a0 e1 10 00       	mov    0x10e1a0,%eax
  106e9a:	8b 40 24             	mov    0x24(%eax),%eax
  106e9d:	8b 40 10             	mov    0x10(%eax),%eax
  106ea0:	39 c2                	cmp    %eax,%edx
  106ea2:	74 1d                	je     106ec1 <proc_exit+0x89>
  106ea4:	83 7d fc ff          	cmpl   $0xffffffff,-0x4(%ebp)
  106ea8:	0f 8d 8f 00 00 00    	jge    106f3d <proc_exit+0x105>
  106eae:	8b 45 fc             	mov    -0x4(%ebp),%eax
  106eb1:	89 c2                	mov    %eax,%edx
  106eb3:	f7 da                	neg    %edx
  106eb5:	a1 a0 e1 10 00       	mov    0x10e1a0,%eax
  106eba:	8b 40 10             	mov    0x10(%eax),%eax
  106ebd:	39 c2                	cmp    %eax,%edx
  106ebf:	75 7c                	jne    106f3d <proc_exit+0x105>
        proc_current->parent->registers.eax = proc_current->pid;
  106ec1:	a1 a0 e1 10 00       	mov    0x10e1a0,%eax
  106ec6:	8b 50 24             	mov    0x24(%eax),%edx
  106ec9:	a1 a0 e1 10 00       	mov    0x10e1a0,%eax
  106ece:	8b 00                	mov    (%eax),%eax
  106ed0:	89 42 2c             	mov    %eax,0x2c(%edx)
        if (proc_current->parent->wait_stat!=NULL) {
  106ed3:	a1 a0 e1 10 00       	mov    0x10e1a0,%eax
  106ed8:	8b 40 24             	mov    0x24(%eax),%eax
  106edb:	8b 80 a0 00 00 00    	mov    0xa0(%eax),%eax
  106ee1:	85 c0                	test   %eax,%eax
  106ee3:	74 36                	je     106f1b <proc_exit+0xe3>
          memuser_load_addrspace(proc_current->parent->addrspace);
  106ee5:	a1 a0 e1 10 00       	mov    0x10e1a0,%eax
  106eea:	8b 40 24             	mov    0x24(%eax),%eax
  106eed:	8b 40 6c             	mov    0x6c(%eax),%eax
  106ef0:	89 04 24             	mov    %eax,(%esp)
  106ef3:	e8 23 cd ff ff       	call   103c1b <memuser_load_addrspace>
          *(proc_current->parent->wait_stat) = ret;
  106ef8:	a1 a0 e1 10 00       	mov    0x10e1a0,%eax
  106efd:	8b 40 24             	mov    0x24(%eax),%eax
  106f00:	8b 90 a0 00 00 00    	mov    0xa0(%eax),%edx
  106f06:	8b 45 08             	mov    0x8(%ebp),%eax
  106f09:	89 02                	mov    %eax,(%edx)
          memuser_load_addrspace(proc_current->addrspace);
  106f0b:	a1 a0 e1 10 00       	mov    0x10e1a0,%eax
  106f10:	8b 40 6c             	mov    0x6c(%eax),%eax
  106f13:	89 04 24             	mov    %eax,(%esp)
  106f16:	e8 00 cd ff ff       	call   103c1b <memuser_load_addrspace>
        }
        proc_current->parent->wait = 0;
  106f1b:	a1 a0 e1 10 00       	mov    0x10e1a0,%eax
  106f20:	8b 40 24             	mov    0x24(%eax),%eax
  106f23:	c7 80 98 00 00 00 00 	movl   $0x0,0x98(%eax)
  106f2a:	00 00 00 
        proc_wake(proc_current->parent);
  106f2d:	a1 a0 e1 10 00       	mov    0x10e1a0,%eax
  106f32:	8b 40 24             	mov    0x24(%eax),%eax
  106f35:	89 04 24             	mov    %eax,(%esp)
  106f38:	e8 50 f7 ff ff       	call   10668d <proc_wake>
      }
    }
  }

  proc_current->ret = ret;
  106f3d:	8b 15 a0 e1 10 00    	mov    0x10e1a0,%edx
  106f43:	8b 45 08             	mov    0x8(%ebp),%eax
  106f46:	89 82 88 00 00 00    	mov    %eax,0x88(%edx)
  proc_current->defunc = 1;
  106f4c:	a1 a0 e1 10 00       	mov    0x10e1a0,%eax
  106f51:	c7 80 84 00 00 00 01 	movl   $0x1,0x84(%eax)
  106f58:	00 00 00 
  llist_remove(proc_running,llist_find(proc_running,proc_current));
  106f5b:	a1 a0 e1 10 00       	mov    0x10e1a0,%eax
  106f60:	8b 15 9c e1 10 00    	mov    0x10e19c,%edx
  106f66:	89 44 24 04          	mov    %eax,0x4(%esp)
  106f6a:	89 14 24             	mov    %edx,(%esp)
  106f6d:	e8 af 3c 00 00       	call   10ac21 <llist_find>
  106f72:	8b 15 9c e1 10 00    	mov    0x10e19c,%edx
  106f78:	89 44 24 04          	mov    %eax,0x4(%esp)
  106f7c:	89 14 24             	mov    %edx,(%esp)
  106f7f:	e8 d5 3b 00 00       	call   10ab59 <llist_remove>
  //memuser_destroy_addrspace(proc_current->addrspace);
  //proc_current->addrspace = NULL;
  proc_current = NULL;
  106f84:	c7 05 a0 e1 10 00 00 	movl   $0x0,0x10e1a0
  106f8b:	00 00 00 
  proc_idle();
  106f8e:	e8 8d 01 00 00       	call   107120 <proc_idle>
}
  106f93:	c9                   	leave  
  106f94:	c3                   	ret    

00106f95 <proc_abort>:

/**
 * Aborts process (Syscall)
 */
void proc_abort() {
  106f95:	55                   	push   %ebp
  106f96:	89 e5                	mov    %esp,%ebp
  106f98:	83 ec 08             	sub    $0x8,%esp
  proc_exit(1);
  106f9b:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
  106fa2:	e8 91 fe ff ff       	call   106e38 <proc_exit>
}
  106fa7:	c9                   	leave  
  106fa8:	c3                   	ret    

00106fa9 <proc_stop>:

/**
 * Stops process (Syscall)
 */
void proc_stop() {
  106fa9:	55                   	push   %ebp
  106faa:	89 e5                	mov    %esp,%ebp
  106fac:	83 ec 08             	sub    $0x8,%esp
  proc_sleep(proc_current);
  106faf:	a1 a0 e1 10 00       	mov    0x10e1a0,%eax
  106fb4:	89 04 24             	mov    %eax,(%esp)
  106fb7:	e8 65 f6 ff ff       	call   106621 <proc_sleep>
}
  106fbc:	c9                   	leave  
  106fbd:	c3                   	ret    

00106fbe <proc_call>:
 *  @param proc Process
 *  @param func Function
 *  @param numparams Number of parameters
 *  @param ... Parameters
 */
void proc_call(proc_t *proc,void *func,size_t numparams,...) {
  106fbe:	55                   	push   %ebp
  106fbf:	89 e5                	mov    %esp,%ebp
  106fc1:	83 ec 28             	sub    $0x28,%esp
  if (!proc->defunc) {
  106fc4:	8b 45 08             	mov    0x8(%ebp),%eax
  106fc7:	8b 80 84 00 00 00    	mov    0x84(%eax),%eax
  106fcd:	85 c0                	test   %eax,%eax
  106fcf:	0f 85 e0 00 00 00    	jne    1070b5 <proc_call+0xf7>
    va_list args;
    size_t i;
    int *params = malloc(numparams*sizeof(int));
  106fd5:	8b 45 10             	mov    0x10(%ebp),%eax
  106fd8:	c1 e0 02             	shl    $0x2,%eax
  106fdb:	89 04 24             	mov    %eax,(%esp)
  106fde:	e8 86 bf ff ff       	call   102f69 <malloc>
  106fe3:	89 45 f8             	mov    %eax,-0x8(%ebp)
    uint32_t *eip = proc_current==proc?interrupt_curregs.eip:&proc->registers.eip;
  106fe6:	a1 a0 e1 10 00       	mov    0x10e1a0,%eax
  106feb:	3b 45 08             	cmp    0x8(%ebp),%eax
  106fee:	75 0a                	jne    106ffa <proc_call+0x3c>
  106ff0:	a1 40 e7 10 00       	mov    0x10e740,%eax
  106ff5:	89 45 ec             	mov    %eax,-0x14(%ebp)
  106ff8:	eb 09                	jmp    107003 <proc_call+0x45>
  106ffa:	8b 45 08             	mov    0x8(%ebp),%eax
  106ffd:	83 c0 4c             	add    $0x4c,%eax
  107000:	89 45 ec             	mov    %eax,-0x14(%ebp)
  107003:	8b 45 ec             	mov    -0x14(%ebp),%eax
  107006:	89 45 fc             	mov    %eax,-0x4(%ebp)

    va_start(args,numparams);
  107009:	8d 45 14             	lea    0x14(%ebp),%eax
  10700c:	89 45 f0             	mov    %eax,-0x10(%ebp)
    for (i=0;i<numparams;i++) params[numparams-(i+1)] = va_arg(args,int);
  10700f:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  107016:	eb 23                	jmp    10703b <proc_call+0x7d>
  107018:	8b 45 f4             	mov    -0xc(%ebp),%eax
  10701b:	f7 d0                	not    %eax
  10701d:	03 45 10             	add    0x10(%ebp),%eax
  107020:	c1 e0 02             	shl    $0x2,%eax
  107023:	89 c1                	mov    %eax,%ecx
  107025:	03 4d f8             	add    -0x8(%ebp),%ecx
  107028:	8b 55 f0             	mov    -0x10(%ebp),%edx
  10702b:	8d 42 04             	lea    0x4(%edx),%eax
  10702e:	89 45 f0             	mov    %eax,-0x10(%ebp)
  107031:	89 d0                	mov    %edx,%eax
  107033:	8b 00                	mov    (%eax),%eax
  107035:	89 01                	mov    %eax,(%ecx)
  107037:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
  10703b:	8b 45 f4             	mov    -0xc(%ebp),%eax
  10703e:	3b 45 10             	cmp    0x10(%ebp),%eax
  107041:	72 d5                	jb     107018 <proc_call+0x5a>
    va_end(args);

    memuser_load_addrspace(proc->addrspace);
  107043:	8b 45 08             	mov    0x8(%ebp),%eax
  107046:	8b 40 6c             	mov    0x6c(%eax),%eax
  107049:	89 04 24             	mov    %eax,(%esp)
  10704c:	e8 ca cb ff ff       	call   103c1b <memuser_load_addrspace>
    for (i=0;i<numparams;i++) proc_push(proc,params[i]);
  107051:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  107058:	eb 1e                	jmp    107078 <proc_call+0xba>
  10705a:	8b 45 f4             	mov    -0xc(%ebp),%eax
  10705d:	c1 e0 02             	shl    $0x2,%eax
  107060:	03 45 f8             	add    -0x8(%ebp),%eax
  107063:	8b 00                	mov    (%eax),%eax
  107065:	89 44 24 04          	mov    %eax,0x4(%esp)
  107069:	8b 45 08             	mov    0x8(%ebp),%eax
  10706c:	89 04 24             	mov    %eax,(%esp)
  10706f:	e8 43 00 00 00       	call   1070b7 <proc_push>
  107074:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
  107078:	8b 45 f4             	mov    -0xc(%ebp),%eax
  10707b:	3b 45 10             	cmp    0x10(%ebp),%eax
  10707e:	72 da                	jb     10705a <proc_call+0x9c>
    proc_push(proc,*eip);
  107080:	8b 45 fc             	mov    -0x4(%ebp),%eax
  107083:	8b 00                	mov    (%eax),%eax
  107085:	89 44 24 04          	mov    %eax,0x4(%esp)
  107089:	8b 45 08             	mov    0x8(%ebp),%eax
  10708c:	89 04 24             	mov    %eax,(%esp)
  10708f:	e8 23 00 00 00       	call   1070b7 <proc_push>
    if (proc_current!=NULL) {
  107094:	a1 a0 e1 10 00       	mov    0x10e1a0,%eax
  107099:	85 c0                	test   %eax,%eax
  10709b:	74 10                	je     1070ad <proc_call+0xef>
      memuser_load_addrspace(proc_current->addrspace);
  10709d:	a1 a0 e1 10 00       	mov    0x10e1a0,%eax
  1070a2:	8b 40 6c             	mov    0x6c(%eax),%eax
  1070a5:	89 04 24             	mov    %eax,(%esp)
  1070a8:	e8 6e cb ff ff       	call   103c1b <memuser_load_addrspace>
    }
    *eip = (uint32_t)func;
  1070ad:	8b 55 0c             	mov    0xc(%ebp),%edx
  1070b0:	8b 45 fc             	mov    -0x4(%ebp),%eax
  1070b3:	89 10                	mov    %edx,(%eax)

    //proc_wake(proc);
  }
}
  1070b5:	c9                   	leave  
  1070b6:	c3                   	ret    

001070b7 <proc_push>:
/**
 * Push an element on user stack
 *  @param proc Process
 *  @param val Value
 */
void proc_push(proc_t *proc,int val) {
  1070b7:	55                   	push   %ebp
  1070b8:	89 e5                	mov    %esp,%ebp
  1070ba:	83 ec 14             	sub    $0x14,%esp
  uint32_t *esp = proc_current==proc?interrupt_curregs.esp:&proc->registers.esp;
  1070bd:	a1 a0 e1 10 00       	mov    0x10e1a0,%eax
  1070c2:	3b 45 08             	cmp    0x8(%ebp),%eax
  1070c5:	75 0a                	jne    1070d1 <proc_push+0x1a>
  1070c7:	a1 3c e7 10 00       	mov    0x10e73c,%eax
  1070cc:	89 45 ec             	mov    %eax,-0x14(%ebp)
  1070cf:	eb 09                	jmp    1070da <proc_push+0x23>
  1070d1:	8b 45 08             	mov    0x8(%ebp),%eax
  1070d4:	83 c0 48             	add    $0x48,%eax
  1070d7:	89 45 ec             	mov    %eax,-0x14(%ebp)
  1070da:	8b 45 ec             	mov    -0x14(%ebp),%eax
  1070dd:	89 45 fc             	mov    %eax,-0x4(%ebp)
  *esp -= sizeof(int);
  1070e0:	8b 45 fc             	mov    -0x4(%ebp),%eax
  1070e3:	8b 00                	mov    (%eax),%eax
  1070e5:	8d 50 fc             	lea    -0x4(%eax),%edx
  1070e8:	8b 45 fc             	mov    -0x4(%ebp),%eax
  1070eb:	89 10                	mov    %edx,(%eax)
  //memuser_load_addrspace(proc->addrspace);
  *((int*)(*esp)) = val;
  1070ed:	8b 45 fc             	mov    -0x4(%ebp),%eax
  1070f0:	8b 00                	mov    (%eax),%eax
  1070f2:	89 c2                	mov    %eax,%edx
  1070f4:	8b 45 0c             	mov    0xc(%ebp),%eax
  1070f7:	89 02                	mov    %eax,(%edx)
  //memuser_load_addrspace(proc_current->addrspace);
}
  1070f9:	c9                   	leave  
  1070fa:	c3                   	ret    

001070fb <proc_pop>:
/**
 * Pops an element from user stack
 *  @param proc Process
 *  @return Value
 */
int proc_pop(proc_t *proc) {
  1070fb:	55                   	push   %ebp
  1070fc:	89 e5                	mov    %esp,%ebp
  1070fe:	83 ec 10             	sub    $0x10,%esp
  int val = *((int*)proc->registers.esp);
  107101:	8b 45 08             	mov    0x8(%ebp),%eax
  107104:	8b 40 48             	mov    0x48(%eax),%eax
  107107:	8b 00                	mov    (%eax),%eax
  107109:	89 45 fc             	mov    %eax,-0x4(%ebp)
  proc->registers.esp += sizeof(int);
  10710c:	8b 45 08             	mov    0x8(%ebp),%eax
  10710f:	8b 40 48             	mov    0x48(%eax),%eax
  107112:	8d 50 04             	lea    0x4(%eax),%edx
  107115:	8b 45 08             	mov    0x8(%ebp),%eax
  107118:	89 50 48             	mov    %edx,0x48(%eax)
  return val;
  10711b:	8b 45 fc             	mov    -0x4(%ebp),%eax
}
  10711e:	c9                   	leave  
  10711f:	c3                   	ret    

00107120 <proc_idle>:

/**
 * Idles until next schedule
 */
void proc_idle() {
  107120:	55                   	push   %ebp
  107121:	89 e5                	mov    %esp,%ebp
  107123:	83 ec 08             	sub    $0x8,%esp
  asm("mov %0,%%esp"::"r"(cpu_this->tss->esp0)); // reload ESP0 in TSS "by hand"
  107126:	a1 54 e4 10 00       	mov    0x10e454,%eax
  10712b:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  107132:	00 
  107133:	89 04 24             	mov    %eax,(%esp)
  107136:	e8 4c 39 00 00       	call   10aa87 <llist_get>
  10713b:	8b 40 50             	mov    0x50(%eax),%eax
  10713e:	8b 40 04             	mov    0x4(%eax),%eax
  107141:	89 c4                	mov    %eax,%esp
  interrupt_enable(1);
  107143:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
  10714a:	e8 7c 9e ff ff       	call   100fcb <interrupt_enable>
  cpu_halt();
  10714f:	e8 02 00 00 00       	call   107156 <cpu_halt>
}
  107154:	c9                   	leave  
  107155:	c3                   	ret    

00107156 <cpu_halt>:
  clock_t ticks;
} cpu_t;

llist_t cpus;

static inline void cpu_halt() {
  107156:	55                   	push   %ebp
  107157:	89 e5                	mov    %esp,%ebp
  asm("hlt");
  107159:	f4                   	hlt    
}
  10715a:	5d                   	pop    %ebp
  10715b:	c3                   	ret    

0010715c <proc_create_syscall>:
 *  @param uid UID
 *  @param gid GID
 *  @param parent_pid Parent's PID
 *  @return PID of created process
 */
pid_t proc_create_syscall(char *name,uid_t uid,gid_t gid,pid_t parent_pid) {
  10715c:	55                   	push   %ebp
  10715d:	89 e5                	mov    %esp,%ebp
  10715f:	83 ec 38             	sub    $0x38,%esp
  if (proc_current->system) {
  107162:	a1 a0 e1 10 00       	mov    0x10e1a0,%eax
  107167:	8b 40 1c             	mov    0x1c(%eax),%eax
  10716a:	85 c0                	test   %eax,%eax
  10716c:	74 66                	je     1071d4 <proc_create_syscall+0x78>
    proc_t *parent = proc_find(parent_pid);
  10716e:	8b 45 14             	mov    0x14(%ebp),%eax
  107171:	89 04 24             	mov    %eax,(%esp)
  107174:	e8 f6 f3 ff ff       	call   10656f <proc_find>
  107179:	89 45 f8             	mov    %eax,-0x8(%ebp)
    if (parent!=NULL) {
  10717c:	83 7d f8 00          	cmpl   $0x0,-0x8(%ebp)
  107180:	74 52                	je     1071d4 <proc_create_syscall+0x78>
      proc_t *proc = proc_create(name,uid,gid,parent,0,0);
  107182:	c7 44 24 14 00 00 00 	movl   $0x0,0x14(%esp)
  107189:	00 
  10718a:	c7 44 24 10 00 00 00 	movl   $0x0,0x10(%esp)
  107191:	00 
  107192:	8b 45 f8             	mov    -0x8(%ebp),%eax
  107195:	89 44 24 0c          	mov    %eax,0xc(%esp)
  107199:	8b 45 10             	mov    0x10(%ebp),%eax
  10719c:	89 44 24 08          	mov    %eax,0x8(%esp)
  1071a0:	8b 45 0c             	mov    0xc(%ebp),%eax
  1071a3:	89 44 24 04          	mov    %eax,0x4(%esp)
  1071a7:	8b 45 08             	mov    0x8(%ebp),%eax
  1071aa:	89 04 24             	mov    %eax,(%esp)
  1071ad:	e8 c0 f0 ff ff       	call   106272 <proc_create>
  1071b2:	89 45 fc             	mov    %eax,-0x4(%ebp)
      return proc!=NULL?proc->pid:-1;
  1071b5:	83 7d fc 00          	cmpl   $0x0,-0x4(%ebp)
  1071b9:	74 0a                	je     1071c5 <proc_create_syscall+0x69>
  1071bb:	8b 45 fc             	mov    -0x4(%ebp),%eax
  1071be:	8b 00                	mov    (%eax),%eax
  1071c0:	89 45 ec             	mov    %eax,-0x14(%ebp)
  1071c3:	eb 07                	jmp    1071cc <proc_create_syscall+0x70>
  1071c5:	c7 45 ec ff ff ff ff 	movl   $0xffffffff,-0x14(%ebp)
  1071cc:	8b 45 ec             	mov    -0x14(%ebp),%eax
  1071cf:	89 45 e8             	mov    %eax,-0x18(%ebp)
  1071d2:	eb 07                	jmp    1071db <proc_create_syscall+0x7f>
    }
  }
  return -1;
  1071d4:	c7 45 e8 ff ff ff ff 	movl   $0xffffffff,-0x18(%ebp)
  1071db:	8b 45 e8             	mov    -0x18(%ebp),%eax
}
  1071de:	c9                   	leave  
  1071df:	c3                   	ret    

001071e0 <proc_destroy_syscall>:

/**
 * Destroys a process (Syscall)
 *  @param proc_pid PID of process to destroy
 */
int proc_destroy_syscall(pid_t proc_pid) {
  1071e0:	55                   	push   %ebp
  1071e1:	89 e5                	mov    %esp,%ebp
  1071e3:	83 ec 18             	sub    $0x18,%esp
  if (proc_current->system) {
  1071e6:	a1 a0 e1 10 00       	mov    0x10e1a0,%eax
  1071eb:	8b 40 1c             	mov    0x1c(%eax),%eax
  1071ee:	85 c0                	test   %eax,%eax
  1071f0:	74 2e                	je     107220 <proc_destroy_syscall+0x40>
    proc_t *proc = proc_find(proc_pid);
  1071f2:	8b 45 08             	mov    0x8(%ebp),%eax
  1071f5:	89 04 24             	mov    %eax,(%esp)
  1071f8:	e8 72 f3 ff ff       	call   10656f <proc_find>
  1071fd:	89 45 fc             	mov    %eax,-0x4(%ebp)
    if (proc!=NULL && proc!=proc_current) {
  107200:	83 7d fc 00          	cmpl   $0x0,-0x4(%ebp)
  107204:	74 1a                	je     107220 <proc_destroy_syscall+0x40>
  107206:	a1 a0 e1 10 00       	mov    0x10e1a0,%eax
  10720b:	39 45 fc             	cmp    %eax,-0x4(%ebp)
  10720e:	74 10                	je     107220 <proc_destroy_syscall+0x40>
      return proc_destroy(proc);
  107210:	8b 45 fc             	mov    -0x4(%ebp),%eax
  107213:	89 04 24             	mov    %eax,(%esp)
  107216:	e8 22 f2 ff ff       	call   10643d <proc_destroy>
  10721b:	89 45 ec             	mov    %eax,-0x14(%ebp)
  10721e:	eb 07                	jmp    107227 <proc_destroy_syscall+0x47>
    }
  }
  return -1;
  107220:	c7 45 ec ff ff ff ff 	movl   $0xffffffff,-0x14(%ebp)
  107227:	8b 45 ec             	mov    -0x14(%ebp),%eax
}
  10722a:	c9                   	leave  
  10722b:	c3                   	ret    

0010722c <proc_memmap>:
 *  @param writable Whether to map it writable
 *  @param cow Map page as COW
 *  @return Success?
 *  @todo remove memuser_load_addrspace()
 */
int proc_memmap(pid_t proc_pid,void *virt,void *phys,int writable,int swappable,int cow) {
  10722c:	55                   	push   %ebp
  10722d:	89 e5                	mov    %esp,%ebp
  10722f:	83 ec 48             	sub    $0x48,%esp
  if (proc_current->system) {
  107232:	a1 a0 e1 10 00       	mov    0x10e1a0,%eax
  107237:	8b 40 1c             	mov    0x1c(%eax),%eax
  10723a:	85 c0                	test   %eax,%eax
  10723c:	0f 84 02 01 00 00    	je     107344 <proc_memmap+0x118>
    proc_t *proc = proc_find(proc_pid);
  107242:	8b 45 08             	mov    0x8(%ebp),%eax
  107245:	89 04 24             	mov    %eax,(%esp)
  107248:	e8 22 f3 ff ff       	call   10656f <proc_find>
  10724d:	89 45 fc             	mov    %eax,-0x4(%ebp)
    if (proc!=NULL) {
  107250:	83 7d fc 00          	cmpl   $0x0,-0x4(%ebp)
  107254:	0f 84 ea 00 00 00    	je     107344 <proc_memmap+0x118>
      pte_t pte = paging_getpte_pd(virt,proc->addrspace->pagedir);
  10725a:	8b 45 fc             	mov    -0x4(%ebp),%eax
  10725d:	8b 40 6c             	mov    0x6c(%eax),%eax
  107260:	8b 40 10             	mov    0x10(%eax),%eax
  107263:	8d 55 f8             	lea    -0x8(%ebp),%edx
  107266:	89 44 24 08          	mov    %eax,0x8(%esp)
  10726a:	8b 45 0c             	mov    0xc(%ebp),%eax
  10726d:	89 44 24 04          	mov    %eax,0x4(%esp)
  107271:	89 14 24             	mov    %edx,(%esp)
  107274:	e8 71 e4 ff ff       	call   1056ea <paging_getpte_pd>
  107279:	83 ec 04             	sub    $0x4,%esp
      if (!pte.exists) {
  10727c:	0f b6 45 f9          	movzbl -0x7(%ebp),%eax
  107280:	83 e0 02             	and    $0x2,%eax
  107283:	84 c0                	test   %al,%al
  107285:	0f 85 b9 00 00 00    	jne    107344 <proc_memmap+0x118>
        memuser_load_addrspace(proc->addrspace);
  10728b:	8b 45 fc             	mov    -0x4(%ebp),%eax
  10728e:	8b 40 6c             	mov    0x6c(%eax),%eax
  107291:	89 04 24             	mov    %eax,(%esp)
  107294:	e8 82 c9 ff ff       	call   103c1b <memuser_load_addrspace>
        paging_map_pd(virt,phys,1,writable && !cow,swappable,cow && writable,proc->addrspace->pagedir);
  107299:	8b 45 fc             	mov    -0x4(%ebp),%eax
  10729c:	8b 40 6c             	mov    0x6c(%eax),%eax
  10729f:	8b 40 10             	mov    0x10(%eax),%eax
  1072a2:	89 45 e0             	mov    %eax,-0x20(%ebp)
  1072a5:	83 7d 1c 00          	cmpl   $0x0,0x1c(%ebp)
  1072a9:	74 0f                	je     1072ba <proc_memmap+0x8e>
  1072ab:	83 7d 14 00          	cmpl   $0x0,0x14(%ebp)
  1072af:	74 09                	je     1072ba <proc_memmap+0x8e>
  1072b1:	c7 45 e4 01 00 00 00 	movl   $0x1,-0x1c(%ebp)
  1072b8:	eb 07                	jmp    1072c1 <proc_memmap+0x95>
  1072ba:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
  1072c1:	83 7d 14 00          	cmpl   $0x0,0x14(%ebp)
  1072c5:	74 0f                	je     1072d6 <proc_memmap+0xaa>
  1072c7:	83 7d 1c 00          	cmpl   $0x0,0x1c(%ebp)
  1072cb:	75 09                	jne    1072d6 <proc_memmap+0xaa>
  1072cd:	c7 45 e8 01 00 00 00 	movl   $0x1,-0x18(%ebp)
  1072d4:	eb 07                	jmp    1072dd <proc_memmap+0xb1>
  1072d6:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
  1072dd:	8b 45 e0             	mov    -0x20(%ebp),%eax
  1072e0:	89 44 24 18          	mov    %eax,0x18(%esp)
  1072e4:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  1072e7:	89 44 24 14          	mov    %eax,0x14(%esp)
  1072eb:	8b 45 18             	mov    0x18(%ebp),%eax
  1072ee:	89 44 24 10          	mov    %eax,0x10(%esp)
  1072f2:	8b 45 e8             	mov    -0x18(%ebp),%eax
  1072f5:	89 44 24 0c          	mov    %eax,0xc(%esp)
  1072f9:	c7 44 24 08 01 00 00 	movl   $0x1,0x8(%esp)
  107300:	00 
  107301:	8b 45 10             	mov    0x10(%ebp),%eax
  107304:	89 44 24 04          	mov    %eax,0x4(%esp)
  107308:	8b 45 0c             	mov    0xc(%ebp),%eax
  10730b:	89 04 24             	mov    %eax,(%esp)
  10730e:	e8 2a e5 ff ff       	call   10583d <paging_map_pd>
        memuser_load_addrspace(proc_current->addrspace);
  107313:	a1 a0 e1 10 00       	mov    0x10e1a0,%eax
  107318:	8b 40 6c             	mov    0x6c(%eax),%eax
  10731b:	89 04 24             	mov    %eax,(%esp)
  10731e:	e8 f8 c8 ff ff       	call   103c1b <memuser_load_addrspace>
        llist_push(proc->addrspace->pages_loaded,virt);
  107323:	8b 45 fc             	mov    -0x4(%ebp),%eax
  107326:	8b 40 6c             	mov    0x6c(%eax),%eax
  107329:	8b 50 04             	mov    0x4(%eax),%edx
  10732c:	8b 45 0c             	mov    0xc(%ebp),%eax
  10732f:	89 44 24 04          	mov    %eax,0x4(%esp)
  107333:	89 14 24             	mov    %edx,(%esp)
  107336:	e8 14 36 00 00       	call   10a94f <llist_push>
        return 0;
  10733b:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
  107342:	eb 07                	jmp    10734b <proc_memmap+0x11f>
      }
    }
  }
  return -1;
  107344:	c7 45 ec ff ff ff ff 	movl   $0xffffffff,-0x14(%ebp)
  10734b:	8b 45 ec             	mov    -0x14(%ebp),%eax
}
  10734e:	c9                   	leave  
  10734f:	c3                   	ret    

00107350 <proc_memalloc>:
 *  @param virt Virtual address
 *  @param writable Whether to alloc wirtable memory
 *  @param swappable Whether memory should be swappable
 *  @return Success?
 */
int proc_memalloc(pid_t proc_pid,void *virt,int writable,int swappable) {
  107350:	55                   	push   %ebp
  107351:	89 e5                	mov    %esp,%ebp
  107353:	83 ec 38             	sub    $0x38,%esp
  void *page = memphys_alloc();
  107356:	e8 5a c1 ff ff       	call   1034b5 <memphys_pop>
  10735b:	89 45 fc             	mov    %eax,-0x4(%ebp)
  if (proc_memmap(proc_pid,virt,page,writable,swappable,0)==0) return 0;
  10735e:	c7 44 24 14 00 00 00 	movl   $0x0,0x14(%esp)
  107365:	00 
  107366:	8b 45 14             	mov    0x14(%ebp),%eax
  107369:	89 44 24 10          	mov    %eax,0x10(%esp)
  10736d:	8b 45 10             	mov    0x10(%ebp),%eax
  107370:	89 44 24 0c          	mov    %eax,0xc(%esp)
  107374:	8b 45 fc             	mov    -0x4(%ebp),%eax
  107377:	89 44 24 08          	mov    %eax,0x8(%esp)
  10737b:	8b 45 0c             	mov    0xc(%ebp),%eax
  10737e:	89 44 24 04          	mov    %eax,0x4(%esp)
  107382:	8b 45 08             	mov    0x8(%ebp),%eax
  107385:	89 04 24             	mov    %eax,(%esp)
  107388:	e8 9f fe ff ff       	call   10722c <proc_memmap>
  10738d:	85 c0                	test   %eax,%eax
  10738f:	75 09                	jne    10739a <proc_memalloc+0x4a>
  107391:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
  107398:	eb 12                	jmp    1073ac <proc_memalloc+0x5c>
  else {
    memphys_free(page);
  10739a:	8b 45 fc             	mov    -0x4(%ebp),%eax
  10739d:	89 04 24             	mov    %eax,(%esp)
  1073a0:	e8 6f c0 ff ff       	call   103414 <memphys_push>
    return -1;
  1073a5:	c7 45 ec ff ff ff ff 	movl   $0xffffffff,-0x14(%ebp)
  1073ac:	8b 45 ec             	mov    -0x14(%ebp),%eax
  }
}
  1073af:	c9                   	leave  
  1073b0:	c3                   	ret    

001073b1 <proc_memunmap>:
 * Unmaps a page from a process' address space
 *  @param proc_pid Process' PID
 *  @param virt Virtual address to unmap
 *  @return Success?
 */
int proc_memunmap(pid_t proc_pid,void *virt) {
  1073b1:	55                   	push   %ebp
  1073b2:	89 e5                	mov    %esp,%ebp
  1073b4:	83 ec 28             	sub    $0x28,%esp
  if (proc_current->system) {
  1073b7:	a1 a0 e1 10 00       	mov    0x10e1a0,%eax
  1073bc:	8b 40 1c             	mov    0x1c(%eax),%eax
  1073bf:	85 c0                	test   %eax,%eax
  1073c1:	74 75                	je     107438 <proc_memunmap+0x87>
    proc_t *proc = proc_find(proc_pid);
  1073c3:	8b 45 08             	mov    0x8(%ebp),%eax
  1073c6:	89 04 24             	mov    %eax,(%esp)
  1073c9:	e8 a1 f1 ff ff       	call   10656f <proc_find>
  1073ce:	89 45 fc             	mov    %eax,-0x4(%ebp)
    if (proc!=NULL) {
  1073d1:	83 7d fc 00          	cmpl   $0x0,-0x4(%ebp)
  1073d5:	74 61                	je     107438 <proc_memunmap+0x87>
      memuser_load_addrspace(proc->addrspace);
  1073d7:	8b 45 fc             	mov    -0x4(%ebp),%eax
  1073da:	8b 40 6c             	mov    0x6c(%eax),%eax
  1073dd:	89 04 24             	mov    %eax,(%esp)
  1073e0:	e8 36 c8 ff ff       	call   103c1b <memuser_load_addrspace>
      paging_unmap(virt);
  1073e5:	8b 45 0c             	mov    0xc(%ebp),%eax
  1073e8:	89 04 24             	mov    %eax,(%esp)
  1073eb:	e8 67 e6 ff ff       	call   105a57 <paging_unmap>
      memuser_load_addrspace(proc_current->addrspace);
  1073f0:	a1 a0 e1 10 00       	mov    0x10e1a0,%eax
  1073f5:	8b 40 6c             	mov    0x6c(%eax),%eax
  1073f8:	89 04 24             	mov    %eax,(%esp)
  1073fb:	e8 1b c8 ff ff       	call   103c1b <memuser_load_addrspace>
      llist_remove(proc->addrspace->pages_imaginary,llist_find(proc->addrspace->pages_imaginary,virt));
  107400:	8b 45 fc             	mov    -0x4(%ebp),%eax
  107403:	8b 40 6c             	mov    0x6c(%eax),%eax
  107406:	8b 50 08             	mov    0x8(%eax),%edx
  107409:	8b 45 0c             	mov    0xc(%ebp),%eax
  10740c:	89 44 24 04          	mov    %eax,0x4(%esp)
  107410:	89 14 24             	mov    %edx,(%esp)
  107413:	e8 09 38 00 00       	call   10ac21 <llist_find>
  107418:	89 c2                	mov    %eax,%edx
  10741a:	8b 45 fc             	mov    -0x4(%ebp),%eax
  10741d:	8b 40 6c             	mov    0x6c(%eax),%eax
  107420:	8b 40 08             	mov    0x8(%eax),%eax
  107423:	89 54 24 04          	mov    %edx,0x4(%esp)
  107427:	89 04 24             	mov    %eax,(%esp)
  10742a:	e8 2a 37 00 00       	call   10ab59 <llist_remove>
      return 0;
  10742f:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
  107436:	eb 07                	jmp    10743f <proc_memunmap+0x8e>
    }
  }
  return -1;
  107438:	c7 45 ec ff ff ff ff 	movl   $0xffffffff,-0x14(%ebp)
  10743f:	8b 45 ec             	mov    -0x14(%ebp),%eax
}
  107442:	c9                   	leave  
  107443:	c3                   	ret    

00107444 <proc_memfree>:
 * Frees a page from a process' address space
 *  @param proc_pid Process' PID
 *  @param virt Virtual address to unmap
 *  @return Success?
 */
int proc_memfree(pid_t proc_pid,void *virt) {
  107444:	55                   	push   %ebp
  107445:	89 e5                	mov    %esp,%ebp
  107447:	83 ec 28             	sub    $0x28,%esp
  if (proc_current->system) {
  10744a:	a1 a0 e1 10 00       	mov    0x10e1a0,%eax
  10744f:	8b 40 1c             	mov    0x1c(%eax),%eax
  107452:	85 c0                	test   %eax,%eax
  107454:	74 7d                	je     1074d3 <proc_memfree+0x8f>
    proc_t *proc = proc_find(proc_pid);
  107456:	8b 45 08             	mov    0x8(%ebp),%eax
  107459:	89 04 24             	mov    %eax,(%esp)
  10745c:	e8 0e f1 ff ff       	call   10656f <proc_find>
  107461:	89 45 fc             	mov    %eax,-0x4(%ebp)
    if (proc!=NULL) {
  107464:	83 7d fc 00          	cmpl   $0x0,-0x4(%ebp)
  107468:	74 69                	je     1074d3 <proc_memfree+0x8f>
      memuser_load_addrspace(proc->addrspace);
  10746a:	8b 45 fc             	mov    -0x4(%ebp),%eax
  10746d:	8b 40 6c             	mov    0x6c(%eax),%eax
  107470:	89 04 24             	mov    %eax,(%esp)
  107473:	e8 a3 c7 ff ff       	call   103c1b <memuser_load_addrspace>
      memphys_free(paging_unmap(virt));
  107478:	8b 45 0c             	mov    0xc(%ebp),%eax
  10747b:	89 04 24             	mov    %eax,(%esp)
  10747e:	e8 d4 e5 ff ff       	call   105a57 <paging_unmap>
  107483:	89 04 24             	mov    %eax,(%esp)
  107486:	e8 89 bf ff ff       	call   103414 <memphys_push>
      memuser_load_addrspace(proc_current->addrspace);
  10748b:	a1 a0 e1 10 00       	mov    0x10e1a0,%eax
  107490:	8b 40 6c             	mov    0x6c(%eax),%eax
  107493:	89 04 24             	mov    %eax,(%esp)
  107496:	e8 80 c7 ff ff       	call   103c1b <memuser_load_addrspace>
      llist_remove(proc->addrspace->pages_imaginary,llist_find(proc->addrspace->pages_imaginary,virt));
  10749b:	8b 45 fc             	mov    -0x4(%ebp),%eax
  10749e:	8b 40 6c             	mov    0x6c(%eax),%eax
  1074a1:	8b 50 08             	mov    0x8(%eax),%edx
  1074a4:	8b 45 0c             	mov    0xc(%ebp),%eax
  1074a7:	89 44 24 04          	mov    %eax,0x4(%esp)
  1074ab:	89 14 24             	mov    %edx,(%esp)
  1074ae:	e8 6e 37 00 00       	call   10ac21 <llist_find>
  1074b3:	89 c2                	mov    %eax,%edx
  1074b5:	8b 45 fc             	mov    -0x4(%ebp),%eax
  1074b8:	8b 40 6c             	mov    0x6c(%eax),%eax
  1074bb:	8b 40 08             	mov    0x8(%eax),%eax
  1074be:	89 54 24 04          	mov    %edx,0x4(%esp)
  1074c2:	89 04 24             	mov    %eax,(%esp)
  1074c5:	e8 8f 36 00 00       	call   10ab59 <llist_remove>
      return 0;
  1074ca:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
  1074d1:	eb 07                	jmp    1074da <proc_memfree+0x96>
    }
  }
  return -1;
  1074d3:	c7 45 ec ff ff ff ff 	movl   $0xffffffff,-0x14(%ebp)
  1074da:	8b 45 ec             	mov    -0x14(%ebp),%eax
}
  1074dd:	c9                   	leave  
  1074de:	c3                   	ret    

001074df <proc_memget>:
 * Gets information about page of process
 *  @param proc_pid Process' PID
 *  @param virt Virtual address to get information about
 *  @return Success?
 */
void *proc_memget(pid_t proc_pid,void *virt,int *exists,int *writable,int *swappable,int *cow) {
  1074df:	55                   	push   %ebp
  1074e0:	89 e5                	mov    %esp,%ebp
  1074e2:	83 ec 28             	sub    $0x28,%esp
  if (proc_current->system) {
  1074e5:	a1 a0 e1 10 00       	mov    0x10e1a0,%eax
  1074ea:	8b 40 1c             	mov    0x1c(%eax),%eax
  1074ed:	85 c0                	test   %eax,%eax
  1074ef:	0f 84 bd 00 00 00    	je     1075b2 <proc_memget+0xd3>
    proc_t *proc = proc_find(proc_pid);
  1074f5:	8b 45 08             	mov    0x8(%ebp),%eax
  1074f8:	89 04 24             	mov    %eax,(%esp)
  1074fb:	e8 6f f0 ff ff       	call   10656f <proc_find>
  107500:	89 45 fc             	mov    %eax,-0x4(%ebp)
    if (proc!=NULL) {
  107503:	83 7d fc 00          	cmpl   $0x0,-0x4(%ebp)
  107507:	0f 84 a5 00 00 00    	je     1075b2 <proc_memget+0xd3>
      pte_t pte = paging_getpte_pd(virt,proc->addrspace->pagedir);
  10750d:	8b 45 fc             	mov    -0x4(%ebp),%eax
  107510:	8b 40 6c             	mov    0x6c(%eax),%eax
  107513:	8b 40 10             	mov    0x10(%eax),%eax
  107516:	8d 55 f8             	lea    -0x8(%ebp),%edx
  107519:	89 44 24 08          	mov    %eax,0x8(%esp)
  10751d:	8b 45 0c             	mov    0xc(%ebp),%eax
  107520:	89 44 24 04          	mov    %eax,0x4(%esp)
  107524:	89 14 24             	mov    %edx,(%esp)
  107527:	e8 be e1 ff ff       	call   1056ea <paging_getpte_pd>
  10752c:	83 ec 04             	sub    $0x4,%esp
      if (exists!=NULL) *exists = pte.exists;
  10752f:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
  107533:	74 11                	je     107546 <proc_memget+0x67>
  107535:	0f b6 45 f9          	movzbl -0x7(%ebp),%eax
  107539:	d0 e8                	shr    %al
  10753b:	83 e0 01             	and    $0x1,%eax
  10753e:	0f b6 d0             	movzbl %al,%edx
  107541:	8b 45 10             	mov    0x10(%ebp),%eax
  107544:	89 10                	mov    %edx,(%eax)
      if (writable!=NULL) *writable = pte.writable;
  107546:	83 7d 14 00          	cmpl   $0x0,0x14(%ebp)
  10754a:	74 11                	je     10755d <proc_memget+0x7e>
  10754c:	0f b6 45 f8          	movzbl -0x8(%ebp),%eax
  107550:	d0 e8                	shr    %al
  107552:	83 e0 01             	and    $0x1,%eax
  107555:	0f b6 d0             	movzbl %al,%edx
  107558:	8b 45 14             	mov    0x14(%ebp),%eax
  10755b:	89 10                	mov    %edx,(%eax)
      if (swappable!=NULL) *swappable = pte.swappable;
  10755d:	83 7d 18 00          	cmpl   $0x0,0x18(%ebp)
  107561:	74 12                	je     107575 <proc_memget+0x96>
  107563:	0f b6 45 f9          	movzbl -0x7(%ebp),%eax
  107567:	c0 e8 02             	shr    $0x2,%al
  10756a:	83 e0 01             	and    $0x1,%eax
  10756d:	0f b6 d0             	movzbl %al,%edx
  107570:	8b 45 18             	mov    0x18(%ebp),%eax
  107573:	89 10                	mov    %edx,(%eax)
      if (cow!=NULL) *cow = pte.cow;
  107575:	83 7d 1c 00          	cmpl   $0x0,0x1c(%ebp)
  107579:	74 0f                	je     10758a <proc_memget+0xab>
  10757b:	0f b6 45 f8          	movzbl -0x8(%ebp),%eax
  10757f:	c0 e8 07             	shr    $0x7,%al
  107582:	0f b6 d0             	movzbl %al,%edx
  107585:	8b 45 1c             	mov    0x1c(%ebp),%eax
  107588:	89 10                	mov    %edx,(%eax)
      return pte.in_memory?PAGE2ADDR(pte.page):NULL;
  10758a:	0f b6 45 f8          	movzbl -0x8(%ebp),%eax
  10758e:	83 e0 01             	and    $0x1,%eax
  107591:	84 c0                	test   %al,%al
  107593:	74 0e                	je     1075a3 <proc_memget+0xc4>
  107595:	8b 45 f8             	mov    -0x8(%ebp),%eax
  107598:	c1 e8 0c             	shr    $0xc,%eax
  10759b:	c1 e0 0c             	shl    $0xc,%eax
  10759e:	89 45 ec             	mov    %eax,-0x14(%ebp)
  1075a1:	eb 07                	jmp    1075aa <proc_memget+0xcb>
  1075a3:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
  1075aa:	8b 45 ec             	mov    -0x14(%ebp),%eax
  1075ad:	89 45 e8             	mov    %eax,-0x18(%ebp)
  1075b0:	eb 10                	jmp    1075c2 <proc_memget+0xe3>
    }
  }
  *exists = 0;
  1075b2:	8b 45 10             	mov    0x10(%ebp),%eax
  1075b5:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
  return NULL;
  1075bb:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
  1075c2:	8b 45 e8             	mov    -0x18(%ebp),%eax
}
  1075c5:	c9                   	leave  
  1075c6:	c3                   	ret    

001075c7 <proc_mempagelist>:
 * Gets page list (Syscall)
 *  @param proc_pid Process' PID
 *  @param virt Virtual address to get information about
 *  @return Number of pages in list
 */
size_t proc_mempagelist(pid_t proc_pid,void **list,size_t n) {
  1075c7:	55                   	push   %ebp
  1075c8:	89 e5                	mov    %esp,%ebp
  1075ca:	53                   	push   %ebx
  1075cb:	83 ec 24             	sub    $0x24,%esp
  if (proc_current->system) {
  1075ce:	a1 a0 e1 10 00       	mov    0x10e1a0,%eax
  1075d3:	8b 40 1c             	mov    0x1c(%eax),%eax
  1075d6:	85 c0                	test   %eax,%eax
  1075d8:	0f 84 52 01 00 00    	je     107730 <proc_mempagelist+0x169>
    proc_t *proc = proc_find(proc_pid);
  1075de:	8b 45 08             	mov    0x8(%ebp),%eax
  1075e1:	89 04 24             	mov    %eax,(%esp)
  1075e4:	e8 86 ef ff ff       	call   10656f <proc_find>
  1075e9:	89 45 ec             	mov    %eax,-0x14(%ebp)
    if (proc!=NULL) {
  1075ec:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
  1075f0:	0f 84 3a 01 00 00    	je     107730 <proc_mempagelist+0x169>
      if (list==NULL || n==0) return llist_size(proc->addrspace->pages_loaded)+llist_size(proc->addrspace->pages_imaginary)+llist_size(proc->addrspace->pages_swapped);
  1075f6:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
  1075fa:	74 06                	je     107602 <proc_mempagelist+0x3b>
  1075fc:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
  107600:	75 41                	jne    107643 <proc_mempagelist+0x7c>
  107602:	8b 45 ec             	mov    -0x14(%ebp),%eax
  107605:	8b 40 6c             	mov    0x6c(%eax),%eax
  107608:	8b 40 04             	mov    0x4(%eax),%eax
  10760b:	89 04 24             	mov    %eax,(%esp)
  10760e:	e8 10 33 00 00       	call   10a923 <llist_size>
  107613:	89 c3                	mov    %eax,%ebx
  107615:	8b 45 ec             	mov    -0x14(%ebp),%eax
  107618:	8b 40 6c             	mov    0x6c(%eax),%eax
  10761b:	8b 40 08             	mov    0x8(%eax),%eax
  10761e:	89 04 24             	mov    %eax,(%esp)
  107621:	e8 fd 32 00 00       	call   10a923 <llist_size>
  107626:	01 c3                	add    %eax,%ebx
  107628:	8b 45 ec             	mov    -0x14(%ebp),%eax
  10762b:	8b 40 6c             	mov    0x6c(%eax),%eax
  10762e:	8b 40 0c             	mov    0xc(%eax),%eax
  107631:	89 04 24             	mov    %eax,(%esp)
  107634:	e8 ea 32 00 00       	call   10a923 <llist_size>
  107639:	01 c3                	add    %eax,%ebx
  10763b:	89 5d e8             	mov    %ebx,-0x18(%ebp)
  10763e:	e9 f4 00 00 00       	jmp    107737 <proc_mempagelist+0x170>
      else {
        size_t i;
        size_t j = 0;
  107643:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
        void *addr;
        for (i=0;(addr = llist_get(proc->addrspace->pages_loaded,i)) && j<n;i++) list[j++] = addr;
  10764a:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
  107651:	eb 18                	jmp    10766b <proc_mempagelist+0xa4>
  107653:	8b 45 f4             	mov    -0xc(%ebp),%eax
  107656:	c1 e0 02             	shl    $0x2,%eax
  107659:	89 c2                	mov    %eax,%edx
  10765b:	03 55 0c             	add    0xc(%ebp),%edx
  10765e:	8b 45 f8             	mov    -0x8(%ebp),%eax
  107661:	89 02                	mov    %eax,(%edx)
  107663:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
  107667:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
  10766b:	8b 45 ec             	mov    -0x14(%ebp),%eax
  10766e:	8b 40 6c             	mov    0x6c(%eax),%eax
  107671:	8b 50 04             	mov    0x4(%eax),%edx
  107674:	8b 45 f0             	mov    -0x10(%ebp),%eax
  107677:	89 44 24 04          	mov    %eax,0x4(%esp)
  10767b:	89 14 24             	mov    %edx,(%esp)
  10767e:	e8 04 34 00 00       	call   10aa87 <llist_get>
  107683:	89 45 f8             	mov    %eax,-0x8(%ebp)
  107686:	83 7d f8 00          	cmpl   $0x0,-0x8(%ebp)
  10768a:	74 08                	je     107694 <proc_mempagelist+0xcd>
  10768c:	8b 45 f4             	mov    -0xc(%ebp),%eax
  10768f:	3b 45 10             	cmp    0x10(%ebp),%eax
  107692:	72 bf                	jb     107653 <proc_mempagelist+0x8c>
        for (i=0;(addr = llist_get(proc->addrspace->pages_imaginary,i)) && j<n;i++) list[j++] = addr;
  107694:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
  10769b:	eb 18                	jmp    1076b5 <proc_mempagelist+0xee>
  10769d:	8b 45 f4             	mov    -0xc(%ebp),%eax
  1076a0:	c1 e0 02             	shl    $0x2,%eax
  1076a3:	89 c2                	mov    %eax,%edx
  1076a5:	03 55 0c             	add    0xc(%ebp),%edx
  1076a8:	8b 45 f8             	mov    -0x8(%ebp),%eax
  1076ab:	89 02                	mov    %eax,(%edx)
  1076ad:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
  1076b1:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
  1076b5:	8b 45 ec             	mov    -0x14(%ebp),%eax
  1076b8:	8b 40 6c             	mov    0x6c(%eax),%eax
  1076bb:	8b 50 08             	mov    0x8(%eax),%edx
  1076be:	8b 45 f0             	mov    -0x10(%ebp),%eax
  1076c1:	89 44 24 04          	mov    %eax,0x4(%esp)
  1076c5:	89 14 24             	mov    %edx,(%esp)
  1076c8:	e8 ba 33 00 00       	call   10aa87 <llist_get>
  1076cd:	89 45 f8             	mov    %eax,-0x8(%ebp)
  1076d0:	83 7d f8 00          	cmpl   $0x0,-0x8(%ebp)
  1076d4:	74 08                	je     1076de <proc_mempagelist+0x117>
  1076d6:	8b 45 f4             	mov    -0xc(%ebp),%eax
  1076d9:	3b 45 10             	cmp    0x10(%ebp),%eax
  1076dc:	72 bf                	jb     10769d <proc_mempagelist+0xd6>
        for (i=0;(addr = llist_get(proc->addrspace->pages_swapped,i)) && j<n;i++) list[j++] = addr;
  1076de:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
  1076e5:	eb 18                	jmp    1076ff <proc_mempagelist+0x138>
  1076e7:	8b 45 f4             	mov    -0xc(%ebp),%eax
  1076ea:	c1 e0 02             	shl    $0x2,%eax
  1076ed:	89 c2                	mov    %eax,%edx
  1076ef:	03 55 0c             	add    0xc(%ebp),%edx
  1076f2:	8b 45 f8             	mov    -0x8(%ebp),%eax
  1076f5:	89 02                	mov    %eax,(%edx)
  1076f7:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
  1076fb:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
  1076ff:	8b 45 ec             	mov    -0x14(%ebp),%eax
  107702:	8b 40 6c             	mov    0x6c(%eax),%eax
  107705:	8b 50 0c             	mov    0xc(%eax),%edx
  107708:	8b 45 f0             	mov    -0x10(%ebp),%eax
  10770b:	89 44 24 04          	mov    %eax,0x4(%esp)
  10770f:	89 14 24             	mov    %edx,(%esp)
  107712:	e8 70 33 00 00       	call   10aa87 <llist_get>
  107717:	89 45 f8             	mov    %eax,-0x8(%ebp)
  10771a:	83 7d f8 00          	cmpl   $0x0,-0x8(%ebp)
  10771e:	74 08                	je     107728 <proc_mempagelist+0x161>
  107720:	8b 45 f4             	mov    -0xc(%ebp),%eax
  107723:	3b 45 10             	cmp    0x10(%ebp),%eax
  107726:	72 bf                	jb     1076e7 <proc_mempagelist+0x120>
        return j;
  107728:	8b 45 f4             	mov    -0xc(%ebp),%eax
  10772b:	89 45 e8             	mov    %eax,-0x18(%ebp)
  10772e:	eb 07                	jmp    107737 <proc_mempagelist+0x170>
      }
    }
  }
  return -1;
  107730:	c7 45 e8 ff ff ff ff 	movl   $0xffffffff,-0x18(%ebp)
  107737:	8b 45 e8             	mov    -0x18(%ebp),%eax
}
  10773a:	83 c4 24             	add    $0x24,%esp
  10773d:	5b                   	pop    %ebx
  10773e:	5d                   	pop    %ebp
  10773f:	c3                   	ret    

00107740 <proc_system>:
 * Gives/Withdraws a process system privilegs
 *  @param proc_pid Process' PID
 *  @param system Whether process should have system privilegs or not
 *  @return Success?
 */
int proc_system(pid_t proc_pid,int system) {
  107740:	55                   	push   %ebp
  107741:	89 e5                	mov    %esp,%ebp
  107743:	83 ec 18             	sub    $0x18,%esp
  if (proc_current->system) {
  107746:	a1 a0 e1 10 00       	mov    0x10e1a0,%eax
  10774b:	8b 40 1c             	mov    0x1c(%eax),%eax
  10774e:	85 c0                	test   %eax,%eax
  107750:	74 45                	je     107797 <proc_system+0x57>
    proc_t *proc = proc_find(proc_pid);
  107752:	8b 45 08             	mov    0x8(%ebp),%eax
  107755:	89 04 24             	mov    %eax,(%esp)
  107758:	e8 12 ee ff ff       	call   10656f <proc_find>
  10775d:	89 45 fc             	mov    %eax,-0x4(%ebp)
    if (proc!=NULL && (system==1 || proc_current==proc->parent || proc_current==proc)) {
  107760:	83 7d fc 00          	cmpl   $0x0,-0x4(%ebp)
  107764:	74 31                	je     107797 <proc_system+0x57>
  107766:	83 7d 0c 01          	cmpl   $0x1,0xc(%ebp)
  10776a:	74 19                	je     107785 <proc_system+0x45>
  10776c:	8b 45 fc             	mov    -0x4(%ebp),%eax
  10776f:	8b 50 24             	mov    0x24(%eax),%edx
  107772:	a1 a0 e1 10 00       	mov    0x10e1a0,%eax
  107777:	39 c2                	cmp    %eax,%edx
  107779:	74 0a                	je     107785 <proc_system+0x45>
  10777b:	a1 a0 e1 10 00       	mov    0x10e1a0,%eax
  107780:	3b 45 fc             	cmp    -0x4(%ebp),%eax
  107783:	75 12                	jne    107797 <proc_system+0x57>
      proc->system = system;
  107785:	8b 55 fc             	mov    -0x4(%ebp),%edx
  107788:	8b 45 0c             	mov    0xc(%ebp),%eax
  10778b:	89 42 1c             	mov    %eax,0x1c(%edx)
      return 0;
  10778e:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
  107795:	eb 07                	jmp    10779e <proc_system+0x5e>
    }
  }
  return -1;
  107797:	c7 45 ec ff ff ff ff 	movl   $0xffffffff,-0x14(%ebp)
  10779e:	8b 45 ec             	mov    -0x14(%ebp),%eax
}
  1077a1:	c9                   	leave  
  1077a2:	c3                   	ret    

001077a3 <proc_jump>:
 * Jumps a process to a specified destination
 *  @param proc_pid Process' PID
 *  @param dest Destination to jump to
 *  @return Success
 */
int proc_jump(pid_t proc_pid,void *dest) {
  1077a3:	55                   	push   %ebp
  1077a4:	89 e5                	mov    %esp,%ebp
  1077a6:	83 ec 18             	sub    $0x18,%esp
  if (proc_current->system) {
  1077a9:	a1 a0 e1 10 00       	mov    0x10e1a0,%eax
  1077ae:	8b 40 1c             	mov    0x1c(%eax),%eax
  1077b1:	85 c0                	test   %eax,%eax
  1077b3:	74 26                	je     1077db <proc_jump+0x38>
    proc_t *proc = proc_find(proc_pid);
  1077b5:	8b 45 08             	mov    0x8(%ebp),%eax
  1077b8:	89 04 24             	mov    %eax,(%esp)
  1077bb:	e8 af ed ff ff       	call   10656f <proc_find>
  1077c0:	89 45 fc             	mov    %eax,-0x4(%ebp)
    if (proc!=NULL) {
  1077c3:	83 7d fc 00          	cmpl   $0x0,-0x4(%ebp)
  1077c7:	74 12                	je     1077db <proc_jump+0x38>
      proc->registers.eip = (uint32_t)dest;
  1077c9:	8b 55 0c             	mov    0xc(%ebp),%edx
  1077cc:	8b 45 fc             	mov    -0x4(%ebp),%eax
  1077cf:	89 50 4c             	mov    %edx,0x4c(%eax)
      return 0;
  1077d2:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
  1077d9:	eb 07                	jmp    1077e2 <proc_jump+0x3f>
    }
  }
  return -1;
  1077db:	c7 45 ec ff ff ff ff 	movl   $0xffffffff,-0x14(%ebp)
  1077e2:	8b 45 ec             	mov    -0x14(%ebp),%eax
}
  1077e5:	c9                   	leave  
  1077e6:	c3                   	ret    

001077e7 <proc_createstack>:
/**
 * Creates a stack for a process
 *  @param proc_pid Process' PID
 *  @return Stack address
 */
int *proc_createstack(pid_t proc_pid) {
  1077e7:	55                   	push   %ebp
  1077e8:	89 e5                	mov    %esp,%ebp
  1077ea:	83 ec 18             	sub    $0x18,%esp
  if (proc_current->system) {
  1077ed:	a1 a0 e1 10 00       	mov    0x10e1a0,%eax
  1077f2:	8b 40 1c             	mov    0x1c(%eax),%eax
  1077f5:	85 c0                	test   %eax,%eax
  1077f7:	74 43                	je     10783c <proc_createstack+0x55>
    proc_t *proc = proc_find(proc_pid);
  1077f9:	8b 45 08             	mov    0x8(%ebp),%eax
  1077fc:	89 04 24             	mov    %eax,(%esp)
  1077ff:	e8 6b ed ff ff       	call   10656f <proc_find>
  107804:	89 45 f8             	mov    %eax,-0x8(%ebp)
    if (proc!=NULL && proc->addrspace->stack==NULL) {
  107807:	83 7d f8 00          	cmpl   $0x0,-0x8(%ebp)
  10780b:	74 2f                	je     10783c <proc_createstack+0x55>
  10780d:	8b 45 f8             	mov    -0x8(%ebp),%eax
  107810:	8b 40 6c             	mov    0x6c(%eax),%eax
  107813:	8b 40 14             	mov    0x14(%eax),%eax
  107816:	85 c0                	test   %eax,%eax
  107818:	75 22                	jne    10783c <proc_createstack+0x55>
      int *stack = memuser_create_stack(proc->addrspace);
  10781a:	8b 45 f8             	mov    -0x8(%ebp),%eax
  10781d:	8b 40 6c             	mov    0x6c(%eax),%eax
  107820:	89 04 24             	mov    %eax,(%esp)
  107823:	e8 5b c7 ff ff       	call   103f83 <memuser_create_stack>
  107828:	89 45 fc             	mov    %eax,-0x4(%ebp)
      proc->registers.esp = (uint32_t)stack;
  10782b:	8b 55 fc             	mov    -0x4(%ebp),%edx
  10782e:	8b 45 f8             	mov    -0x8(%ebp),%eax
  107831:	89 50 48             	mov    %edx,0x48(%eax)
      return stack;
  107834:	8b 45 fc             	mov    -0x4(%ebp),%eax
  107837:	89 45 ec             	mov    %eax,-0x14(%ebp)
  10783a:	eb 07                	jmp    107843 <proc_createstack+0x5c>
    }
  }
  return NULL;
  10783c:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
  107843:	8b 45 ec             	mov    -0x14(%ebp),%eax
}
  107846:	c9                   	leave  
  107847:	c3                   	ret    

00107848 <rpc_init>:
#include <syscall.h>
#include <interrupt.h>

#include <cpu.h>

int rpc_init() {
  107848:	55                   	push   %ebp
  107849:	89 e5                	mov    %esp,%ebp
  10784b:	83 ec 18             	sub    $0x18,%esp
  rpc_functions = llist_create();
  10784e:	e8 81 30 00 00       	call   10a8d4 <llist_create>
  107853:	a3 30 e9 10 00       	mov    %eax,0x10e930
  rpc_lastid = 0;
  107858:	c7 05 34 e9 10 00 00 	movl   $0x0,0x10e934
  10785f:	00 00 00 
  if (syscall_create(SYSCALL_RPC_CREATE,rpc_function_create,5)==-1) return -1;
  107862:	c7 44 24 08 05 00 00 	movl   $0x5,0x8(%esp)
  107869:	00 
  10786a:	c7 44 24 04 a0 79 10 	movl   $0x1079a0,0x4(%esp)
  107871:	00 
  107872:	c7 04 24 21 00 00 00 	movl   $0x21,(%esp)
  107879:	e8 bc 25 00 00       	call   109e3a <syscall_create>
  10787e:	83 f8 ff             	cmp    $0xffffffff,%eax
  107881:	75 0c                	jne    10788f <rpc_init+0x47>
  107883:	c7 45 fc ff ff ff ff 	movl   $0xffffffff,-0x4(%ebp)
  10788a:	e9 0c 01 00 00       	jmp    10799b <rpc_init+0x153>
  if (syscall_create(SYSCALL_RPC_DESTROY,rpc_function_destroy,1)==-1) return -1;
  10788f:	c7 44 24 08 01 00 00 	movl   $0x1,0x8(%esp)
  107896:	00 
  107897:	c7 44 24 04 3e 7a 10 	movl   $0x107a3e,0x4(%esp)
  10789e:	00 
  10789f:	c7 04 24 22 00 00 00 	movl   $0x22,(%esp)
  1078a6:	e8 8f 25 00 00       	call   109e3a <syscall_create>
  1078ab:	83 f8 ff             	cmp    $0xffffffff,%eax
  1078ae:	75 0c                	jne    1078bc <rpc_init+0x74>
  1078b0:	c7 45 fc ff ff ff ff 	movl   $0xffffffff,-0x4(%ebp)
  1078b7:	e9 df 00 00 00       	jmp    10799b <rpc_init+0x153>
  if (syscall_create(SYSCALL_RPC_GETINFO,rpc_function_getinfo,9)==-1) return -1;
  1078bc:	c7 44 24 08 09 00 00 	movl   $0x9,0x8(%esp)
  1078c3:	00 
  1078c4:	c7 44 24 04 e5 7a 10 	movl   $0x107ae5,0x4(%esp)
  1078cb:	00 
  1078cc:	c7 04 24 23 00 00 00 	movl   $0x23,(%esp)
  1078d3:	e8 62 25 00 00       	call   109e3a <syscall_create>
  1078d8:	83 f8 ff             	cmp    $0xffffffff,%eax
  1078db:	75 0c                	jne    1078e9 <rpc_init+0xa1>
  1078dd:	c7 45 fc ff ff ff ff 	movl   $0xffffffff,-0x4(%ebp)
  1078e4:	e9 b2 00 00 00       	jmp    10799b <rpc_init+0x153>
  if (syscall_create(SYSCALL_RPC_CALL,rpc_function_call,5)==-1) return -1;
  1078e9:	c7 44 24 08 05 00 00 	movl   $0x5,0x8(%esp)
  1078f0:	00 
  1078f1:	c7 44 24 04 9d 7b 10 	movl   $0x107b9d,0x4(%esp)
  1078f8:	00 
  1078f9:	c7 04 24 24 00 00 00 	movl   $0x24,(%esp)
  107900:	e8 35 25 00 00       	call   109e3a <syscall_create>
  107905:	83 f8 ff             	cmp    $0xffffffff,%eax
  107908:	75 0c                	jne    107916 <rpc_init+0xce>
  10790a:	c7 45 fc ff ff ff ff 	movl   $0xffffffff,-0x4(%ebp)
  107911:	e9 85 00 00 00       	jmp    10799b <rpc_init+0x153>
  if (syscall_create(SYSCALL_RPC_POLL,rpc_call_poll,4)==-1) return -1;
  107916:	c7 44 24 08 04 00 00 	movl   $0x4,0x8(%esp)
  10791d:	00 
  10791e:	c7 44 24 04 d2 7c 10 	movl   $0x107cd2,0x4(%esp)
  107925:	00 
  107926:	c7 04 24 25 00 00 00 	movl   $0x25,(%esp)
  10792d:	e8 08 25 00 00       	call   109e3a <syscall_create>
  107932:	83 f8 ff             	cmp    $0xffffffff,%eax
  107935:	75 09                	jne    107940 <rpc_init+0xf8>
  107937:	c7 45 fc ff ff ff ff 	movl   $0xffffffff,-0x4(%ebp)
  10793e:	eb 5b                	jmp    10799b <rpc_init+0x153>
  if (syscall_create(SYSCALL_RPC_RETURN,rpc_call_return,2)==-1) return -1;
  107940:	c7 44 24 08 02 00 00 	movl   $0x2,0x8(%esp)
  107947:	00 
  107948:	c7 44 24 04 73 7d 10 	movl   $0x107d73,0x4(%esp)
  10794f:	00 
  107950:	c7 04 24 26 00 00 00 	movl   $0x26,(%esp)
  107957:	e8 de 24 00 00       	call   109e3a <syscall_create>
  10795c:	83 f8 ff             	cmp    $0xffffffff,%eax
  10795f:	75 09                	jne    10796a <rpc_init+0x122>
  107961:	c7 45 fc ff ff ff ff 	movl   $0xffffffff,-0x4(%ebp)
  107968:	eb 31                	jmp    10799b <rpc_init+0x153>
  if (syscall_create(SYSCALL_RPC_LIST,rpc_list,3)==-1) return -1;
  10796a:	c7 44 24 08 03 00 00 	movl   $0x3,0x8(%esp)
  107971:	00 
  107972:	c7 44 24 04 63 7f 10 	movl   $0x107f63,0x4(%esp)
  107979:	00 
  10797a:	c7 04 24 27 00 00 00 	movl   $0x27,(%esp)
  107981:	e8 b4 24 00 00       	call   109e3a <syscall_create>
  107986:	83 f8 ff             	cmp    $0xffffffff,%eax
  107989:	75 09                	jne    107994 <rpc_init+0x14c>
  10798b:	c7 45 fc ff ff ff ff 	movl   $0xffffffff,-0x4(%ebp)
  107992:	eb 07                	jmp    10799b <rpc_init+0x153>
  return 0;
  107994:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
  10799b:	8b 45 fc             	mov    -0x4(%ebp),%eax
}
  10799e:	c9                   	leave  
  10799f:	c3                   	ret    

001079a0 <rpc_function_create>:
 *  @param synopsis Funtion synopsis
 *  @param param_size Size of parameters
 *  @param ret_size Size of return value
 *  @return Function ID
 */
int rpc_function_create(char *name,void *func,char *synopsis,size_t params_size,size_t ret_size) {
  1079a0:	55                   	push   %ebp
  1079a1:	89 e5                	mov    %esp,%ebp
  1079a3:	83 ec 18             	sub    $0x18,%esp
  rpc_function_t *new = malloc(sizeof(rpc_function_t));
  1079a6:	c7 04 24 24 00 00 00 	movl   $0x24,(%esp)
  1079ad:	e8 b7 b5 ff ff       	call   102f69 <malloc>
  1079b2:	89 45 fc             	mov    %eax,-0x4(%ebp)
  new->id = rpc_lastid++;
  1079b5:	8b 15 34 e9 10 00    	mov    0x10e934,%edx
  1079bb:	8b 45 fc             	mov    -0x4(%ebp),%eax
  1079be:	89 10                	mov    %edx,(%eax)
  1079c0:	8d 42 01             	lea    0x1(%edx),%eax
  1079c3:	a3 34 e9 10 00       	mov    %eax,0x10e934
  new->name = strdup(name);
  1079c8:	8b 45 08             	mov    0x8(%ebp),%eax
  1079cb:	89 04 24             	mov    %eax,(%esp)
  1079ce:	e8 1e 45 00 00       	call   10bef1 <strdup>
  1079d3:	89 c2                	mov    %eax,%edx
  1079d5:	8b 45 fc             	mov    -0x4(%ebp),%eax
  1079d8:	89 50 04             	mov    %edx,0x4(%eax)
  new->func = func;
  1079db:	8b 55 fc             	mov    -0x4(%ebp),%edx
  1079de:	8b 45 0c             	mov    0xc(%ebp),%eax
  1079e1:	89 42 08             	mov    %eax,0x8(%edx)
  new->synopsis = strdup(synopsis);
  1079e4:	8b 45 10             	mov    0x10(%ebp),%eax
  1079e7:	89 04 24             	mov    %eax,(%esp)
  1079ea:	e8 02 45 00 00       	call   10bef1 <strdup>
  1079ef:	89 c2                	mov    %eax,%edx
  1079f1:	8b 45 fc             	mov    -0x4(%ebp),%eax
  1079f4:	89 50 0c             	mov    %edx,0xc(%eax)
  new->owner = proc_current;
  1079f7:	8b 15 a0 e1 10 00    	mov    0x10e1a0,%edx
  1079fd:	8b 45 fc             	mov    -0x4(%ebp),%eax
  107a00:	89 50 18             	mov    %edx,0x18(%eax)
  new->calls = llist_create();
  107a03:	e8 cc 2e 00 00       	call   10a8d4 <llist_create>
  107a08:	89 c2                	mov    %eax,%edx
  107a0a:	8b 45 fc             	mov    -0x4(%ebp),%eax
  107a0d:	89 50 1c             	mov    %edx,0x1c(%eax)
  new->params_size = params_size;
  107a10:	8b 55 fc             	mov    -0x4(%ebp),%edx
  107a13:	8b 45 14             	mov    0x14(%ebp),%eax
  107a16:	89 42 10             	mov    %eax,0x10(%edx)
  new->ret_size = ret_size;
  107a19:	8b 55 fc             	mov    -0x4(%ebp),%edx
  107a1c:	8b 45 18             	mov    0x18(%ebp),%eax
  107a1f:	89 42 14             	mov    %eax,0x14(%edx)
  llist_push(rpc_functions,new);
  107a22:	8b 15 30 e9 10 00    	mov    0x10e930,%edx
  107a28:	8b 45 fc             	mov    -0x4(%ebp),%eax
  107a2b:	89 44 24 04          	mov    %eax,0x4(%esp)
  107a2f:	89 14 24             	mov    %edx,(%esp)
  107a32:	e8 18 2f 00 00       	call   10a94f <llist_push>
  return new->id;
  107a37:	8b 45 fc             	mov    -0x4(%ebp),%eax
  107a3a:	8b 00                	mov    (%eax),%eax
}
  107a3c:	c9                   	leave  
  107a3d:	c3                   	ret    

00107a3e <rpc_function_destroy>:
/**
 * Destroys a RPC function (Syscall)
 *  @param id Function ID
 *  @return Success?
 */
int rpc_function_destroy(int id) {
  107a3e:	55                   	push   %ebp
  107a3f:	89 e5                	mov    %esp,%ebp
  107a41:	83 ec 28             	sub    $0x28,%esp
  rpc_function_t *func = rpc_find(id,NULL,NULL,0,0);
  107a44:	c7 44 24 10 00 00 00 	movl   $0x0,0x10(%esp)
  107a4b:	00 
  107a4c:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
  107a53:	00 
  107a54:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  107a5b:	00 
  107a5c:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  107a63:	00 
  107a64:	8b 45 08             	mov    0x8(%ebp),%eax
  107a67:	89 04 24             	mov    %eax,(%esp)
  107a6a:	e8 41 04 00 00       	call   107eb0 <rpc_find>
  107a6f:	89 45 f8             	mov    %eax,-0x8(%ebp)
  if (func!=NULL) {
  107a72:	83 7d f8 00          	cmpl   $0x0,-0x8(%ebp)
  107a76:	74 61                	je     107ad9 <rpc_function_destroy+0x9b>
    if (func->owner==proc_current) {
  107a78:	8b 45 f8             	mov    -0x8(%ebp),%eax
  107a7b:	8b 50 18             	mov    0x18(%eax),%edx
  107a7e:	a1 a0 e1 10 00       	mov    0x10e1a0,%eax
  107a83:	39 c2                	cmp    %eax,%edx
  107a85:	75 49                	jne    107ad0 <rpc_function_destroy+0x92>
      free(func->name);
  107a87:	8b 45 f8             	mov    -0x8(%ebp),%eax
  107a8a:	8b 40 04             	mov    0x4(%eax),%eax
  107a8d:	89 04 24             	mov    %eax,(%esp)
  107a90:	e8 08 b5 ff ff       	call   102f9d <free>
      free(func->synopsis);
  107a95:	8b 45 f8             	mov    -0x8(%ebp),%eax
  107a98:	8b 40 0c             	mov    0xc(%eax),%eax
  107a9b:	89 04 24             	mov    %eax,(%esp)
  107a9e:	e8 fa b4 ff ff       	call   102f9d <free>
  107aa3:	eb 0b                	jmp    107ab0 <rpc_function_destroy+0x72>
      rpc_call_t *call;
      while ((call = llist_pop(func->calls))) rpc_call_destroy(call);
  107aa5:	8b 45 fc             	mov    -0x4(%ebp),%eax
  107aa8:	89 04 24             	mov    %eax,(%esp)
  107aab:	e8 ef 01 00 00       	call   107c9f <rpc_call_destroy>
  107ab0:	8b 45 f8             	mov    -0x8(%ebp),%eax
  107ab3:	8b 40 1c             	mov    0x1c(%eax),%eax
  107ab6:	89 04 24             	mov    %eax,(%esp)
  107ab9:	e8 ea 2e 00 00       	call   10a9a8 <llist_pop>
  107abe:	89 45 fc             	mov    %eax,-0x4(%ebp)
  107ac1:	83 7d fc 00          	cmpl   $0x0,-0x4(%ebp)
  107ac5:	75 de                	jne    107aa5 <rpc_function_destroy+0x67>
      return 0;
  107ac7:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
  107ace:	eb 10                	jmp    107ae0 <rpc_function_destroy+0xa2>
    }
    else return -EACCES;
  107ad0:	c7 45 ec fe ff ff ff 	movl   $0xfffffffe,-0x14(%ebp)
  107ad7:	eb 07                	jmp    107ae0 <rpc_function_destroy+0xa2>
  }
  else return -EINVAL;
  107ad9:	c7 45 ec e4 ff ff ff 	movl   $0xffffffe4,-0x14(%ebp)
  107ae0:	8b 45 ec             	mov    -0x14(%ebp),%eax
}
  107ae3:	c9                   	leave  
  107ae4:	c3                   	ret    

00107ae5 <rpc_function_getinfo>:
 *  @param synopsis Buffer for synopsis
 *  @param maxlen Maxlen for synopsis
 *  @param sleep Whether to sleep til next found (works only for owner)
 *  @return Function ID
 */
int rpc_function_getinfo(int id,char *name,pid_t pid,int has_calls,size_t *params_size,size_t *ret_size,char *synopsis,size_t maxlen,int sleep) {
  107ae5:	55                   	push   %ebp
  107ae6:	89 e5                	mov    %esp,%ebp
  107ae8:	83 ec 28             	sub    $0x28,%esp
  rpc_function_t *func = rpc_find(id,name,NULL,pid,has_calls);
  107aeb:	8b 45 14             	mov    0x14(%ebp),%eax
  107aee:	89 44 24 10          	mov    %eax,0x10(%esp)
  107af2:	8b 45 10             	mov    0x10(%ebp),%eax
  107af5:	89 44 24 0c          	mov    %eax,0xc(%esp)
  107af9:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  107b00:	00 
  107b01:	8b 45 0c             	mov    0xc(%ebp),%eax
  107b04:	89 44 24 04          	mov    %eax,0x4(%esp)
  107b08:	8b 45 08             	mov    0x8(%ebp),%eax
  107b0b:	89 04 24             	mov    %eax,(%esp)
  107b0e:	e8 9d 03 00 00       	call   107eb0 <rpc_find>
  107b13:	89 45 fc             	mov    %eax,-0x4(%ebp)
  if (func!=NULL) {
  107b16:	83 7d fc 00          	cmpl   $0x0,-0x4(%ebp)
  107b1a:	74 3c                	je     107b58 <rpc_function_getinfo+0x73>
    strncpy(synopsis,func->synopsis,maxlen);
  107b1c:	8b 45 fc             	mov    -0x4(%ebp),%eax
  107b1f:	8b 50 0c             	mov    0xc(%eax),%edx
  107b22:	8b 45 24             	mov    0x24(%ebp),%eax
  107b25:	89 44 24 08          	mov    %eax,0x8(%esp)
  107b29:	89 54 24 04          	mov    %edx,0x4(%esp)
  107b2d:	8b 45 20             	mov    0x20(%ebp),%eax
  107b30:	89 04 24             	mov    %eax,(%esp)
  107b33:	e8 44 45 00 00       	call   10c07c <strncpy>
    *params_size = func->params_size;
  107b38:	8b 45 fc             	mov    -0x4(%ebp),%eax
  107b3b:	8b 50 10             	mov    0x10(%eax),%edx
  107b3e:	8b 45 18             	mov    0x18(%ebp),%eax
  107b41:	89 10                	mov    %edx,(%eax)
    *ret_size = func->ret_size;
  107b43:	8b 45 fc             	mov    -0x4(%ebp),%eax
  107b46:	8b 50 14             	mov    0x14(%eax),%edx
  107b49:	8b 45 1c             	mov    0x1c(%ebp),%eax
  107b4c:	89 10                	mov    %edx,(%eax)
    return func->id;
  107b4e:	8b 45 fc             	mov    -0x4(%ebp),%eax
  107b51:	8b 00                	mov    (%eax),%eax
  107b53:	89 45 ec             	mov    %eax,-0x14(%ebp)
  107b56:	eb 40                	jmp    107b98 <rpc_function_getinfo+0xb3>
  }
  else if (sleep && has_calls && pid==proc_current->pid) {
  107b58:	83 7d 28 00          	cmpl   $0x0,0x28(%ebp)
  107b5c:	74 33                	je     107b91 <rpc_function_getinfo+0xac>
  107b5e:	83 7d 14 00          	cmpl   $0x0,0x14(%ebp)
  107b62:	74 2d                	je     107b91 <rpc_function_getinfo+0xac>
  107b64:	a1 a0 e1 10 00       	mov    0x10e1a0,%eax
  107b69:	8b 00                	mov    (%eax),%eax
  107b6b:	3b 45 10             	cmp    0x10(%ebp),%eax
  107b6e:	75 21                	jne    107b91 <rpc_function_getinfo+0xac>
    *(interrupt_curregs.eax) = -1;
  107b70:	a1 20 e7 10 00       	mov    0x10e720,%eax
  107b75:	c7 00 ff ff ff ff    	movl   $0xffffffff,(%eax)
    proc_sleep(proc_current);
  107b7b:	a1 a0 e1 10 00       	mov    0x10e1a0,%eax
  107b80:	89 04 24             	mov    %eax,(%esp)
  107b83:	e8 99 ea ff ff       	call   106621 <proc_sleep>
    return -1;
  107b88:	c7 45 ec ff ff ff ff 	movl   $0xffffffff,-0x14(%ebp)
  107b8f:	eb 07                	jmp    107b98 <rpc_function_getinfo+0xb3>
  }
  else return -EINVAL;
  107b91:	c7 45 ec e4 ff ff ff 	movl   $0xffffffe4,-0x14(%ebp)
  107b98:	8b 45 ec             	mov    -0x14(%ebp),%eax
}
  107b9b:	c9                   	leave  
  107b9c:	c3                   	ret    

00107b9d <rpc_function_call>:
 *  @param ret_params Reference for return parameters (can be NULL)
 *  @param error Reference for RPC error
 *  @param sleep Sleep Reference
 *  @return Success?
 */
int rpc_function_call(int id,void *params,int *ret,void *retbuf,int *error) {
  107b9d:	55                   	push   %ebp
  107b9e:	89 e5                	mov    %esp,%ebp
  107ba0:	53                   	push   %ebx
  107ba1:	83 ec 34             	sub    $0x34,%esp
  rpc_function_t *func = rpc_find(id,NULL,NULL,0,0);
  107ba4:	c7 44 24 10 00 00 00 	movl   $0x0,0x10(%esp)
  107bab:	00 
  107bac:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
  107bb3:	00 
  107bb4:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  107bbb:	00 
  107bbc:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  107bc3:	00 
  107bc4:	8b 45 08             	mov    0x8(%ebp),%eax
  107bc7:	89 04 24             	mov    %eax,(%esp)
  107bca:	e8 e1 02 00 00       	call   107eb0 <rpc_find>
  107bcf:	89 45 f4             	mov    %eax,-0xc(%ebp)
  if (func!=NULL) {
  107bd2:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
  107bd6:	0f 84 b3 00 00 00    	je     107c8f <rpc_function_call+0xf2>
    rpc_call_t *new = malloc(sizeof(rpc_call_t));
  107bdc:	c7 04 24 14 00 00 00 	movl   $0x14,(%esp)
  107be3:	e8 81 b3 ff ff       	call   102f69 <malloc>
  107be8:	89 45 f8             	mov    %eax,-0x8(%ebp)
    new->caller = proc_current;
  107beb:	8b 15 a0 e1 10 00    	mov    0x10e1a0,%edx
  107bf1:	8b 45 f8             	mov    -0x8(%ebp),%eax
  107bf4:	89 10                	mov    %edx,(%eax)
    new->ret = ret;
  107bf6:	8b 55 f8             	mov    -0x8(%ebp),%edx
  107bf9:	8b 45 10             	mov    0x10(%ebp),%eax
  107bfc:	89 42 08             	mov    %eax,0x8(%edx)
    new->retbuf = retbuf;
  107bff:	8b 55 f8             	mov    -0x8(%ebp),%edx
  107c02:	8b 45 14             	mov    0x14(%ebp),%eax
  107c05:	89 42 0c             	mov    %eax,0xc(%edx)
    new->params = memcpy(malloc(func->params_size),params,func->params_size);
  107c08:	8b 45 f4             	mov    -0xc(%ebp),%eax
  107c0b:	8b 58 10             	mov    0x10(%eax),%ebx
  107c0e:	8b 45 f4             	mov    -0xc(%ebp),%eax
  107c11:	8b 40 10             	mov    0x10(%eax),%eax
  107c14:	89 04 24             	mov    %eax,(%esp)
  107c17:	e8 4d b3 ff ff       	call   102f69 <malloc>
  107c1c:	89 c2                	mov    %eax,%edx
  107c1e:	89 5c 24 08          	mov    %ebx,0x8(%esp)
  107c22:	8b 45 0c             	mov    0xc(%ebp),%eax
  107c25:	89 44 24 04          	mov    %eax,0x4(%esp)
  107c29:	89 14 24             	mov    %edx,(%esp)
  107c2c:	e8 53 3f 00 00       	call   10bb84 <memcpy>
  107c31:	89 c2                	mov    %eax,%edx
  107c33:	8b 45 f8             	mov    -0x8(%ebp),%eax
  107c36:	89 50 04             	mov    %edx,0x4(%eax)
    new->error = error;
  107c39:	8b 55 f8             	mov    -0x8(%ebp),%edx
  107c3c:	8b 45 18             	mov    0x18(%ebp),%eax
  107c3f:	89 42 10             	mov    %eax,0x10(%edx)
    llist_push(func->calls,new);
  107c42:	8b 45 f4             	mov    -0xc(%ebp),%eax
  107c45:	8b 50 1c             	mov    0x1c(%eax),%edx
  107c48:	8b 45 f8             	mov    -0x8(%ebp),%eax
  107c4b:	89 44 24 04          	mov    %eax,0x4(%esp)
  107c4f:	89 14 24             	mov    %edx,(%esp)
  107c52:	e8 f8 2c 00 00       	call   10a94f <llist_push>
    *error = 0;
  107c57:	8b 45 18             	mov    0x18(%ebp),%eax
  107c5a:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
    proc_wake(func->owner);
  107c60:	8b 45 f4             	mov    -0xc(%ebp),%eax
  107c63:	8b 40 18             	mov    0x18(%eax),%eax
  107c66:	89 04 24             	mov    %eax,(%esp)
  107c69:	e8 1f ea ff ff       	call   10668d <proc_wake>
    *(interrupt_curregs.eax) = 0;
  107c6e:	a1 20 e7 10 00       	mov    0x10e720,%eax
  107c73:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
    proc_sleep(proc_current);
  107c79:	a1 a0 e1 10 00       	mov    0x10e1a0,%eax
  107c7e:	89 04 24             	mov    %eax,(%esp)
  107c81:	e8 9b e9 ff ff       	call   106621 <proc_sleep>
    return 0;
  107c86:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
  107c8d:	eb 07                	jmp    107c96 <rpc_function_call+0xf9>
  }
  else return -EINVAL;
  107c8f:	c7 45 e8 e4 ff ff ff 	movl   $0xffffffe4,-0x18(%ebp)
  107c96:	8b 45 e8             	mov    -0x18(%ebp),%eax
}
  107c99:	83 c4 34             	add    $0x34,%esp
  107c9c:	5b                   	pop    %ebx
  107c9d:	5d                   	pop    %ebp
  107c9e:	c3                   	ret    

00107c9f <rpc_call_destroy>:
 * Destroys a RPC Call
 *  @param call RPC Call
 *  @return Success?
 *  @todo set *(call->error) in callers address space
 */
int rpc_call_destroy(rpc_call_t *call) {
  107c9f:	55                   	push   %ebp
  107ca0:	89 e5                	mov    %esp,%ebp
  107ca2:	83 ec 08             	sub    $0x8,%esp
  free(call->params);
  107ca5:	8b 45 08             	mov    0x8(%ebp),%eax
  107ca8:	8b 40 04             	mov    0x4(%eax),%eax
  107cab:	89 04 24             	mov    %eax,(%esp)
  107cae:	e8 ea b2 ff ff       	call   102f9d <free>
  proc_wake(call->caller);
  107cb3:	8b 45 08             	mov    0x8(%ebp),%eax
  107cb6:	8b 00                	mov    (%eax),%eax
  107cb8:	89 04 24             	mov    %eax,(%esp)
  107cbb:	e8 cd e9 ff ff       	call   10668d <proc_wake>
  //*(call->error) = 1;
  free(call);
  107cc0:	8b 45 08             	mov    0x8(%ebp),%eax
  107cc3:	89 04 24             	mov    %eax,(%esp)
  107cc6:	e8 d2 b2 ff ff       	call   102f9d <free>
  return 0;
  107ccb:	b8 00 00 00 00       	mov    $0x0,%eax
}
  107cd0:	c9                   	leave  
  107cd1:	c3                   	ret    

00107cd2 <rpc_call_poll>:
 *  @param func Reference for function pointer
 *  @param params Buffer for params
 *  @param caller Reference for caller PID
 *  @return Success?
 */
int rpc_call_poll(int id,void **func_ptr,void *params,pid_t *caller) {
  107cd2:	55                   	push   %ebp
  107cd3:	89 e5                	mov    %esp,%ebp
  107cd5:	83 ec 28             	sub    $0x28,%esp
  rpc_function_t *func = rpc_find(-1,NULL,proc_current,0,1);
  107cd8:	a1 a0 e1 10 00       	mov    0x10e1a0,%eax
  107cdd:	c7 44 24 10 01 00 00 	movl   $0x1,0x10(%esp)
  107ce4:	00 
  107ce5:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
  107cec:	00 
  107ced:	89 44 24 08          	mov    %eax,0x8(%esp)
  107cf1:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  107cf8:	00 
  107cf9:	c7 04 24 ff ff ff ff 	movl   $0xffffffff,(%esp)
  107d00:	e8 ab 01 00 00       	call   107eb0 <rpc_find>
  107d05:	89 45 f8             	mov    %eax,-0x8(%ebp)
  if (func!=NULL) {
  107d08:	83 7d f8 00          	cmpl   $0x0,-0x8(%ebp)
  107d0c:	74 59                	je     107d67 <rpc_call_poll+0x95>
    rpc_call_t *call = llist_pop(func->calls);
  107d0e:	8b 45 f8             	mov    -0x8(%ebp),%eax
  107d11:	8b 40 1c             	mov    0x1c(%eax),%eax
  107d14:	89 04 24             	mov    %eax,(%esp)
  107d17:	e8 8c 2c 00 00       	call   10a9a8 <llist_pop>
  107d1c:	89 45 fc             	mov    %eax,-0x4(%ebp)
    func->current = call;
  107d1f:	8b 55 f8             	mov    -0x8(%ebp),%edx
  107d22:	8b 45 fc             	mov    -0x4(%ebp),%eax
  107d25:	89 42 20             	mov    %eax,0x20(%edx)
    *func_ptr = func->func;
  107d28:	8b 45 f8             	mov    -0x8(%ebp),%eax
  107d2b:	8b 50 08             	mov    0x8(%eax),%edx
  107d2e:	8b 45 0c             	mov    0xc(%ebp),%eax
  107d31:	89 10                	mov    %edx,(%eax)
    *caller = call->caller->pid;
  107d33:	8b 45 fc             	mov    -0x4(%ebp),%eax
  107d36:	8b 00                	mov    (%eax),%eax
  107d38:	8b 10                	mov    (%eax),%edx
  107d3a:	8b 45 14             	mov    0x14(%ebp),%eax
  107d3d:	89 10                	mov    %edx,(%eax)
    memcpy(params,call->params,func->params_size);
  107d3f:	8b 45 f8             	mov    -0x8(%ebp),%eax
  107d42:	8b 50 10             	mov    0x10(%eax),%edx
  107d45:	8b 45 fc             	mov    -0x4(%ebp),%eax
  107d48:	8b 40 04             	mov    0x4(%eax),%eax
  107d4b:	89 54 24 08          	mov    %edx,0x8(%esp)
  107d4f:	89 44 24 04          	mov    %eax,0x4(%esp)
  107d53:	8b 45 10             	mov    0x10(%ebp),%eax
  107d56:	89 04 24             	mov    %eax,(%esp)
  107d59:	e8 26 3e 00 00       	call   10bb84 <memcpy>
    return 0;
  107d5e:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
  107d65:	eb 07                	jmp    107d6e <rpc_call_poll+0x9c>
  }
  else return -EINVAL;
  107d67:	c7 45 ec e4 ff ff ff 	movl   $0xffffffe4,-0x14(%ebp)
  107d6e:	8b 45 ec             	mov    -0x14(%ebp),%eax
}
  107d71:	c9                   	leave  
  107d72:	c3                   	ret    

00107d73 <rpc_call_return>:
 *  @param id Function ID (or -1)
 *  @param ret Return value
 *  @param ret_params Return params
 *  @return Success?
 */
int rpc_call_return(int id,int ret) {
  107d73:	55                   	push   %ebp
  107d74:	89 e5                	mov    %esp,%ebp
  107d76:	56                   	push   %esi
  107d77:	53                   	push   %ebx
  107d78:	83 ec 30             	sub    $0x30,%esp
  rpc_function_t *func = rpc_find(id,NULL,proc_current,0,0);
  107d7b:	a1 a0 e1 10 00       	mov    0x10e1a0,%eax
  107d80:	c7 44 24 10 00 00 00 	movl   $0x0,0x10(%esp)
  107d87:	00 
  107d88:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
  107d8f:	00 
  107d90:	89 44 24 08          	mov    %eax,0x8(%esp)
  107d94:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  107d9b:	00 
  107d9c:	8b 45 08             	mov    0x8(%ebp),%eax
  107d9f:	89 04 24             	mov    %eax,(%esp)
  107da2:	e8 09 01 00 00       	call   107eb0 <rpc_find>
  107da7:	89 45 ec             	mov    %eax,-0x14(%ebp)
  if (func!=NULL) {
  107daa:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
  107dae:	0f 84 eb 00 00 00    	je     107e9f <rpc_call_return+0x12c>
    rpc_call_t *call = func->current;
  107db4:	8b 45 ec             	mov    -0x14(%ebp),%eax
  107db7:	8b 40 20             	mov    0x20(%eax),%eax
  107dba:	89 45 f0             	mov    %eax,-0x10(%ebp)
    if (call!=NULL) {
  107dbd:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
  107dc1:	0f 84 d8 00 00 00    	je     107e9f <rpc_call_return+0x12c>
      if (call->retbuf!=NULL && ret!=0) {
  107dc7:	8b 45 f0             	mov    -0x10(%ebp),%eax
  107dca:	8b 40 0c             	mov    0xc(%eax),%eax
  107dcd:	85 c0                	test   %eax,%eax
  107dcf:	74 6c                	je     107e3d <rpc_call_return+0xca>
  107dd1:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
  107dd5:	74 66                	je     107e3d <rpc_call_return+0xca>
        void *buf = memcpy(malloc(func->ret_size),(void*)ret,func->ret_size);
  107dd7:	8b 45 ec             	mov    -0x14(%ebp),%eax
  107dda:	8b 58 14             	mov    0x14(%eax),%ebx
  107ddd:	8b 75 0c             	mov    0xc(%ebp),%esi
  107de0:	8b 45 ec             	mov    -0x14(%ebp),%eax
  107de3:	8b 40 14             	mov    0x14(%eax),%eax
  107de6:	89 04 24             	mov    %eax,(%esp)
  107de9:	e8 7b b1 ff ff       	call   102f69 <malloc>
  107dee:	89 5c 24 08          	mov    %ebx,0x8(%esp)
  107df2:	89 74 24 04          	mov    %esi,0x4(%esp)
  107df6:	89 04 24             	mov    %eax,(%esp)
  107df9:	e8 86 3d 00 00       	call   10bb84 <memcpy>
  107dfe:	89 45 f4             	mov    %eax,-0xc(%ebp)
        memuser_load_addrspace(call->caller->addrspace);
  107e01:	8b 45 f0             	mov    -0x10(%ebp),%eax
  107e04:	8b 00                	mov    (%eax),%eax
  107e06:	8b 40 6c             	mov    0x6c(%eax),%eax
  107e09:	89 04 24             	mov    %eax,(%esp)
  107e0c:	e8 0a be ff ff       	call   103c1b <memuser_load_addrspace>
        memcpy(call->retbuf,buf,func->params_size);
  107e11:	8b 45 ec             	mov    -0x14(%ebp),%eax
  107e14:	8b 50 10             	mov    0x10(%eax),%edx
  107e17:	8b 45 f0             	mov    -0x10(%ebp),%eax
  107e1a:	8b 48 0c             	mov    0xc(%eax),%ecx
  107e1d:	89 54 24 08          	mov    %edx,0x8(%esp)
  107e21:	8b 45 f4             	mov    -0xc(%ebp),%eax
  107e24:	89 44 24 04          	mov    %eax,0x4(%esp)
  107e28:	89 0c 24             	mov    %ecx,(%esp)
  107e2b:	e8 54 3d 00 00       	call   10bb84 <memcpy>
        free(buf);
  107e30:	8b 45 f4             	mov    -0xc(%ebp),%eax
  107e33:	89 04 24             	mov    %eax,(%esp)
  107e36:	e8 62 b1 ff ff       	call   102f9d <free>
  107e3b:	eb 10                	jmp    107e4d <rpc_call_return+0xda>
      }
      else memuser_load_addrspace(call->caller->addrspace);
  107e3d:	8b 45 f0             	mov    -0x10(%ebp),%eax
  107e40:	8b 00                	mov    (%eax),%eax
  107e42:	8b 40 6c             	mov    0x6c(%eax),%eax
  107e45:	89 04 24             	mov    %eax,(%esp)
  107e48:	e8 ce bd ff ff       	call   103c1b <memuser_load_addrspace>
      *(call->ret) = ret;
  107e4d:	8b 45 f0             	mov    -0x10(%ebp),%eax
  107e50:	8b 50 08             	mov    0x8(%eax),%edx
  107e53:	8b 45 0c             	mov    0xc(%ebp),%eax
  107e56:	89 02                	mov    %eax,(%edx)
      *(call->error) = 0;
  107e58:	8b 45 f0             	mov    -0x10(%ebp),%eax
  107e5b:	8b 40 10             	mov    0x10(%eax),%eax
  107e5e:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
      proc_wake(call->caller);
  107e64:	8b 45 f0             	mov    -0x10(%ebp),%eax
  107e67:	8b 00                	mov    (%eax),%eax
  107e69:	89 04 24             	mov    %eax,(%esp)
  107e6c:	e8 1c e8 ff ff       	call   10668d <proc_wake>
      memuser_load_addrspace(proc_current->addrspace); // done by proc_wake(), too
  107e71:	a1 a0 e1 10 00       	mov    0x10e1a0,%eax
  107e76:	8b 40 6c             	mov    0x6c(%eax),%eax
  107e79:	89 04 24             	mov    %eax,(%esp)
  107e7c:	e8 9a bd ff ff       	call   103c1b <memuser_load_addrspace>
      rpc_call_destroy(call);
  107e81:	8b 45 f0             	mov    -0x10(%ebp),%eax
  107e84:	89 04 24             	mov    %eax,(%esp)
  107e87:	e8 13 fe ff ff       	call   107c9f <rpc_call_destroy>
      func->current = NULL;
  107e8c:	8b 45 ec             	mov    -0x14(%ebp),%eax
  107e8f:	c7 40 20 00 00 00 00 	movl   $0x0,0x20(%eax)
      return 0;
  107e96:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
  107e9d:	eb 07                	jmp    107ea6 <rpc_call_return+0x133>
    }
  }
  return -EINVAL;
  107e9f:	c7 45 e4 e4 ff ff ff 	movl   $0xffffffe4,-0x1c(%ebp)
  107ea6:	8b 45 e4             	mov    -0x1c(%ebp),%eax
}
  107ea9:	83 c4 30             	add    $0x30,%esp
  107eac:	5b                   	pop    %ebx
  107ead:	5e                   	pop    %esi
  107eae:	5d                   	pop    %ebp
  107eaf:	c3                   	ret    

00107eb0 <rpc_find>:
 *  @param owner Function owner (or NULL)
 *  @param pid Function owner's PID (or 0)
 *  @param has_calls Whether to check if functions is called
 *  @return RPC function
 */
rpc_function_t *rpc_find(int id,char *name,proc_t *owner,pid_t pid,int has_calls) {
  107eb0:	55                   	push   %ebp
  107eb1:	89 e5                	mov    %esp,%ebp
  107eb3:	83 ec 28             	sub    $0x28,%esp
  rpc_function_t *func;
  size_t i;
  for (i=0;(func = llist_get(rpc_functions,i));i++) {
  107eb6:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
  107ebd:	eb 77                	jmp    107f36 <rpc_find+0x86>
    if ((id==-1 || id==func->id) && (name==NULL || strcmp(name,func->name)==0) && (owner==NULL || owner==func->owner) && (pid==0 || pid==func->owner->pid) && (has_calls==0 || !llist_empty(func->calls))) return func;
  107ebf:	83 7d 08 ff          	cmpl   $0xffffffff,0x8(%ebp)
  107ec3:	74 0a                	je     107ecf <rpc_find+0x1f>
  107ec5:	8b 45 f8             	mov    -0x8(%ebp),%eax
  107ec8:	8b 00                	mov    (%eax),%eax
  107eca:	3b 45 08             	cmp    0x8(%ebp),%eax
  107ecd:	75 63                	jne    107f32 <rpc_find+0x82>
  107ecf:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
  107ed3:	74 19                	je     107eee <rpc_find+0x3e>
  107ed5:	8b 45 f8             	mov    -0x8(%ebp),%eax
  107ed8:	8b 40 04             	mov    0x4(%eax),%eax
  107edb:	89 44 24 04          	mov    %eax,0x4(%esp)
  107edf:	8b 45 0c             	mov    0xc(%ebp),%eax
  107ee2:	89 04 24             	mov    %eax,(%esp)
  107ee5:	e8 32 3f 00 00       	call   10be1c <strcmp>
  107eea:	85 c0                	test   %eax,%eax
  107eec:	75 44                	jne    107f32 <rpc_find+0x82>
  107eee:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
  107ef2:	74 0b                	je     107eff <rpc_find+0x4f>
  107ef4:	8b 45 f8             	mov    -0x8(%ebp),%eax
  107ef7:	8b 40 18             	mov    0x18(%eax),%eax
  107efa:	3b 45 10             	cmp    0x10(%ebp),%eax
  107efd:	75 33                	jne    107f32 <rpc_find+0x82>
  107eff:	83 7d 14 00          	cmpl   $0x0,0x14(%ebp)
  107f03:	74 0d                	je     107f12 <rpc_find+0x62>
  107f05:	8b 45 f8             	mov    -0x8(%ebp),%eax
  107f08:	8b 40 18             	mov    0x18(%eax),%eax
  107f0b:	8b 00                	mov    (%eax),%eax
  107f0d:	3b 45 14             	cmp    0x14(%ebp),%eax
  107f10:	75 20                	jne    107f32 <rpc_find+0x82>
  107f12:	83 7d 18 00          	cmpl   $0x0,0x18(%ebp)
  107f16:	74 12                	je     107f2a <rpc_find+0x7a>
  107f18:	8b 45 f8             	mov    -0x8(%ebp),%eax
  107f1b:	8b 40 1c             	mov    0x1c(%eax),%eax
  107f1e:	89 04 24             	mov    %eax,(%esp)
  107f21:	e8 fd 29 00 00       	call   10a923 <llist_size>
  107f26:	85 c0                	test   %eax,%eax
  107f28:	74 08                	je     107f32 <rpc_find+0x82>
  107f2a:	8b 45 f8             	mov    -0x8(%ebp),%eax
  107f2d:	89 45 ec             	mov    %eax,-0x14(%ebp)
  107f30:	eb 2c                	jmp    107f5e <rpc_find+0xae>
 *  @return RPC function
 */
rpc_function_t *rpc_find(int id,char *name,proc_t *owner,pid_t pid,int has_calls) {
  rpc_function_t *func;
  size_t i;
  for (i=0;(func = llist_get(rpc_functions,i));i++) {
  107f32:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
  107f36:	a1 30 e9 10 00       	mov    0x10e930,%eax
  107f3b:	8b 55 fc             	mov    -0x4(%ebp),%edx
  107f3e:	89 54 24 04          	mov    %edx,0x4(%esp)
  107f42:	89 04 24             	mov    %eax,(%esp)
  107f45:	e8 3d 2b 00 00       	call   10aa87 <llist_get>
  107f4a:	89 45 f8             	mov    %eax,-0x8(%ebp)
  107f4d:	83 7d f8 00          	cmpl   $0x0,-0x8(%ebp)
  107f51:	0f 85 68 ff ff ff    	jne    107ebf <rpc_find+0xf>
    if ((id==-1 || id==func->id) && (name==NULL || strcmp(name,func->name)==0) && (owner==NULL || owner==func->owner) && (pid==0 || pid==func->owner->pid) && (has_calls==0 || !llist_empty(func->calls))) return func;
  }
  return NULL;
  107f57:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
  107f5e:	8b 45 ec             	mov    -0x14(%ebp),%eax
}
  107f61:	c9                   	leave  
  107f62:	c3                   	ret    

00107f63 <rpc_list>:
 *  @param i Index of current function
 *  @param buf Buffer for name
 *  @param bufsize Size of buffer
 *  @return Count of copied bytes
 */
size_t rpc_list(size_t i,char *buf,size_t bufsize) {
  107f63:	55                   	push   %ebp
  107f64:	89 e5                	mov    %esp,%ebp
  107f66:	83 ec 28             	sub    $0x28,%esp
  rpc_function_t *func;
  func = llist_get(rpc_functions,i);
  107f69:	a1 30 e9 10 00       	mov    0x10e930,%eax
  107f6e:	8b 55 08             	mov    0x8(%ebp),%edx
  107f71:	89 54 24 04          	mov    %edx,0x4(%esp)
  107f75:	89 04 24             	mov    %eax,(%esp)
  107f78:	e8 0a 2b 00 00       	call   10aa87 <llist_get>
  107f7d:	89 45 fc             	mov    %eax,-0x4(%ebp)
  if (func!=NULL) {
  107f80:	83 7d fc 00          	cmpl   $0x0,-0x4(%ebp)
  107f84:	74 51                	je     107fd7 <rpc_list+0x74>
    if (buf==NULL || bufsize==0) { // only return size
  107f86:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
  107f8a:	74 06                	je     107f92 <rpc_list+0x2f>
  107f8c:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
  107f90:	75 16                	jne    107fa8 <rpc_list+0x45>
      return strlen(func->name)+1;
  107f92:	8b 45 fc             	mov    -0x4(%ebp),%eax
  107f95:	8b 40 04             	mov    0x4(%eax),%eax
  107f98:	89 04 24             	mov    %eax,(%esp)
  107f9b:	e8 9c 3f 00 00       	call   10bf3c <strlen>
  107fa0:	83 c0 01             	add    $0x1,%eax
  107fa3:	89 45 ec             	mov    %eax,-0x14(%ebp)
  107fa6:	eb 36                	jmp    107fde <rpc_list+0x7b>
    }
    else {
      strncpy(buf,func->name,bufsize);
  107fa8:	8b 45 fc             	mov    -0x4(%ebp),%eax
  107fab:	8b 50 04             	mov    0x4(%eax),%edx
  107fae:	8b 45 10             	mov    0x10(%ebp),%eax
  107fb1:	89 44 24 08          	mov    %eax,0x8(%esp)
  107fb5:	89 54 24 04          	mov    %edx,0x4(%esp)
  107fb9:	8b 45 0c             	mov    0xc(%ebp),%eax
  107fbc:	89 04 24             	mov    %eax,(%esp)
  107fbf:	e8 b8 40 00 00       	call   10c07c <strncpy>
      return strlen(buf)+1;
  107fc4:	8b 45 0c             	mov    0xc(%ebp),%eax
  107fc7:	89 04 24             	mov    %eax,(%esp)
  107fca:	e8 6d 3f 00 00       	call   10bf3c <strlen>
  107fcf:	83 c0 01             	add    $0x1,%eax
  107fd2:	89 45 ec             	mov    %eax,-0x14(%ebp)
  107fd5:	eb 07                	jmp    107fde <rpc_list+0x7b>
    }
  }
  else return 0;
  107fd7:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
  107fde:	8b 45 ec             	mov    -0x14(%ebp),%eax
}
  107fe1:	c9                   	leave  
  107fe2:	c3                   	ret    
	...

00107fe4 <ipc_sem_init>:

/**
 * Initializes semaphore IPC
 *  @return Success?
 */
int ipc_sem_init() {
  107fe4:	55                   	push   %ebp
  107fe5:	89 e5                	mov    %esp,%ebp
  107fe7:	83 ec 18             	sub    $0x18,%esp
  if (syscall_create(SYSCALL_IPC_SEM_GET,ipc_sem_get,1)==-1) return -1;
  107fea:	c7 44 24 08 01 00 00 	movl   $0x1,0x8(%esp)
  107ff1:	00 
  107ff2:	c7 44 24 04 09 82 10 	movl   $0x108209,0x4(%esp)
  107ff9:	00 
  107ffa:	c7 04 24 0e 00 00 00 	movl   $0xe,(%esp)
  108001:	e8 34 1e 00 00       	call   109e3a <syscall_create>
  108006:	83 f8 ff             	cmp    $0xffffffff,%eax
  108009:	75 0c                	jne    108017 <ipc_sem_init+0x33>
  10800b:	c7 45 fc ff ff ff ff 	movl   $0xffffffff,-0x4(%ebp)
  108012:	e9 ed 01 00 00       	jmp    108204 <ipc_sem_init+0x220>
  if (syscall_create(SYSCALL_IPC_SEM_CREATE,ipc_sem_create,4)==-1) return -1;
  108017:	c7 44 24 08 04 00 00 	movl   $0x4,0x8(%esp)
  10801e:	00 
  10801f:	c7 44 24 04 4a 82 10 	movl   $0x10824a,0x4(%esp)
  108026:	00 
  108027:	c7 04 24 0f 00 00 00 	movl   $0xf,(%esp)
  10802e:	e8 07 1e 00 00       	call   109e3a <syscall_create>
  108033:	83 f8 ff             	cmp    $0xffffffff,%eax
  108036:	75 0c                	jne    108044 <ipc_sem_init+0x60>
  108038:	c7 45 fc ff ff ff ff 	movl   $0xffffffff,-0x4(%ebp)
  10803f:	e9 c0 01 00 00       	jmp    108204 <ipc_sem_init+0x220>
  if (syscall_create(SYSCALL_IPC_SEM_OP,ipc_sem_op,4)==-1) return -1;
  108044:	c7 44 24 08 04 00 00 	movl   $0x4,0x8(%esp)
  10804b:	00 
  10804c:	c7 44 24 04 0c 84 10 	movl   $0x10840c,0x4(%esp)
  108053:	00 
  108054:	c7 04 24 10 00 00 00 	movl   $0x10,(%esp)
  10805b:	e8 da 1d 00 00       	call   109e3a <syscall_create>
  108060:	83 f8 ff             	cmp    $0xffffffff,%eax
  108063:	75 0c                	jne    108071 <ipc_sem_init+0x8d>
  108065:	c7 45 fc ff ff ff ff 	movl   $0xffffffff,-0x4(%ebp)
  10806c:	e9 93 01 00 00       	jmp    108204 <ipc_sem_init+0x220>
  if (syscall_create(SYSCALL_IPC_SEM_GETVAL,ipc_sem_getval,2)==-1) return -1;
  108071:	c7 44 24 08 02 00 00 	movl   $0x2,0x8(%esp)
  108078:	00 
  108079:	c7 44 24 04 1b 87 10 	movl   $0x10871b,0x4(%esp)
  108080:	00 
  108081:	c7 04 24 11 00 00 00 	movl   $0x11,(%esp)
  108088:	e8 ad 1d 00 00       	call   109e3a <syscall_create>
  10808d:	83 f8 ff             	cmp    $0xffffffff,%eax
  108090:	75 0c                	jne    10809e <ipc_sem_init+0xba>
  108092:	c7 45 fc ff ff ff ff 	movl   $0xffffffff,-0x4(%ebp)
  108099:	e9 66 01 00 00       	jmp    108204 <ipc_sem_init+0x220>
  if (syscall_create(SYSCALL_IPC_SEM_SETVAL,ipc_sem_setval,4)==-1) return -1;
  10809e:	c7 44 24 08 04 00 00 	movl   $0x4,0x8(%esp)
  1080a5:	00 
  1080a6:	c7 44 24 04 f2 87 10 	movl   $0x1087f2,0x4(%esp)
  1080ad:	00 
  1080ae:	c7 04 24 12 00 00 00 	movl   $0x12,(%esp)
  1080b5:	e8 80 1d 00 00       	call   109e3a <syscall_create>
  1080ba:	83 f8 ff             	cmp    $0xffffffff,%eax
  1080bd:	75 0c                	jne    1080cb <ipc_sem_init+0xe7>
  1080bf:	c7 45 fc ff ff ff ff 	movl   $0xffffffff,-0x4(%ebp)
  1080c6:	e9 39 01 00 00       	jmp    108204 <ipc_sem_init+0x220>
  if (syscall_create(SYSCALL_IPC_SEM_GETPID,ipc_sem_getpid,2)==-1) return -1;
  1080cb:	c7 44 24 08 02 00 00 	movl   $0x2,0x8(%esp)
  1080d2:	00 
  1080d3:	c7 44 24 04 09 89 10 	movl   $0x108909,0x4(%esp)
  1080da:	00 
  1080db:	c7 04 24 13 00 00 00 	movl   $0x13,(%esp)
  1080e2:	e8 53 1d 00 00       	call   109e3a <syscall_create>
  1080e7:	83 f8 ff             	cmp    $0xffffffff,%eax
  1080ea:	75 0c                	jne    1080f8 <ipc_sem_init+0x114>
  1080ec:	c7 45 fc ff ff ff ff 	movl   $0xffffffff,-0x4(%ebp)
  1080f3:	e9 0c 01 00 00       	jmp    108204 <ipc_sem_init+0x220>
  if (syscall_create(SYSCALL_IPC_SEM_GETCNT,ipc_sem_getcnt,3)==-1) return -1;
  1080f8:	c7 44 24 08 03 00 00 	movl   $0x3,0x8(%esp)
  1080ff:	00 
  108100:	c7 44 24 04 e0 89 10 	movl   $0x1089e0,0x4(%esp)
  108107:	00 
  108108:	c7 04 24 14 00 00 00 	movl   $0x14,(%esp)
  10810f:	e8 26 1d 00 00       	call   109e3a <syscall_create>
  108114:	83 f8 ff             	cmp    $0xffffffff,%eax
  108117:	75 0c                	jne    108125 <ipc_sem_init+0x141>
  108119:	c7 45 fc ff ff ff ff 	movl   $0xffffffff,-0x4(%ebp)
  108120:	e9 df 00 00 00       	jmp    108204 <ipc_sem_init+0x220>
  if (syscall_create(SYSCALL_IPC_SEM_GETALL,ipc_sem_getall,2)==-1) return -1;
  108125:	c7 44 24 08 02 00 00 	movl   $0x2,0x8(%esp)
  10812c:	00 
  10812d:	c7 44 24 04 e9 8a 10 	movl   $0x108ae9,0x4(%esp)
  108134:	00 
  108135:	c7 04 24 15 00 00 00 	movl   $0x15,(%esp)
  10813c:	e8 f9 1c 00 00       	call   109e3a <syscall_create>
  108141:	83 f8 ff             	cmp    $0xffffffff,%eax
  108144:	75 0c                	jne    108152 <ipc_sem_init+0x16e>
  108146:	c7 45 fc ff ff ff ff 	movl   $0xffffffff,-0x4(%ebp)
  10814d:	e9 b2 00 00 00       	jmp    108204 <ipc_sem_init+0x220>
  if (syscall_create(SYSCALL_IPC_SEM_SETALL,ipc_sem_setall,3)==-1) return -1;
  108152:	c7 44 24 08 03 00 00 	movl   $0x3,0x8(%esp)
  108159:	00 
  10815a:	c7 44 24 04 da 8b 10 	movl   $0x108bda,0x4(%esp)
  108161:	00 
  108162:	c7 04 24 16 00 00 00 	movl   $0x16,(%esp)
  108169:	e8 cc 1c 00 00       	call   109e3a <syscall_create>
  10816e:	83 f8 ff             	cmp    $0xffffffff,%eax
  108171:	75 0c                	jne    10817f <ipc_sem_init+0x19b>
  108173:	c7 45 fc ff ff ff ff 	movl   $0xffffffff,-0x4(%ebp)
  10817a:	e9 85 00 00 00       	jmp    108204 <ipc_sem_init+0x220>
  if (syscall_create(SYSCALL_IPC_SEM_STAT,ipc_sem_stat,9)==-1) return -1;
  10817f:	c7 44 24 08 09 00 00 	movl   $0x9,0x8(%esp)
  108186:	00 
  108187:	c7 44 24 04 d3 8c 10 	movl   $0x108cd3,0x4(%esp)
  10818e:	00 
  10818f:	c7 04 24 17 00 00 00 	movl   $0x17,(%esp)
  108196:	e8 9f 1c 00 00       	call   109e3a <syscall_create>
  10819b:	83 f8 ff             	cmp    $0xffffffff,%eax
  10819e:	75 09                	jne    1081a9 <ipc_sem_init+0x1c5>
  1081a0:	c7 45 fc ff ff ff ff 	movl   $0xffffffff,-0x4(%ebp)
  1081a7:	eb 5b                	jmp    108204 <ipc_sem_init+0x220>
  if (syscall_create(SYSCALL_IPC_SEM_SET,ipc_sem_set,5)==-1) return -1;
  1081a9:	c7 44 24 08 05 00 00 	movl   $0x5,0x8(%esp)
  1081b0:	00 
  1081b1:	c7 44 24 04 ea 8d 10 	movl   $0x108dea,0x4(%esp)
  1081b8:	00 
  1081b9:	c7 04 24 18 00 00 00 	movl   $0x18,(%esp)
  1081c0:	e8 75 1c 00 00       	call   109e3a <syscall_create>
  1081c5:	83 f8 ff             	cmp    $0xffffffff,%eax
  1081c8:	75 09                	jne    1081d3 <ipc_sem_init+0x1ef>
  1081ca:	c7 45 fc ff ff ff ff 	movl   $0xffffffff,-0x4(%ebp)
  1081d1:	eb 31                	jmp    108204 <ipc_sem_init+0x220>
  if (syscall_create(SYSCALL_IPC_SEM_DESTROY,ipc_sem_destroy,1)==-1) return -1;
  1081d3:	c7 44 24 08 01 00 00 	movl   $0x1,0x8(%esp)
  1081da:	00 
  1081db:	c7 44 24 04 af 8e 10 	movl   $0x108eaf,0x4(%esp)
  1081e2:	00 
  1081e3:	c7 04 24 19 00 00 00 	movl   $0x19,(%esp)
  1081ea:	e8 4b 1c 00 00       	call   109e3a <syscall_create>
  1081ef:	83 f8 ff             	cmp    $0xffffffff,%eax
  1081f2:	75 09                	jne    1081fd <ipc_sem_init+0x219>
  1081f4:	c7 45 fc ff ff ff ff 	movl   $0xffffffff,-0x4(%ebp)
  1081fb:	eb 07                	jmp    108204 <ipc_sem_init+0x220>
  return 0;
  1081fd:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
  108204:	8b 45 fc             	mov    -0x4(%ebp),%eax
}
  108207:	c9                   	leave  
  108208:	c3                   	ret    

00108209 <ipc_sem_get>:
/**
 * Gets a semaphore set (Syscall)
 *  @param key IPC Key
 *  @return SemID
 */
id_t ipc_sem_get(key_t key) {
  108209:	55                   	push   %ebp
  10820a:	89 e5                	mov    %esp,%ebp
  10820c:	83 ec 28             	sub    $0x28,%esp
  ipc_sem_t *semset = ipc_sem_find(key,-1);
  10820f:	c7 44 24 08 03 00 00 	movl   $0x3,0x8(%esp)
  108216:	00 
  108217:	c7 44 24 04 ff ff ff 	movl   $0xffffffff,0x4(%esp)
  10821e:	ff 
  10821f:	8b 45 08             	mov    0x8(%ebp),%eax
  108222:	89 04 24             	mov    %eax,(%esp)
  108225:	e8 e1 92 ff ff       	call   10150b <ipc_find>
  10822a:	89 45 fc             	mov    %eax,-0x4(%ebp)
  if (semset==NULL) return -EINVAL;
  10822d:	83 7d fc 00          	cmpl   $0x0,-0x4(%ebp)
  108231:	75 09                	jne    10823c <ipc_sem_get+0x33>
  108233:	c7 45 ec e4 ff ff ff 	movl   $0xffffffe4,-0x14(%ebp)
  10823a:	eb 09                	jmp    108245 <ipc_sem_get+0x3c>
  else return semset->ipc.id;
  10823c:	8b 45 fc             	mov    -0x4(%ebp),%eax
  10823f:	8b 40 04             	mov    0x4(%eax),%eax
  108242:	89 45 ec             	mov    %eax,-0x14(%ebp)
  108245:	8b 45 ec             	mov    -0x14(%ebp),%eax
}
  108248:	c9                   	leave  
  108249:	c3                   	ret    

0010824a <ipc_sem_create>:
 *  @param key IPC Key
 *  @param mode Permissions
 *  @param time Current time
 *  @return SemID
 */
int ipc_sem_create(key_t key,size_t nsems,mode_t mode,time_t time) {
  10824a:	55                   	push   %ebp
  10824b:	89 e5                	mov    %esp,%ebp
  10824d:	53                   	push   %ebx
  10824e:	83 ec 24             	sub    $0x24,%esp
  ipc_sem_t *semset = key!=IPC_PRIVATE?ipc_sem_find(key,-1):NULL;
  108251:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
  108255:	74 20                	je     108277 <ipc_sem_create+0x2d>
  108257:	c7 44 24 08 03 00 00 	movl   $0x3,0x8(%esp)
  10825e:	00 
  10825f:	c7 44 24 04 ff ff ff 	movl   $0xffffffff,0x4(%esp)
  108266:	ff 
  108267:	8b 45 08             	mov    0x8(%ebp),%eax
  10826a:	89 04 24             	mov    %eax,(%esp)
  10826d:	e8 99 92 ff ff       	call   10150b <ipc_find>
  108272:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  108275:	eb 07                	jmp    10827e <ipc_sem_create+0x34>
  108277:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
  10827e:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  108281:	89 45 f0             	mov    %eax,-0x10(%ebp)
  if (semset==NULL) {
  108284:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
  108288:	0f 85 6e 01 00 00    	jne    1083fc <ipc_sem_create+0x1b2>
    ipc_sem_t *new = malloc(sizeof(ipc_sem_t));
  10828e:	c7 04 24 28 00 00 00 	movl   $0x28,(%esp)
  108295:	e8 cf ac ff ff       	call   102f69 <malloc>
  10829a:	89 45 f4             	mov    %eax,-0xc(%ebp)
    if (new!=NULL) {
  10829d:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
  1082a1:	0f 84 4c 01 00 00    	je     1083f3 <ipc_sem_create+0x1a9>
      size_t i;
      new->ipc.type = IPC_SEM;
  1082a7:	8b 45 f4             	mov    -0xc(%ebp),%eax
  1082aa:	c7 00 03 00 00 00    	movl   $0x3,(%eax)
      new->ipc.id = ipc_lastid++;
  1082b0:	8b 15 98 e1 10 00    	mov    0x10e198,%edx
  1082b6:	8b 45 f4             	mov    -0xc(%ebp),%eax
  1082b9:	89 50 04             	mov    %edx,0x4(%eax)
  1082bc:	8d 42 01             	lea    0x1(%edx),%eax
  1082bf:	a3 98 e1 10 00       	mov    %eax,0x10e198
      new->ipc.key = key;
  1082c4:	8b 55 f4             	mov    -0xc(%ebp),%edx
  1082c7:	8b 45 08             	mov    0x8(%ebp),%eax
  1082ca:	89 42 08             	mov    %eax,0x8(%edx)
      new->ipc.owner = proc_current;
  1082cd:	8b 15 a0 e1 10 00    	mov    0x10e1a0,%edx
  1082d3:	8b 45 f4             	mov    -0xc(%ebp),%eax
  1082d6:	89 50 0c             	mov    %edx,0xc(%eax)
      new->ipc.creator = proc_current;
  1082d9:	8b 15 a0 e1 10 00    	mov    0x10e1a0,%edx
  1082df:	8b 45 f4             	mov    -0xc(%ebp),%eax
  1082e2:	89 50 10             	mov    %edx,0x10(%eax)
      new->ipc.mode = mode;
  1082e5:	8b 55 f4             	mov    -0xc(%ebp),%edx
  1082e8:	8b 45 10             	mov    0x10(%ebp),%eax
  1082eb:	89 42 14             	mov    %eax,0x14(%edx)
      new->otime = 0;
  1082ee:	8b 45 f4             	mov    -0xc(%ebp),%eax
  1082f1:	c7 40 20 00 00 00 00 	movl   $0x0,0x20(%eax)
      new->ctime = time;
  1082f8:	8b 55 f4             	mov    -0xc(%ebp),%edx
  1082fb:	8b 45 14             	mov    0x14(%ebp),%eax
  1082fe:	89 42 24             	mov    %eax,0x24(%edx)
      new->sems = malloc(sizeof(ipc_sem_sem_t)*nsems);
  108301:	8b 55 0c             	mov    0xc(%ebp),%edx
  108304:	89 d0                	mov    %edx,%eax
  108306:	c1 e0 02             	shl    $0x2,%eax
  108309:	01 d0                	add    %edx,%eax
  10830b:	c1 e0 02             	shl    $0x2,%eax
  10830e:	89 04 24             	mov    %eax,(%esp)
  108311:	e8 53 ac ff ff       	call   102f69 <malloc>
  108316:	89 c2                	mov    %eax,%edx
  108318:	8b 45 f4             	mov    -0xc(%ebp),%eax
  10831b:	89 50 1c             	mov    %edx,0x1c(%eax)
      new->num = nsems;
  10831e:	8b 55 f4             	mov    -0xc(%ebp),%edx
  108321:	8b 45 0c             	mov    0xc(%ebp),%eax
  108324:	89 42 18             	mov    %eax,0x18(%edx)
      for (i=0;i<nsems;i++) {
  108327:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
  10832e:	e9 95 00 00 00       	jmp    1083c8 <ipc_sem_create+0x17e>
        new->sems[i].semset = new;
  108333:	8b 45 f4             	mov    -0xc(%ebp),%eax
  108336:	8b 48 1c             	mov    0x1c(%eax),%ecx
  108339:	8b 55 f8             	mov    -0x8(%ebp),%edx
  10833c:	89 d0                	mov    %edx,%eax
  10833e:	c1 e0 02             	shl    $0x2,%eax
  108341:	01 d0                	add    %edx,%eax
  108343:	c1 e0 02             	shl    $0x2,%eax
  108346:	8d 14 01             	lea    (%ecx,%eax,1),%edx
  108349:	8b 45 f4             	mov    -0xc(%ebp),%eax
  10834c:	89 02                	mov    %eax,(%edx)
        new->sems[i].val = 0;
  10834e:	8b 45 f4             	mov    -0xc(%ebp),%eax
  108351:	8b 48 1c             	mov    0x1c(%eax),%ecx
  108354:	8b 55 f8             	mov    -0x8(%ebp),%edx
  108357:	89 d0                	mov    %edx,%eax
  108359:	c1 e0 02             	shl    $0x2,%eax
  10835c:	01 d0                	add    %edx,%eax
  10835e:	c1 e0 02             	shl    $0x2,%eax
  108361:	8d 04 01             	lea    (%ecx,%eax,1),%eax
  108364:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
        new->sems[i].lopid = 0;
  10836b:	8b 45 f4             	mov    -0xc(%ebp),%eax
  10836e:	8b 48 1c             	mov    0x1c(%eax),%ecx
  108371:	8b 55 f8             	mov    -0x8(%ebp),%edx
  108374:	89 d0                	mov    %edx,%eax
  108376:	c1 e0 02             	shl    $0x2,%eax
  108379:	01 d0                	add    %edx,%eax
  10837b:	c1 e0 02             	shl    $0x2,%eax
  10837e:	8d 04 01             	lea    (%ecx,%eax,1),%eax
  108381:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
        new->sems[i].waitn = llist_create();
  108388:	8b 45 f4             	mov    -0xc(%ebp),%eax
  10838b:	8b 48 1c             	mov    0x1c(%eax),%ecx
  10838e:	8b 55 f8             	mov    -0x8(%ebp),%edx
  108391:	89 d0                	mov    %edx,%eax
  108393:	c1 e0 02             	shl    $0x2,%eax
  108396:	01 d0                	add    %edx,%eax
  108398:	c1 e0 02             	shl    $0x2,%eax
  10839b:	8d 1c 01             	lea    (%ecx,%eax,1),%ebx
  10839e:	e8 31 25 00 00       	call   10a8d4 <llist_create>
  1083a3:	89 43 0c             	mov    %eax,0xc(%ebx)
        new->sems[i].waitz = llist_create();
  1083a6:	8b 45 f4             	mov    -0xc(%ebp),%eax
  1083a9:	8b 48 1c             	mov    0x1c(%eax),%ecx
  1083ac:	8b 55 f8             	mov    -0x8(%ebp),%edx
  1083af:	89 d0                	mov    %edx,%eax
  1083b1:	c1 e0 02             	shl    $0x2,%eax
  1083b4:	01 d0                	add    %edx,%eax
  1083b6:	c1 e0 02             	shl    $0x2,%eax
  1083b9:	8d 1c 01             	lea    (%ecx,%eax,1),%ebx
  1083bc:	e8 13 25 00 00       	call   10a8d4 <llist_create>
  1083c1:	89 43 10             	mov    %eax,0x10(%ebx)
      new->ipc.mode = mode;
      new->otime = 0;
      new->ctime = time;
      new->sems = malloc(sizeof(ipc_sem_sem_t)*nsems);
      new->num = nsems;
      for (i=0;i<nsems;i++) {
  1083c4:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
  1083c8:	8b 45 f8             	mov    -0x8(%ebp),%eax
  1083cb:	3b 45 0c             	cmp    0xc(%ebp),%eax
  1083ce:	0f 82 5f ff ff ff    	jb     108333 <ipc_sem_create+0xe9>
        new->sems[i].val = 0;
        new->sems[i].lopid = 0;
        new->sems[i].waitn = llist_create();
        new->sems[i].waitz = llist_create();
      }
      llist_push(ipc_objects,new);
  1083d4:	a1 90 e1 10 00       	mov    0x10e190,%eax
  1083d9:	8b 55 f4             	mov    -0xc(%ebp),%edx
  1083dc:	89 54 24 04          	mov    %edx,0x4(%esp)
  1083e0:	89 04 24             	mov    %eax,(%esp)
  1083e3:	e8 67 25 00 00       	call   10a94f <llist_push>
      return new->ipc.id;
  1083e8:	8b 45 f4             	mov    -0xc(%ebp),%eax
  1083eb:	8b 40 04             	mov    0x4(%eax),%eax
  1083ee:	89 45 e8             	mov    %eax,-0x18(%ebp)
  1083f1:	eb 10                	jmp    108403 <ipc_sem_create+0x1b9>
    }
    else return -ENOSPC;
  1083f3:	c7 45 e8 cc ff ff ff 	movl   $0xffffffcc,-0x18(%ebp)
  1083fa:	eb 07                	jmp    108403 <ipc_sem_create+0x1b9>
  }
  return -EEXIST;
  1083fc:	c7 45 e8 ec ff ff ff 	movl   $0xffffffec,-0x18(%ebp)
  108403:	8b 45 e8             	mov    -0x18(%ebp),%eax
}
  108406:	83 c4 24             	add    $0x24,%esp
  108409:	5b                   	pop    %ebx
  10840a:	5d                   	pop    %ebp
  10840b:	c3                   	ret    

0010840c <ipc_sem_op>:
 *  @param nops Number of Operations
 *  @param time Current time
 *  @return Number of operations progressed
 *  @todo Check for permissions
 */
int ipc_sem_op(id_t id,ipc_sem_op_t *ops,size_t nops,time_t time) {
  10840c:	55                   	push   %ebp
  10840d:	89 e5                	mov    %esp,%ebp
  10840f:	83 ec 38             	sub    $0x38,%esp
  size_t i;
  for (i=0;i<nops;i++) {
  108412:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
  108419:	e9 e5 02 00 00       	jmp    108703 <ipc_sem_op+0x2f7>
    ipc_sem_t *semset = ipc_sem_find(-1,id);
  10841e:	c7 44 24 08 03 00 00 	movl   $0x3,0x8(%esp)
  108425:	00 
  108426:	8b 45 08             	mov    0x8(%ebp),%eax
  108429:	89 44 24 04          	mov    %eax,0x4(%esp)
  10842d:	c7 04 24 ff ff ff ff 	movl   $0xffffffff,(%esp)
  108434:	e8 d2 90 ff ff       	call   10150b <ipc_find>
  108439:	89 45 ec             	mov    %eax,-0x14(%ebp)
    if (semset==NULL) return -EINVAL;
  10843c:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
  108440:	75 0c                	jne    10844e <ipc_sem_op+0x42>
  108442:	c7 45 dc e4 ff ff ff 	movl   $0xffffffe4,-0x24(%ebp)
  108449:	e9 c8 02 00 00       	jmp    108716 <ipc_sem_op+0x30a>
    if (ops[i].num>=semset->num) return -1;
  10844e:	8b 55 e8             	mov    -0x18(%ebp),%edx
  108451:	89 d0                	mov    %edx,%eax
  108453:	01 c0                	add    %eax,%eax
  108455:	01 d0                	add    %edx,%eax
  108457:	01 c0                	add    %eax,%eax
  108459:	03 45 0c             	add    0xc(%ebp),%eax
  10845c:	0f b7 00             	movzwl (%eax),%eax
  10845f:	0f b7 d0             	movzwl %ax,%edx
  108462:	8b 45 ec             	mov    -0x14(%ebp),%eax
  108465:	8b 40 18             	mov    0x18(%eax),%eax
  108468:	39 c2                	cmp    %eax,%edx
  10846a:	72 0c                	jb     108478 <ipc_sem_op+0x6c>
  10846c:	c7 45 dc ff ff ff ff 	movl   $0xffffffff,-0x24(%ebp)
  108473:	e9 9e 02 00 00       	jmp    108716 <ipc_sem_op+0x30a>
    ipc_sem_sem_t *sem = semset->sems+ops[i].num;
  108478:	8b 45 ec             	mov    -0x14(%ebp),%eax
  10847b:	8b 48 1c             	mov    0x1c(%eax),%ecx
  10847e:	8b 55 e8             	mov    -0x18(%ebp),%edx
  108481:	89 d0                	mov    %edx,%eax
  108483:	01 c0                	add    %eax,%eax
  108485:	01 d0                	add    %edx,%eax
  108487:	01 c0                	add    %eax,%eax
  108489:	03 45 0c             	add    0xc(%ebp),%eax
  10848c:	0f b7 00             	movzwl (%eax),%eax
  10848f:	0f b7 d0             	movzwl %ax,%edx
  108492:	89 d0                	mov    %edx,%eax
  108494:	c1 e0 02             	shl    $0x2,%eax
  108497:	01 d0                	add    %edx,%eax
  108499:	c1 e0 02             	shl    $0x2,%eax
  10849c:	8d 04 01             	lea    (%ecx,%eax,1),%eax
  10849f:	89 45 f0             	mov    %eax,-0x10(%ebp)
    sem->lopid = proc_current->pid;
  1084a2:	a1 a0 e1 10 00       	mov    0x10e1a0,%eax
  1084a7:	8b 10                	mov    (%eax),%edx
  1084a9:	8b 45 f0             	mov    -0x10(%ebp),%eax
  1084ac:	89 50 08             	mov    %edx,0x8(%eax)
    semset->otime = time;
  1084af:	8b 55 ec             	mov    -0x14(%ebp),%edx
  1084b2:	8b 45 14             	mov    0x14(%ebp),%eax
  1084b5:	89 42 20             	mov    %eax,0x20(%edx)
    if (ops[i].op<0) {
  1084b8:	8b 55 e8             	mov    -0x18(%ebp),%edx
  1084bb:	89 d0                	mov    %edx,%eax
  1084bd:	01 c0                	add    %eax,%eax
  1084bf:	01 d0                	add    %edx,%eax
  1084c1:	01 c0                	add    %eax,%eax
  1084c3:	03 45 0c             	add    0xc(%ebp),%eax
  1084c6:	0f b7 40 02          	movzwl 0x2(%eax),%eax
  1084ca:	66 85 c0             	test   %ax,%ax
  1084cd:	0f 89 3a 01 00 00    	jns    10860d <ipc_sem_op+0x201>
      if (-ops[i].op<=sem->val) sem->val += ops[i].op;
  1084d3:	8b 55 e8             	mov    -0x18(%ebp),%edx
  1084d6:	89 d0                	mov    %edx,%eax
  1084d8:	01 c0                	add    %eax,%eax
  1084da:	01 d0                	add    %edx,%eax
  1084dc:	01 c0                	add    %eax,%eax
  1084de:	03 45 0c             	add    0xc(%ebp),%eax
  1084e1:	0f b7 40 02          	movzwl 0x2(%eax),%eax
  1084e5:	98                   	cwtl   
  1084e6:	89 c2                	mov    %eax,%edx
  1084e8:	f7 da                	neg    %edx
  1084ea:	8b 45 f0             	mov    -0x10(%ebp),%eax
  1084ed:	8b 40 04             	mov    0x4(%eax),%eax
  1084f0:	39 c2                	cmp    %eax,%edx
  1084f2:	7f 27                	jg     10851b <ipc_sem_op+0x10f>
  1084f4:	8b 45 f0             	mov    -0x10(%ebp),%eax
  1084f7:	8b 48 04             	mov    0x4(%eax),%ecx
  1084fa:	8b 55 e8             	mov    -0x18(%ebp),%edx
  1084fd:	89 d0                	mov    %edx,%eax
  1084ff:	01 c0                	add    %eax,%eax
  108501:	01 d0                	add    %edx,%eax
  108503:	01 c0                	add    %eax,%eax
  108505:	03 45 0c             	add    0xc(%ebp),%eax
  108508:	0f b7 40 02          	movzwl 0x2(%eax),%eax
  10850c:	98                   	cwtl   
  10850d:	8d 14 01             	lea    (%ecx,%eax,1),%edx
  108510:	8b 45 f0             	mov    -0x10(%ebp),%eax
  108513:	89 50 04             	mov    %edx,0x4(%eax)
  108516:	e9 69 01 00 00       	jmp    108684 <ipc_sem_op+0x278>
      else if (-ops[i].op>sem->val && (ops[i].flags&IPC_NOWAIT)) return 0;
  10851b:	8b 55 e8             	mov    -0x18(%ebp),%edx
  10851e:	89 d0                	mov    %edx,%eax
  108520:	01 c0                	add    %eax,%eax
  108522:	01 d0                	add    %edx,%eax
  108524:	01 c0                	add    %eax,%eax
  108526:	03 45 0c             	add    0xc(%ebp),%eax
  108529:	0f b7 40 02          	movzwl 0x2(%eax),%eax
  10852d:	98                   	cwtl   
  10852e:	89 c2                	mov    %eax,%edx
  108530:	f7 da                	neg    %edx
  108532:	8b 45 f0             	mov    -0x10(%ebp),%eax
  108535:	8b 40 04             	mov    0x4(%eax),%eax
  108538:	39 c2                	cmp    %eax,%edx
  10853a:	7e 28                	jle    108564 <ipc_sem_op+0x158>
  10853c:	8b 55 e8             	mov    -0x18(%ebp),%edx
  10853f:	89 d0                	mov    %edx,%eax
  108541:	01 c0                	add    %eax,%eax
  108543:	01 d0                	add    %edx,%eax
  108545:	01 c0                	add    %eax,%eax
  108547:	03 45 0c             	add    0xc(%ebp),%eax
  10854a:	0f b7 40 04          	movzwl 0x4(%eax),%eax
  10854e:	98                   	cwtl   
  10854f:	25 03 02 00 00       	and    $0x203,%eax
  108554:	85 c0                	test   %eax,%eax
  108556:	74 0c                	je     108564 <ipc_sem_op+0x158>
  108558:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
  10855f:	e9 b2 01 00 00       	jmp    108716 <ipc_sem_op+0x30a>
      else if (-ops[i].op>sem->val && !(ops[i].flags&IPC_NOWAIT)) {
  108564:	8b 55 e8             	mov    -0x18(%ebp),%edx
  108567:	89 d0                	mov    %edx,%eax
  108569:	01 c0                	add    %eax,%eax
  10856b:	01 d0                	add    %edx,%eax
  10856d:	01 c0                	add    %eax,%eax
  10856f:	03 45 0c             	add    0xc(%ebp),%eax
  108572:	0f b7 40 02          	movzwl 0x2(%eax),%eax
  108576:	98                   	cwtl   
  108577:	89 c2                	mov    %eax,%edx
  108579:	f7 da                	neg    %edx
  10857b:	8b 45 f0             	mov    -0x10(%ebp),%eax
  10857e:	8b 40 04             	mov    0x4(%eax),%eax
  108581:	39 c2                	cmp    %eax,%edx
  108583:	0f 8e fb 00 00 00    	jle    108684 <ipc_sem_op+0x278>
  108589:	8b 55 e8             	mov    -0x18(%ebp),%edx
  10858c:	89 d0                	mov    %edx,%eax
  10858e:	01 c0                	add    %eax,%eax
  108590:	01 d0                	add    %edx,%eax
  108592:	01 c0                	add    %eax,%eax
  108594:	03 45 0c             	add    0xc(%ebp),%eax
  108597:	0f b7 40 04          	movzwl 0x4(%eax),%eax
  10859b:	98                   	cwtl   
  10859c:	25 03 02 00 00       	and    $0x203,%eax
  1085a1:	85 c0                	test   %eax,%eax
  1085a3:	0f 85 db 00 00 00    	jne    108684 <ipc_sem_op+0x278>
        ipc_sem_sleepn_t *sleepn = malloc(sizeof(ipc_sem_sleepn_t));
  1085a9:	c7 04 24 08 00 00 00 	movl   $0x8,(%esp)
  1085b0:	e8 b4 a9 ff ff       	call   102f69 <malloc>
  1085b5:	89 45 f4             	mov    %eax,-0xc(%ebp)
        sleepn->val = -ops[i].op;
  1085b8:	8b 55 e8             	mov    -0x18(%ebp),%edx
  1085bb:	89 d0                	mov    %edx,%eax
  1085bd:	01 c0                	add    %eax,%eax
  1085bf:	01 d0                	add    %edx,%eax
  1085c1:	01 c0                	add    %eax,%eax
  1085c3:	03 45 0c             	add    0xc(%ebp),%eax
  1085c6:	0f b7 40 02          	movzwl 0x2(%eax),%eax
  1085ca:	98                   	cwtl   
  1085cb:	89 c2                	mov    %eax,%edx
  1085cd:	f7 da                	neg    %edx
  1085cf:	8b 45 f4             	mov    -0xc(%ebp),%eax
  1085d2:	89 10                	mov    %edx,(%eax)
        sleepn->proc = proc_current;
  1085d4:	8b 15 a0 e1 10 00    	mov    0x10e1a0,%edx
  1085da:	8b 45 f4             	mov    -0xc(%ebp),%eax
  1085dd:	89 50 04             	mov    %edx,0x4(%eax)
        llist_push(sem->waitn,sleepn);
  1085e0:	8b 45 f0             	mov    -0x10(%ebp),%eax
  1085e3:	8b 50 0c             	mov    0xc(%eax),%edx
  1085e6:	8b 45 f4             	mov    -0xc(%ebp),%eax
  1085e9:	89 44 24 04          	mov    %eax,0x4(%esp)
  1085ed:	89 14 24             	mov    %edx,(%esp)
  1085f0:	e8 5a 23 00 00       	call   10a94f <llist_push>
        proc_sleep(proc_current);
  1085f5:	a1 a0 e1 10 00       	mov    0x10e1a0,%eax
  1085fa:	89 04 24             	mov    %eax,(%esp)
  1085fd:	e8 1f e0 ff ff       	call   106621 <proc_sleep>
        return i;
  108602:	8b 45 e8             	mov    -0x18(%ebp),%eax
  108605:	89 45 dc             	mov    %eax,-0x24(%ebp)
  108608:	e9 09 01 00 00       	jmp    108716 <ipc_sem_op+0x30a>
      }
    }
    else if (ops[i].op>0) sem->val += ops[i].op;
  10860d:	8b 55 e8             	mov    -0x18(%ebp),%edx
  108610:	89 d0                	mov    %edx,%eax
  108612:	01 c0                	add    %eax,%eax
  108614:	01 d0                	add    %edx,%eax
  108616:	01 c0                	add    %eax,%eax
  108618:	03 45 0c             	add    0xc(%ebp),%eax
  10861b:	0f b7 40 02          	movzwl 0x2(%eax),%eax
  10861f:	66 85 c0             	test   %ax,%ax
  108622:	7e 24                	jle    108648 <ipc_sem_op+0x23c>
  108624:	8b 45 f0             	mov    -0x10(%ebp),%eax
  108627:	8b 48 04             	mov    0x4(%eax),%ecx
  10862a:	8b 55 e8             	mov    -0x18(%ebp),%edx
  10862d:	89 d0                	mov    %edx,%eax
  10862f:	01 c0                	add    %eax,%eax
  108631:	01 d0                	add    %edx,%eax
  108633:	01 c0                	add    %eax,%eax
  108635:	03 45 0c             	add    0xc(%ebp),%eax
  108638:	0f b7 40 02          	movzwl 0x2(%eax),%eax
  10863c:	98                   	cwtl   
  10863d:	8d 14 01             	lea    (%ecx,%eax,1),%edx
  108640:	8b 45 f0             	mov    -0x10(%ebp),%eax
  108643:	89 50 04             	mov    %edx,0x4(%eax)
  108646:	eb 3c                	jmp    108684 <ipc_sem_op+0x278>
    else if (ops[i].op==0) {
  108648:	8b 55 e8             	mov    -0x18(%ebp),%edx
  10864b:	89 d0                	mov    %edx,%eax
  10864d:	01 c0                	add    %eax,%eax
  10864f:	01 d0                	add    %edx,%eax
  108651:	01 c0                	add    %eax,%eax
  108653:	03 45 0c             	add    0xc(%ebp),%eax
  108656:	0f b7 40 02          	movzwl 0x2(%eax),%eax
  10865a:	66 85 c0             	test   %ax,%ax
  10865d:	75 25                	jne    108684 <ipc_sem_op+0x278>
      llist_push(sem->waitz,proc_current);
  10865f:	8b 15 a0 e1 10 00    	mov    0x10e1a0,%edx
  108665:	8b 45 f0             	mov    -0x10(%ebp),%eax
  108668:	8b 40 10             	mov    0x10(%eax),%eax
  10866b:	89 54 24 04          	mov    %edx,0x4(%esp)
  10866f:	89 04 24             	mov    %eax,(%esp)
  108672:	e8 d8 22 00 00       	call   10a94f <llist_push>
      proc_sleep(proc_current);
  108677:	a1 a0 e1 10 00       	mov    0x10e1a0,%eax
  10867c:	89 04 24             	mov    %eax,(%esp)
  10867f:	e8 9d df ff ff       	call   106621 <proc_sleep>
    }
    if (sem->val==0) {
  108684:	8b 45 f0             	mov    -0x10(%ebp),%eax
  108687:	8b 40 04             	mov    0x4(%eax),%eax
  10868a:	85 c0                	test   %eax,%eax
  10868c:	75 26                	jne    1086b4 <ipc_sem_op+0x2a8>
  10868e:	eb 0b                	jmp    10869b <ipc_sem_op+0x28f>
      proc_t *proc;
      while ((proc = llist_pop(sem->waitz))) proc_wake(proc);
  108690:	8b 45 f8             	mov    -0x8(%ebp),%eax
  108693:	89 04 24             	mov    %eax,(%esp)
  108696:	e8 f2 df ff ff       	call   10668d <proc_wake>
  10869b:	8b 45 f0             	mov    -0x10(%ebp),%eax
  10869e:	8b 40 10             	mov    0x10(%eax),%eax
  1086a1:	89 04 24             	mov    %eax,(%esp)
  1086a4:	e8 ff 22 00 00       	call   10a9a8 <llist_pop>
  1086a9:	89 45 f8             	mov    %eax,-0x8(%ebp)
  1086ac:	83 7d f8 00          	cmpl   $0x0,-0x8(%ebp)
  1086b0:	75 de                	jne    108690 <ipc_sem_op+0x284>
  1086b2:	eb 4b                	jmp    1086ff <ipc_sem_op+0x2f3>
    }
    else if (sem->val>0) {
  1086b4:	8b 45 f0             	mov    -0x10(%ebp),%eax
  1086b7:	8b 40 04             	mov    0x4(%eax),%eax
  1086ba:	85 c0                	test   %eax,%eax
  1086bc:	7e 41                	jle    1086ff <ipc_sem_op+0x2f3>
  1086be:	eb 28                	jmp    1086e8 <ipc_sem_op+0x2dc>
      ipc_sem_sleepn_t *sleepn;
      while ((sleepn = llist_pop(sem->waitn))) {
        if (sleepn->val<sem->val) {
  1086c0:	8b 45 fc             	mov    -0x4(%ebp),%eax
  1086c3:	8b 10                	mov    (%eax),%edx
  1086c5:	8b 45 f0             	mov    -0x10(%ebp),%eax
  1086c8:	8b 40 04             	mov    0x4(%eax),%eax
  1086cb:	39 c2                	cmp    %eax,%edx
  1086cd:	7d 19                	jge    1086e8 <ipc_sem_op+0x2dc>
          free(sleepn);
  1086cf:	8b 45 fc             	mov    -0x4(%ebp),%eax
  1086d2:	89 04 24             	mov    %eax,(%esp)
  1086d5:	e8 c3 a8 ff ff       	call   102f9d <free>
          proc_wake(sleepn->proc);
  1086da:	8b 45 fc             	mov    -0x4(%ebp),%eax
  1086dd:	8b 40 04             	mov    0x4(%eax),%eax
  1086e0:	89 04 24             	mov    %eax,(%esp)
  1086e3:	e8 a5 df ff ff       	call   10668d <proc_wake>
      proc_t *proc;
      while ((proc = llist_pop(sem->waitz))) proc_wake(proc);
    }
    else if (sem->val>0) {
      ipc_sem_sleepn_t *sleepn;
      while ((sleepn = llist_pop(sem->waitn))) {
  1086e8:	8b 45 f0             	mov    -0x10(%ebp),%eax
  1086eb:	8b 40 0c             	mov    0xc(%eax),%eax
  1086ee:	89 04 24             	mov    %eax,(%esp)
  1086f1:	e8 b2 22 00 00       	call   10a9a8 <llist_pop>
  1086f6:	89 45 fc             	mov    %eax,-0x4(%ebp)
  1086f9:	83 7d fc 00          	cmpl   $0x0,-0x4(%ebp)
  1086fd:	75 c1                	jne    1086c0 <ipc_sem_op+0x2b4>
 *  @return Number of operations progressed
 *  @todo Check for permissions
 */
int ipc_sem_op(id_t id,ipc_sem_op_t *ops,size_t nops,time_t time) {
  size_t i;
  for (i=0;i<nops;i++) {
  1086ff:	83 45 e8 01          	addl   $0x1,-0x18(%ebp)
  108703:	8b 45 e8             	mov    -0x18(%ebp),%eax
  108706:	3b 45 10             	cmp    0x10(%ebp),%eax
  108709:	0f 82 0f fd ff ff    	jb     10841e <ipc_sem_op+0x12>
          proc_wake(sleepn->proc);
        }
      }
    }
  }
  return 0;
  10870f:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
  108716:	8b 45 dc             	mov    -0x24(%ebp),%eax
}
  108719:	c9                   	leave  
  10871a:	c3                   	ret    

0010871b <ipc_sem_getval>:

int ipc_sem_getval(id_t id,size_t num) {
  10871b:	55                   	push   %ebp
  10871c:	89 e5                	mov    %esp,%ebp
  10871e:	56                   	push   %esi
  10871f:	53                   	push   %ebx
  108720:	83 ec 30             	sub    $0x30,%esp
  ipc_sem_t *semset = ipc_sem_find(-1,id);
  108723:	c7 44 24 08 03 00 00 	movl   $0x3,0x8(%esp)
  10872a:	00 
  10872b:	8b 45 08             	mov    0x8(%ebp),%eax
  10872e:	89 44 24 04          	mov    %eax,0x4(%esp)
  108732:	c7 04 24 ff ff ff ff 	movl   $0xffffffff,(%esp)
  108739:	e8 cd 8d ff ff       	call   10150b <ipc_find>
  10873e:	89 45 f4             	mov    %eax,-0xc(%ebp)
  if (semset!=NULL && num<semset->num) {
  108741:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
  108745:	0f 84 96 00 00 00    	je     1087e1 <ipc_sem_getval+0xc6>
  10874b:	8b 45 f4             	mov    -0xc(%ebp),%eax
  10874e:	8b 40 18             	mov    0x18(%eax),%eax
  108751:	3b 45 0c             	cmp    0xc(%ebp),%eax
  108754:	0f 86 87 00 00 00    	jbe    1087e1 <ipc_sem_getval+0xc6>
    if (ipc_sem_permcheck(semset,PERM_R)) return semset->sems[num].val;
  10875a:	8b 45 f4             	mov    -0xc(%ebp),%eax
  10875d:	8b 58 14             	mov    0x14(%eax),%ebx
  108760:	a1 a0 e1 10 00       	mov    0x10e1a0,%eax
  108765:	8b 70 10             	mov    0x10(%eax),%esi
  108768:	a1 a0 e1 10 00       	mov    0x10e1a0,%eax
  10876d:	8b 50 04             	mov    0x4(%eax),%edx
  108770:	8b 45 f4             	mov    -0xc(%ebp),%eax
  108773:	8b 40 0c             	mov    0xc(%eax),%eax
  108776:	8b 48 10             	mov    0x10(%eax),%ecx
  108779:	8b 45 f4             	mov    -0xc(%ebp),%eax
  10877c:	8b 40 0c             	mov    0xc(%eax),%eax
  10877f:	8b 00                	mov    (%eax),%eax
  108781:	c7 44 24 14 01 00 00 	movl   $0x1,0x14(%esp)
  108788:	00 
  108789:	89 5c 24 10          	mov    %ebx,0x10(%esp)
  10878d:	89 74 24 0c          	mov    %esi,0xc(%esp)
  108791:	89 54 24 08          	mov    %edx,0x8(%esp)
  108795:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  108799:	89 04 24             	mov    %eax,(%esp)
  10879c:	e8 93 26 00 00       	call   10ae34 <perm_check>
  1087a1:	85 c0                	test   %eax,%eax
  1087a3:	75 15                	jne    1087ba <ipc_sem_getval+0x9f>
  1087a5:	a1 a0 e1 10 00       	mov    0x10e1a0,%eax
  1087aa:	8b 50 04             	mov    0x4(%eax),%edx
  1087ad:	8b 45 f4             	mov    -0xc(%ebp),%eax
  1087b0:	8b 40 10             	mov    0x10(%eax),%eax
  1087b3:	8b 40 04             	mov    0x4(%eax),%eax
  1087b6:	39 c2                	cmp    %eax,%edx
  1087b8:	75 1e                	jne    1087d8 <ipc_sem_getval+0xbd>
  1087ba:	8b 45 f4             	mov    -0xc(%ebp),%eax
  1087bd:	8b 48 1c             	mov    0x1c(%eax),%ecx
  1087c0:	8b 55 0c             	mov    0xc(%ebp),%edx
  1087c3:	89 d0                	mov    %edx,%eax
  1087c5:	c1 e0 02             	shl    $0x2,%eax
  1087c8:	01 d0                	add    %edx,%eax
  1087ca:	c1 e0 02             	shl    $0x2,%eax
  1087cd:	8d 04 01             	lea    (%ecx,%eax,1),%eax
  1087d0:	8b 40 04             	mov    0x4(%eax),%eax
  1087d3:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  1087d6:	eb 10                	jmp    1087e8 <ipc_sem_getval+0xcd>
    else return -EACCES;
  1087d8:	c7 45 e4 fe ff ff ff 	movl   $0xfffffffe,-0x1c(%ebp)
  1087df:	eb 07                	jmp    1087e8 <ipc_sem_getval+0xcd>
  }
  return -EINVAL;
  1087e1:	c7 45 e4 e4 ff ff ff 	movl   $0xffffffe4,-0x1c(%ebp)
  1087e8:	8b 45 e4             	mov    -0x1c(%ebp),%eax
}
  1087eb:	83 c4 30             	add    $0x30,%esp
  1087ee:	5b                   	pop    %ebx
  1087ef:	5e                   	pop    %esi
  1087f0:	5d                   	pop    %ebp
  1087f1:	c3                   	ret    

001087f2 <ipc_sem_setval>:

int ipc_sem_setval(id_t id,size_t num,int val,time_t time) {
  1087f2:	55                   	push   %ebp
  1087f3:	89 e5                	mov    %esp,%ebp
  1087f5:	56                   	push   %esi
  1087f6:	53                   	push   %ebx
  1087f7:	83 ec 30             	sub    $0x30,%esp
  ipc_sem_t *semset = ipc_sem_find(-1,id);
  1087fa:	c7 44 24 08 03 00 00 	movl   $0x3,0x8(%esp)
  108801:	00 
  108802:	8b 45 08             	mov    0x8(%ebp),%eax
  108805:	89 44 24 04          	mov    %eax,0x4(%esp)
  108809:	c7 04 24 ff ff ff ff 	movl   $0xffffffff,(%esp)
  108810:	e8 f6 8c ff ff       	call   10150b <ipc_find>
  108815:	89 45 f4             	mov    %eax,-0xc(%ebp)
  if (semset!=NULL && num<semset->num) {
  108818:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
  10881c:	0f 84 d6 00 00 00    	je     1088f8 <ipc_sem_setval+0x106>
  108822:	8b 45 f4             	mov    -0xc(%ebp),%eax
  108825:	8b 40 18             	mov    0x18(%eax),%eax
  108828:	3b 45 0c             	cmp    0xc(%ebp),%eax
  10882b:	0f 86 c7 00 00 00    	jbe    1088f8 <ipc_sem_setval+0x106>
    if (ipc_sem_permcheck(semset,PERM_W)) {
  108831:	8b 45 f4             	mov    -0xc(%ebp),%eax
  108834:	8b 58 14             	mov    0x14(%eax),%ebx
  108837:	a1 a0 e1 10 00       	mov    0x10e1a0,%eax
  10883c:	8b 70 10             	mov    0x10(%eax),%esi
  10883f:	a1 a0 e1 10 00       	mov    0x10e1a0,%eax
  108844:	8b 50 04             	mov    0x4(%eax),%edx
  108847:	8b 45 f4             	mov    -0xc(%ebp),%eax
  10884a:	8b 40 0c             	mov    0xc(%eax),%eax
  10884d:	8b 48 10             	mov    0x10(%eax),%ecx
  108850:	8b 45 f4             	mov    -0xc(%ebp),%eax
  108853:	8b 40 0c             	mov    0xc(%eax),%eax
  108856:	8b 00                	mov    (%eax),%eax
  108858:	c7 44 24 14 02 00 00 	movl   $0x2,0x14(%esp)
  10885f:	00 
  108860:	89 5c 24 10          	mov    %ebx,0x10(%esp)
  108864:	89 74 24 0c          	mov    %esi,0xc(%esp)
  108868:	89 54 24 08          	mov    %edx,0x8(%esp)
  10886c:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  108870:	89 04 24             	mov    %eax,(%esp)
  108873:	e8 bc 25 00 00       	call   10ae34 <perm_check>
  108878:	85 c0                	test   %eax,%eax
  10887a:	75 15                	jne    108891 <ipc_sem_setval+0x9f>
  10887c:	a1 a0 e1 10 00       	mov    0x10e1a0,%eax
  108881:	8b 50 04             	mov    0x4(%eax),%edx
  108884:	8b 45 f4             	mov    -0xc(%ebp),%eax
  108887:	8b 40 10             	mov    0x10(%eax),%eax
  10888a:	8b 40 04             	mov    0x4(%eax),%eax
  10888d:	39 c2                	cmp    %eax,%edx
  10888f:	75 5e                	jne    1088ef <ipc_sem_setval+0xfd>
      semset->sems[num].val = val;
  108891:	8b 45 f4             	mov    -0xc(%ebp),%eax
  108894:	8b 48 1c             	mov    0x1c(%eax),%ecx
  108897:	8b 55 0c             	mov    0xc(%ebp),%edx
  10889a:	89 d0                	mov    %edx,%eax
  10889c:	c1 e0 02             	shl    $0x2,%eax
  10889f:	01 d0                	add    %edx,%eax
  1088a1:	c1 e0 02             	shl    $0x2,%eax
  1088a4:	8d 14 01             	lea    (%ecx,%eax,1),%edx
  1088a7:	8b 45 10             	mov    0x10(%ebp),%eax
  1088aa:	89 42 04             	mov    %eax,0x4(%edx)
      kprintf("<%d|%d>\n",num,semset->sems[num].val);
  1088ad:	8b 45 f4             	mov    -0xc(%ebp),%eax
  1088b0:	8b 48 1c             	mov    0x1c(%eax),%ecx
  1088b3:	8b 55 0c             	mov    0xc(%ebp),%edx
  1088b6:	89 d0                	mov    %edx,%eax
  1088b8:	c1 e0 02             	shl    $0x2,%eax
  1088bb:	01 d0                	add    %edx,%eax
  1088bd:	c1 e0 02             	shl    $0x2,%eax
  1088c0:	8d 04 01             	lea    (%ecx,%eax,1),%eax
  1088c3:	8b 40 04             	mov    0x4(%eax),%eax
  1088c6:	89 44 24 08          	mov    %eax,0x8(%esp)
  1088ca:	8b 45 0c             	mov    0xc(%ebp),%eax
  1088cd:	89 44 24 04          	mov    %eax,0x4(%esp)
  1088d1:	c7 04 24 ae d6 10 00 	movl   $0x10d6ae,(%esp)
  1088d8:	e8 be 9a ff ff       	call   10239b <kprintf>
      semset->ctime = time;
  1088dd:	8b 55 f4             	mov    -0xc(%ebp),%edx
  1088e0:	8b 45 14             	mov    0x14(%ebp),%eax
  1088e3:	89 42 24             	mov    %eax,0x24(%edx)
      return 0;
  1088e6:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
  1088ed:	eb 10                	jmp    1088ff <ipc_sem_setval+0x10d>
    }
    else return -EACCES;
  1088ef:	c7 45 e4 fe ff ff ff 	movl   $0xfffffffe,-0x1c(%ebp)
  1088f6:	eb 07                	jmp    1088ff <ipc_sem_setval+0x10d>
  }
  return -EINVAL;
  1088f8:	c7 45 e4 e4 ff ff ff 	movl   $0xffffffe4,-0x1c(%ebp)
  1088ff:	8b 45 e4             	mov    -0x1c(%ebp),%eax
}
  108902:	83 c4 30             	add    $0x30,%esp
  108905:	5b                   	pop    %ebx
  108906:	5e                   	pop    %esi
  108907:	5d                   	pop    %ebp
  108908:	c3                   	ret    

00108909 <ipc_sem_getpid>:

pid_t ipc_sem_getpid(id_t id,size_t num) {
  108909:	55                   	push   %ebp
  10890a:	89 e5                	mov    %esp,%ebp
  10890c:	56                   	push   %esi
  10890d:	53                   	push   %ebx
  10890e:	83 ec 30             	sub    $0x30,%esp
  ipc_sem_t *semset = ipc_sem_find(-1,id);
  108911:	c7 44 24 08 03 00 00 	movl   $0x3,0x8(%esp)
  108918:	00 
  108919:	8b 45 08             	mov    0x8(%ebp),%eax
  10891c:	89 44 24 04          	mov    %eax,0x4(%esp)
  108920:	c7 04 24 ff ff ff ff 	movl   $0xffffffff,(%esp)
  108927:	e8 df 8b ff ff       	call   10150b <ipc_find>
  10892c:	89 45 f4             	mov    %eax,-0xc(%ebp)
  if (semset!=NULL && num<semset->num) {
  10892f:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
  108933:	0f 84 96 00 00 00    	je     1089cf <ipc_sem_getpid+0xc6>
  108939:	8b 45 f4             	mov    -0xc(%ebp),%eax
  10893c:	8b 40 18             	mov    0x18(%eax),%eax
  10893f:	3b 45 0c             	cmp    0xc(%ebp),%eax
  108942:	0f 86 87 00 00 00    	jbe    1089cf <ipc_sem_getpid+0xc6>
    if (ipc_sem_permcheck(semset,PERM_R)) return semset->sems[num].lopid;
  108948:	8b 45 f4             	mov    -0xc(%ebp),%eax
  10894b:	8b 58 14             	mov    0x14(%eax),%ebx
  10894e:	a1 a0 e1 10 00       	mov    0x10e1a0,%eax
  108953:	8b 70 10             	mov    0x10(%eax),%esi
  108956:	a1 a0 e1 10 00       	mov    0x10e1a0,%eax
  10895b:	8b 50 04             	mov    0x4(%eax),%edx
  10895e:	8b 45 f4             	mov    -0xc(%ebp),%eax
  108961:	8b 40 0c             	mov    0xc(%eax),%eax
  108964:	8b 48 10             	mov    0x10(%eax),%ecx
  108967:	8b 45 f4             	mov    -0xc(%ebp),%eax
  10896a:	8b 40 0c             	mov    0xc(%eax),%eax
  10896d:	8b 00                	mov    (%eax),%eax
  10896f:	c7 44 24 14 01 00 00 	movl   $0x1,0x14(%esp)
  108976:	00 
  108977:	89 5c 24 10          	mov    %ebx,0x10(%esp)
  10897b:	89 74 24 0c          	mov    %esi,0xc(%esp)
  10897f:	89 54 24 08          	mov    %edx,0x8(%esp)
  108983:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  108987:	89 04 24             	mov    %eax,(%esp)
  10898a:	e8 a5 24 00 00       	call   10ae34 <perm_check>
  10898f:	85 c0                	test   %eax,%eax
  108991:	75 15                	jne    1089a8 <ipc_sem_getpid+0x9f>
  108993:	a1 a0 e1 10 00       	mov    0x10e1a0,%eax
  108998:	8b 50 04             	mov    0x4(%eax),%edx
  10899b:	8b 45 f4             	mov    -0xc(%ebp),%eax
  10899e:	8b 40 10             	mov    0x10(%eax),%eax
  1089a1:	8b 40 04             	mov    0x4(%eax),%eax
  1089a4:	39 c2                	cmp    %eax,%edx
  1089a6:	75 1e                	jne    1089c6 <ipc_sem_getpid+0xbd>
  1089a8:	8b 45 f4             	mov    -0xc(%ebp),%eax
  1089ab:	8b 48 1c             	mov    0x1c(%eax),%ecx
  1089ae:	8b 55 0c             	mov    0xc(%ebp),%edx
  1089b1:	89 d0                	mov    %edx,%eax
  1089b3:	c1 e0 02             	shl    $0x2,%eax
  1089b6:	01 d0                	add    %edx,%eax
  1089b8:	c1 e0 02             	shl    $0x2,%eax
  1089bb:	8d 04 01             	lea    (%ecx,%eax,1),%eax
  1089be:	8b 40 08             	mov    0x8(%eax),%eax
  1089c1:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  1089c4:	eb 10                	jmp    1089d6 <ipc_sem_getpid+0xcd>
    else return -EACCES;
  1089c6:	c7 45 e4 fe ff ff ff 	movl   $0xfffffffe,-0x1c(%ebp)
  1089cd:	eb 07                	jmp    1089d6 <ipc_sem_getpid+0xcd>
  }
  return -EINVAL;
  1089cf:	c7 45 e4 e4 ff ff ff 	movl   $0xffffffe4,-0x1c(%ebp)
  1089d6:	8b 45 e4             	mov    -0x1c(%ebp),%eax
}
  1089d9:	83 c4 30             	add    $0x30,%esp
  1089dc:	5b                   	pop    %ebx
  1089dd:	5e                   	pop    %esi
  1089de:	5d                   	pop    %ebp
  1089df:	c3                   	ret    

001089e0 <ipc_sem_getcnt>:

size_t ipc_sem_getcnt(id_t id,size_t num,int type) {
  1089e0:	55                   	push   %ebp
  1089e1:	89 e5                	mov    %esp,%ebp
  1089e3:	56                   	push   %esi
  1089e4:	53                   	push   %ebx
  1089e5:	83 ec 30             	sub    $0x30,%esp
  ipc_sem_t *semset = ipc_sem_find(-1,id);
  1089e8:	c7 44 24 08 03 00 00 	movl   $0x3,0x8(%esp)
  1089ef:	00 
  1089f0:	8b 45 08             	mov    0x8(%ebp),%eax
  1089f3:	89 44 24 04          	mov    %eax,0x4(%esp)
  1089f7:	c7 04 24 ff ff ff ff 	movl   $0xffffffff,(%esp)
  1089fe:	e8 08 8b ff ff       	call   10150b <ipc_find>
  108a03:	89 45 f4             	mov    %eax,-0xc(%ebp)
  if (semset!=NULL && num<semset->num) {
  108a06:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
  108a0a:	0f 84 c8 00 00 00    	je     108ad8 <ipc_sem_getcnt+0xf8>
  108a10:	8b 45 f4             	mov    -0xc(%ebp),%eax
  108a13:	8b 40 18             	mov    0x18(%eax),%eax
  108a16:	3b 45 0c             	cmp    0xc(%ebp),%eax
  108a19:	0f 86 b9 00 00 00    	jbe    108ad8 <ipc_sem_getcnt+0xf8>
    if (ipc_sem_permcheck(semset,PERM_R)) return llist_size(type=='z'?semset->sems[num].waitz:semset->sems[num].waitn);
  108a1f:	8b 45 f4             	mov    -0xc(%ebp),%eax
  108a22:	8b 58 14             	mov    0x14(%eax),%ebx
  108a25:	a1 a0 e1 10 00       	mov    0x10e1a0,%eax
  108a2a:	8b 70 10             	mov    0x10(%eax),%esi
  108a2d:	a1 a0 e1 10 00       	mov    0x10e1a0,%eax
  108a32:	8b 50 04             	mov    0x4(%eax),%edx
  108a35:	8b 45 f4             	mov    -0xc(%ebp),%eax
  108a38:	8b 40 0c             	mov    0xc(%eax),%eax
  108a3b:	8b 48 10             	mov    0x10(%eax),%ecx
  108a3e:	8b 45 f4             	mov    -0xc(%ebp),%eax
  108a41:	8b 40 0c             	mov    0xc(%eax),%eax
  108a44:	8b 00                	mov    (%eax),%eax
  108a46:	c7 44 24 14 01 00 00 	movl   $0x1,0x14(%esp)
  108a4d:	00 
  108a4e:	89 5c 24 10          	mov    %ebx,0x10(%esp)
  108a52:	89 74 24 0c          	mov    %esi,0xc(%esp)
  108a56:	89 54 24 08          	mov    %edx,0x8(%esp)
  108a5a:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  108a5e:	89 04 24             	mov    %eax,(%esp)
  108a61:	e8 ce 23 00 00       	call   10ae34 <perm_check>
  108a66:	85 c0                	test   %eax,%eax
  108a68:	75 15                	jne    108a7f <ipc_sem_getcnt+0x9f>
  108a6a:	a1 a0 e1 10 00       	mov    0x10e1a0,%eax
  108a6f:	8b 50 04             	mov    0x4(%eax),%edx
  108a72:	8b 45 f4             	mov    -0xc(%ebp),%eax
  108a75:	8b 40 10             	mov    0x10(%eax),%eax
  108a78:	8b 40 04             	mov    0x4(%eax),%eax
  108a7b:	39 c2                	cmp    %eax,%edx
  108a7d:	75 50                	jne    108acf <ipc_sem_getcnt+0xef>
  108a7f:	83 7d 10 7a          	cmpl   $0x7a,0x10(%ebp)
  108a83:	75 1e                	jne    108aa3 <ipc_sem_getcnt+0xc3>
  108a85:	8b 45 f4             	mov    -0xc(%ebp),%eax
  108a88:	8b 48 1c             	mov    0x1c(%eax),%ecx
  108a8b:	8b 55 0c             	mov    0xc(%ebp),%edx
  108a8e:	89 d0                	mov    %edx,%eax
  108a90:	c1 e0 02             	shl    $0x2,%eax
  108a93:	01 d0                	add    %edx,%eax
  108a95:	c1 e0 02             	shl    $0x2,%eax
  108a98:	8d 04 01             	lea    (%ecx,%eax,1),%eax
  108a9b:	8b 40 10             	mov    0x10(%eax),%eax
  108a9e:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  108aa1:	eb 1c                	jmp    108abf <ipc_sem_getcnt+0xdf>
  108aa3:	8b 45 f4             	mov    -0xc(%ebp),%eax
  108aa6:	8b 48 1c             	mov    0x1c(%eax),%ecx
  108aa9:	8b 55 0c             	mov    0xc(%ebp),%edx
  108aac:	89 d0                	mov    %edx,%eax
  108aae:	c1 e0 02             	shl    $0x2,%eax
  108ab1:	01 d0                	add    %edx,%eax
  108ab3:	c1 e0 02             	shl    $0x2,%eax
  108ab6:	8d 04 01             	lea    (%ecx,%eax,1),%eax
  108ab9:	8b 40 0c             	mov    0xc(%eax),%eax
  108abc:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  108abf:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  108ac2:	89 04 24             	mov    %eax,(%esp)
  108ac5:	e8 59 1e 00 00       	call   10a923 <llist_size>
  108aca:	89 45 e0             	mov    %eax,-0x20(%ebp)
  108acd:	eb 10                	jmp    108adf <ipc_sem_getcnt+0xff>
    else return -EACCES;
  108acf:	c7 45 e0 fe ff ff ff 	movl   $0xfffffffe,-0x20(%ebp)
  108ad6:	eb 07                	jmp    108adf <ipc_sem_getcnt+0xff>
  }
  return -EINVAL;
  108ad8:	c7 45 e0 e4 ff ff ff 	movl   $0xffffffe4,-0x20(%ebp)
  108adf:	8b 45 e0             	mov    -0x20(%ebp),%eax
}
  108ae2:	83 c4 30             	add    $0x30,%esp
  108ae5:	5b                   	pop    %ebx
  108ae6:	5e                   	pop    %esi
  108ae7:	5d                   	pop    %ebp
  108ae8:	c3                   	ret    

00108ae9 <ipc_sem_getall>:

int ipc_sem_getall(id_t id,short *buf) {
  108ae9:	55                   	push   %ebp
  108aea:	89 e5                	mov    %esp,%ebp
  108aec:	56                   	push   %esi
  108aed:	53                   	push   %ebx
  108aee:	83 ec 30             	sub    $0x30,%esp
  ipc_sem_t *semset = ipc_sem_find(-1,id);
  108af1:	c7 44 24 08 03 00 00 	movl   $0x3,0x8(%esp)
  108af8:	00 
  108af9:	8b 45 08             	mov    0x8(%ebp),%eax
  108afc:	89 44 24 04          	mov    %eax,0x4(%esp)
  108b00:	c7 04 24 ff ff ff ff 	movl   $0xffffffff,(%esp)
  108b07:	e8 ff 89 ff ff       	call   10150b <ipc_find>
  108b0c:	89 45 f0             	mov    %eax,-0x10(%ebp)
  if (semset!=NULL) {
  108b0f:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
  108b13:	0f 84 b0 00 00 00    	je     108bc9 <ipc_sem_getall+0xe0>
    if (ipc_sem_permcheck(semset,PERM_R)) {
  108b19:	8b 45 f0             	mov    -0x10(%ebp),%eax
  108b1c:	8b 58 14             	mov    0x14(%eax),%ebx
  108b1f:	a1 a0 e1 10 00       	mov    0x10e1a0,%eax
  108b24:	8b 70 10             	mov    0x10(%eax),%esi
  108b27:	a1 a0 e1 10 00       	mov    0x10e1a0,%eax
  108b2c:	8b 50 04             	mov    0x4(%eax),%edx
  108b2f:	8b 45 f0             	mov    -0x10(%ebp),%eax
  108b32:	8b 40 0c             	mov    0xc(%eax),%eax
  108b35:	8b 48 10             	mov    0x10(%eax),%ecx
  108b38:	8b 45 f0             	mov    -0x10(%ebp),%eax
  108b3b:	8b 40 0c             	mov    0xc(%eax),%eax
  108b3e:	8b 00                	mov    (%eax),%eax
  108b40:	c7 44 24 14 01 00 00 	movl   $0x1,0x14(%esp)
  108b47:	00 
  108b48:	89 5c 24 10          	mov    %ebx,0x10(%esp)
  108b4c:	89 74 24 0c          	mov    %esi,0xc(%esp)
  108b50:	89 54 24 08          	mov    %edx,0x8(%esp)
  108b54:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  108b58:	89 04 24             	mov    %eax,(%esp)
  108b5b:	e8 d4 22 00 00       	call   10ae34 <perm_check>
  108b60:	85 c0                	test   %eax,%eax
  108b62:	75 15                	jne    108b79 <ipc_sem_getall+0x90>
  108b64:	a1 a0 e1 10 00       	mov    0x10e1a0,%eax
  108b69:	8b 50 04             	mov    0x4(%eax),%edx
  108b6c:	8b 45 f0             	mov    -0x10(%ebp),%eax
  108b6f:	8b 40 10             	mov    0x10(%eax),%eax
  108b72:	8b 40 04             	mov    0x4(%eax),%eax
  108b75:	39 c2                	cmp    %eax,%edx
  108b77:	75 47                	jne    108bc0 <ipc_sem_getall+0xd7>
      size_t i;
      for (i=0;i<semset->num;i++) buf[i] = semset->sems[i].val;
  108b79:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  108b80:	eb 2a                	jmp    108bac <ipc_sem_getall+0xc3>
  108b82:	8b 45 f4             	mov    -0xc(%ebp),%eax
  108b85:	01 c0                	add    %eax,%eax
  108b87:	89 c3                	mov    %eax,%ebx
  108b89:	03 5d 0c             	add    0xc(%ebp),%ebx
  108b8c:	8b 45 f0             	mov    -0x10(%ebp),%eax
  108b8f:	8b 48 1c             	mov    0x1c(%eax),%ecx
  108b92:	8b 55 f4             	mov    -0xc(%ebp),%edx
  108b95:	89 d0                	mov    %edx,%eax
  108b97:	c1 e0 02             	shl    $0x2,%eax
  108b9a:	01 d0                	add    %edx,%eax
  108b9c:	c1 e0 02             	shl    $0x2,%eax
  108b9f:	8d 04 01             	lea    (%ecx,%eax,1),%eax
  108ba2:	8b 40 04             	mov    0x4(%eax),%eax
  108ba5:	66 89 03             	mov    %ax,(%ebx)
  108ba8:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
  108bac:	8b 45 f0             	mov    -0x10(%ebp),%eax
  108baf:	8b 40 18             	mov    0x18(%eax),%eax
  108bb2:	3b 45 f4             	cmp    -0xc(%ebp),%eax
  108bb5:	77 cb                	ja     108b82 <ipc_sem_getall+0x99>
      return 0;
  108bb7:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
  108bbe:	eb 10                	jmp    108bd0 <ipc_sem_getall+0xe7>
    }
    else return -EACCES;
  108bc0:	c7 45 e4 fe ff ff ff 	movl   $0xfffffffe,-0x1c(%ebp)
  108bc7:	eb 07                	jmp    108bd0 <ipc_sem_getall+0xe7>
  }
  return -EINVAL;
  108bc9:	c7 45 e4 e4 ff ff ff 	movl   $0xffffffe4,-0x1c(%ebp)
  108bd0:	8b 45 e4             	mov    -0x1c(%ebp),%eax
}
  108bd3:	83 c4 30             	add    $0x30,%esp
  108bd6:	5b                   	pop    %ebx
  108bd7:	5e                   	pop    %esi
  108bd8:	5d                   	pop    %ebp
  108bd9:	c3                   	ret    

00108bda <ipc_sem_setall>:

int ipc_sem_setall(id_t id,short *buf,time_t time) {
  108bda:	55                   	push   %ebp
  108bdb:	89 e5                	mov    %esp,%ebp
  108bdd:	56                   	push   %esi
  108bde:	53                   	push   %ebx
  108bdf:	83 ec 30             	sub    $0x30,%esp
  ipc_sem_t *semset = ipc_sem_find(-1,id);
  108be2:	c7 44 24 08 03 00 00 	movl   $0x3,0x8(%esp)
  108be9:	00 
  108bea:	8b 45 08             	mov    0x8(%ebp),%eax
  108bed:	89 44 24 04          	mov    %eax,0x4(%esp)
  108bf1:	c7 04 24 ff ff ff ff 	movl   $0xffffffff,(%esp)
  108bf8:	e8 0e 89 ff ff       	call   10150b <ipc_find>
  108bfd:	89 45 f0             	mov    %eax,-0x10(%ebp)
  if (semset!=NULL) {
  108c00:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
  108c04:	0f 84 b8 00 00 00    	je     108cc2 <ipc_sem_setall+0xe8>
    if (ipc_sem_permcheck(semset,PERM_W)) {
  108c0a:	8b 45 f0             	mov    -0x10(%ebp),%eax
  108c0d:	8b 58 14             	mov    0x14(%eax),%ebx
  108c10:	a1 a0 e1 10 00       	mov    0x10e1a0,%eax
  108c15:	8b 70 10             	mov    0x10(%eax),%esi
  108c18:	a1 a0 e1 10 00       	mov    0x10e1a0,%eax
  108c1d:	8b 50 04             	mov    0x4(%eax),%edx
  108c20:	8b 45 f0             	mov    -0x10(%ebp),%eax
  108c23:	8b 40 0c             	mov    0xc(%eax),%eax
  108c26:	8b 48 10             	mov    0x10(%eax),%ecx
  108c29:	8b 45 f0             	mov    -0x10(%ebp),%eax
  108c2c:	8b 40 0c             	mov    0xc(%eax),%eax
  108c2f:	8b 00                	mov    (%eax),%eax
  108c31:	c7 44 24 14 02 00 00 	movl   $0x2,0x14(%esp)
  108c38:	00 
  108c39:	89 5c 24 10          	mov    %ebx,0x10(%esp)
  108c3d:	89 74 24 0c          	mov    %esi,0xc(%esp)
  108c41:	89 54 24 08          	mov    %edx,0x8(%esp)
  108c45:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  108c49:	89 04 24             	mov    %eax,(%esp)
  108c4c:	e8 e3 21 00 00       	call   10ae34 <perm_check>
  108c51:	85 c0                	test   %eax,%eax
  108c53:	75 15                	jne    108c6a <ipc_sem_setall+0x90>
  108c55:	a1 a0 e1 10 00       	mov    0x10e1a0,%eax
  108c5a:	8b 50 04             	mov    0x4(%eax),%edx
  108c5d:	8b 45 f0             	mov    -0x10(%ebp),%eax
  108c60:	8b 40 10             	mov    0x10(%eax),%eax
  108c63:	8b 40 04             	mov    0x4(%eax),%eax
  108c66:	39 c2                	cmp    %eax,%edx
  108c68:	75 4f                	jne    108cb9 <ipc_sem_setall+0xdf>
      size_t i;
      for (i=0;i<semset->num;i++) semset->sems[i].val = buf[i];
  108c6a:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  108c71:	eb 29                	jmp    108c9c <ipc_sem_setall+0xc2>
  108c73:	8b 45 f0             	mov    -0x10(%ebp),%eax
  108c76:	8b 48 1c             	mov    0x1c(%eax),%ecx
  108c79:	8b 55 f4             	mov    -0xc(%ebp),%edx
  108c7c:	89 d0                	mov    %edx,%eax
  108c7e:	c1 e0 02             	shl    $0x2,%eax
  108c81:	01 d0                	add    %edx,%eax
  108c83:	c1 e0 02             	shl    $0x2,%eax
  108c86:	8d 14 01             	lea    (%ecx,%eax,1),%edx
  108c89:	8b 45 f4             	mov    -0xc(%ebp),%eax
  108c8c:	01 c0                	add    %eax,%eax
  108c8e:	03 45 0c             	add    0xc(%ebp),%eax
  108c91:	0f b7 00             	movzwl (%eax),%eax
  108c94:	98                   	cwtl   
  108c95:	89 42 04             	mov    %eax,0x4(%edx)
  108c98:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
  108c9c:	8b 45 f0             	mov    -0x10(%ebp),%eax
  108c9f:	8b 40 18             	mov    0x18(%eax),%eax
  108ca2:	3b 45 f4             	cmp    -0xc(%ebp),%eax
  108ca5:	77 cc                	ja     108c73 <ipc_sem_setall+0x99>
      semset->ctime = time;
  108ca7:	8b 55 f0             	mov    -0x10(%ebp),%edx
  108caa:	8b 45 10             	mov    0x10(%ebp),%eax
  108cad:	89 42 24             	mov    %eax,0x24(%edx)
      return 0;
  108cb0:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
  108cb7:	eb 10                	jmp    108cc9 <ipc_sem_setall+0xef>
    }
    else return -EACCES;
  108cb9:	c7 45 e4 fe ff ff ff 	movl   $0xfffffffe,-0x1c(%ebp)
  108cc0:	eb 07                	jmp    108cc9 <ipc_sem_setall+0xef>
  }
  return -EINVAL;
  108cc2:	c7 45 e4 e4 ff ff ff 	movl   $0xffffffe4,-0x1c(%ebp)
  108cc9:	8b 45 e4             	mov    -0x1c(%ebp),%eax
}
  108ccc:	83 c4 30             	add    $0x30,%esp
  108ccf:	5b                   	pop    %ebx
  108cd0:	5e                   	pop    %esi
  108cd1:	5d                   	pop    %ebp
  108cd2:	c3                   	ret    

00108cd3 <ipc_sem_stat>:

int ipc_sem_stat(id_t id,uid_t *uid,gid_t *gid,uid_t *cuid,gid_t *cgid,mode_t *mode,size_t *nsems,time_t *otime,time_t *ctime) {
  108cd3:	55                   	push   %ebp
  108cd4:	89 e5                	mov    %esp,%ebp
  108cd6:	56                   	push   %esi
  108cd7:	53                   	push   %ebx
  108cd8:	83 ec 30             	sub    $0x30,%esp
  ipc_sem_t *semset = ipc_sem_find(-1,id);
  108cdb:	c7 44 24 08 03 00 00 	movl   $0x3,0x8(%esp)
  108ce2:	00 
  108ce3:	8b 45 08             	mov    0x8(%ebp),%eax
  108ce6:	89 44 24 04          	mov    %eax,0x4(%esp)
  108cea:	c7 04 24 ff ff ff ff 	movl   $0xffffffff,(%esp)
  108cf1:	e8 15 88 ff ff       	call   10150b <ipc_find>
  108cf6:	89 45 f4             	mov    %eax,-0xc(%ebp)
  if (semset!=NULL) {
  108cf9:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
  108cfd:	0f 84 d6 00 00 00    	je     108dd9 <ipc_sem_stat+0x106>
    if (ipc_sem_permcheck(semset,PERM_R)) {
  108d03:	8b 45 f4             	mov    -0xc(%ebp),%eax
  108d06:	8b 58 14             	mov    0x14(%eax),%ebx
  108d09:	a1 a0 e1 10 00       	mov    0x10e1a0,%eax
  108d0e:	8b 70 10             	mov    0x10(%eax),%esi
  108d11:	a1 a0 e1 10 00       	mov    0x10e1a0,%eax
  108d16:	8b 50 04             	mov    0x4(%eax),%edx
  108d19:	8b 45 f4             	mov    -0xc(%ebp),%eax
  108d1c:	8b 40 0c             	mov    0xc(%eax),%eax
  108d1f:	8b 48 10             	mov    0x10(%eax),%ecx
  108d22:	8b 45 f4             	mov    -0xc(%ebp),%eax
  108d25:	8b 40 0c             	mov    0xc(%eax),%eax
  108d28:	8b 00                	mov    (%eax),%eax
  108d2a:	c7 44 24 14 01 00 00 	movl   $0x1,0x14(%esp)
  108d31:	00 
  108d32:	89 5c 24 10          	mov    %ebx,0x10(%esp)
  108d36:	89 74 24 0c          	mov    %esi,0xc(%esp)
  108d3a:	89 54 24 08          	mov    %edx,0x8(%esp)
  108d3e:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  108d42:	89 04 24             	mov    %eax,(%esp)
  108d45:	e8 ea 20 00 00       	call   10ae34 <perm_check>
  108d4a:	85 c0                	test   %eax,%eax
  108d4c:	75 15                	jne    108d63 <ipc_sem_stat+0x90>
  108d4e:	a1 a0 e1 10 00       	mov    0x10e1a0,%eax
  108d53:	8b 50 04             	mov    0x4(%eax),%edx
  108d56:	8b 45 f4             	mov    -0xc(%ebp),%eax
  108d59:	8b 40 10             	mov    0x10(%eax),%eax
  108d5c:	8b 40 04             	mov    0x4(%eax),%eax
  108d5f:	39 c2                	cmp    %eax,%edx
  108d61:	75 6d                	jne    108dd0 <ipc_sem_stat+0xfd>
      *uid = semset->ipc.owner->uid;
  108d63:	8b 45 f4             	mov    -0xc(%ebp),%eax
  108d66:	8b 40 0c             	mov    0xc(%eax),%eax
  108d69:	8b 50 04             	mov    0x4(%eax),%edx
  108d6c:	8b 45 0c             	mov    0xc(%ebp),%eax
  108d6f:	89 10                	mov    %edx,(%eax)
      *gid = semset->ipc.owner->gid;
  108d71:	8b 45 f4             	mov    -0xc(%ebp),%eax
  108d74:	8b 40 0c             	mov    0xc(%eax),%eax
  108d77:	8b 50 10             	mov    0x10(%eax),%edx
  108d7a:	8b 45 10             	mov    0x10(%ebp),%eax
  108d7d:	89 10                	mov    %edx,(%eax)
      *cuid = semset->ipc.creator->uid;
  108d7f:	8b 45 f4             	mov    -0xc(%ebp),%eax
  108d82:	8b 40 10             	mov    0x10(%eax),%eax
  108d85:	8b 50 04             	mov    0x4(%eax),%edx
  108d88:	8b 45 14             	mov    0x14(%ebp),%eax
  108d8b:	89 10                	mov    %edx,(%eax)
      *cgid = semset->ipc.creator->gid;
  108d8d:	8b 45 f4             	mov    -0xc(%ebp),%eax
  108d90:	8b 40 10             	mov    0x10(%eax),%eax
  108d93:	8b 50 10             	mov    0x10(%eax),%edx
  108d96:	8b 45 18             	mov    0x18(%ebp),%eax
  108d99:	89 10                	mov    %edx,(%eax)
      *mode = semset->ipc.mode;
  108d9b:	8b 45 f4             	mov    -0xc(%ebp),%eax
  108d9e:	8b 50 14             	mov    0x14(%eax),%edx
  108da1:	8b 45 1c             	mov    0x1c(%ebp),%eax
  108da4:	89 10                	mov    %edx,(%eax)
      *nsems = semset->num;
  108da6:	8b 45 f4             	mov    -0xc(%ebp),%eax
  108da9:	8b 50 18             	mov    0x18(%eax),%edx
  108dac:	8b 45 20             	mov    0x20(%ebp),%eax
  108daf:	89 10                	mov    %edx,(%eax)
      *otime = semset->otime;
  108db1:	8b 45 f4             	mov    -0xc(%ebp),%eax
  108db4:	8b 50 20             	mov    0x20(%eax),%edx
  108db7:	8b 45 24             	mov    0x24(%ebp),%eax
  108dba:	89 10                	mov    %edx,(%eax)
      *ctime = semset->ctime;
  108dbc:	8b 45 f4             	mov    -0xc(%ebp),%eax
  108dbf:	8b 50 24             	mov    0x24(%eax),%edx
  108dc2:	8b 45 28             	mov    0x28(%ebp),%eax
  108dc5:	89 10                	mov    %edx,(%eax)
      return 0;
  108dc7:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
  108dce:	eb 10                	jmp    108de0 <ipc_sem_stat+0x10d>
    }
    else return -EACCES;
  108dd0:	c7 45 e4 fe ff ff ff 	movl   $0xfffffffe,-0x1c(%ebp)
  108dd7:	eb 07                	jmp    108de0 <ipc_sem_stat+0x10d>
  }
  return -EINVAL;
  108dd9:	c7 45 e4 e4 ff ff ff 	movl   $0xffffffe4,-0x1c(%ebp)
  108de0:	8b 45 e4             	mov    -0x1c(%ebp),%eax
}
  108de3:	83 c4 30             	add    $0x30,%esp
  108de6:	5b                   	pop    %ebx
  108de7:	5e                   	pop    %esi
  108de8:	5d                   	pop    %ebp
  108de9:	c3                   	ret    

00108dea <ipc_sem_set>:

int ipc_sem_set(id_t id,uid_t uid,gid_t gid,mode_t mode,time_t time) {
  108dea:	55                   	push   %ebp
  108deb:	89 e5                	mov    %esp,%ebp
  108ded:	56                   	push   %esi
  108dee:	53                   	push   %ebx
  108def:	83 ec 30             	sub    $0x30,%esp
  ipc_sem_t *semset = ipc_sem_find(-1,id);
  108df2:	c7 44 24 08 03 00 00 	movl   $0x3,0x8(%esp)
  108df9:	00 
  108dfa:	8b 45 08             	mov    0x8(%ebp),%eax
  108dfd:	89 44 24 04          	mov    %eax,0x4(%esp)
  108e01:	c7 04 24 ff ff ff ff 	movl   $0xffffffff,(%esp)
  108e08:	e8 fe 86 ff ff       	call   10150b <ipc_find>
  108e0d:	89 45 f4             	mov    %eax,-0xc(%ebp)
  if (semset!=NULL) {
  108e10:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
  108e14:	0f 84 84 00 00 00    	je     108e9e <ipc_sem_set+0xb4>
    if (ipc_sem_permcheck(semset,PERM_W)) {
  108e1a:	8b 45 f4             	mov    -0xc(%ebp),%eax
  108e1d:	8b 58 14             	mov    0x14(%eax),%ebx
  108e20:	a1 a0 e1 10 00       	mov    0x10e1a0,%eax
  108e25:	8b 70 10             	mov    0x10(%eax),%esi
  108e28:	a1 a0 e1 10 00       	mov    0x10e1a0,%eax
  108e2d:	8b 50 04             	mov    0x4(%eax),%edx
  108e30:	8b 45 f4             	mov    -0xc(%ebp),%eax
  108e33:	8b 40 0c             	mov    0xc(%eax),%eax
  108e36:	8b 48 10             	mov    0x10(%eax),%ecx
  108e39:	8b 45 f4             	mov    -0xc(%ebp),%eax
  108e3c:	8b 40 0c             	mov    0xc(%eax),%eax
  108e3f:	8b 00                	mov    (%eax),%eax
  108e41:	c7 44 24 14 02 00 00 	movl   $0x2,0x14(%esp)
  108e48:	00 
  108e49:	89 5c 24 10          	mov    %ebx,0x10(%esp)
  108e4d:	89 74 24 0c          	mov    %esi,0xc(%esp)
  108e51:	89 54 24 08          	mov    %edx,0x8(%esp)
  108e55:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  108e59:	89 04 24             	mov    %eax,(%esp)
  108e5c:	e8 d3 1f 00 00       	call   10ae34 <perm_check>
  108e61:	85 c0                	test   %eax,%eax
  108e63:	75 15                	jne    108e7a <ipc_sem_set+0x90>
  108e65:	a1 a0 e1 10 00       	mov    0x10e1a0,%eax
  108e6a:	8b 50 04             	mov    0x4(%eax),%edx
  108e6d:	8b 45 f4             	mov    -0xc(%ebp),%eax
  108e70:	8b 40 10             	mov    0x10(%eax),%eax
  108e73:	8b 40 04             	mov    0x4(%eax),%eax
  108e76:	39 c2                	cmp    %eax,%edx
  108e78:	75 1b                	jne    108e95 <ipc_sem_set+0xab>
      semset->ipc.mode = mode;
  108e7a:	8b 55 f4             	mov    -0xc(%ebp),%edx
  108e7d:	8b 45 14             	mov    0x14(%ebp),%eax
  108e80:	89 42 14             	mov    %eax,0x14(%edx)
      semset->ctime = time;
  108e83:	8b 55 f4             	mov    -0xc(%ebp),%edx
  108e86:	8b 45 18             	mov    0x18(%ebp),%eax
  108e89:	89 42 24             	mov    %eax,0x24(%edx)
      return 0;
  108e8c:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
  108e93:	eb 10                	jmp    108ea5 <ipc_sem_set+0xbb>
    }
    else return -EACCES;
  108e95:	c7 45 e4 fe ff ff ff 	movl   $0xfffffffe,-0x1c(%ebp)
  108e9c:	eb 07                	jmp    108ea5 <ipc_sem_set+0xbb>
  }
  return -EINVAL;
  108e9e:	c7 45 e4 e4 ff ff ff 	movl   $0xffffffe4,-0x1c(%ebp)
  108ea5:	8b 45 e4             	mov    -0x1c(%ebp),%eax
}
  108ea8:	83 c4 30             	add    $0x30,%esp
  108eab:	5b                   	pop    %ebx
  108eac:	5e                   	pop    %esi
  108ead:	5d                   	pop    %ebp
  108eae:	c3                   	ret    

00108eaf <ipc_sem_destroy>:
/**
 * Destroys a semaphore set (Syscall)
 *  @param id SemID
 *  @return Success?
 */
int ipc_sem_destroy(id_t id) {
  108eaf:	55                   	push   %ebp
  108eb0:	89 e5                	mov    %esp,%ebp
  108eb2:	56                   	push   %esi
  108eb3:	53                   	push   %ebx
  108eb4:	83 ec 30             	sub    $0x30,%esp
  ipc_sem_t *semset = ipc_sem_find(-1,id);
  108eb7:	c7 44 24 08 03 00 00 	movl   $0x3,0x8(%esp)
  108ebe:	00 
  108ebf:	8b 45 08             	mov    0x8(%ebp),%eax
  108ec2:	89 44 24 04          	mov    %eax,0x4(%esp)
  108ec6:	c7 04 24 ff ff ff ff 	movl   $0xffffffff,(%esp)
  108ecd:	e8 39 86 ff ff       	call   10150b <ipc_find>
  108ed2:	89 45 e8             	mov    %eax,-0x18(%ebp)
  if (semset!=NULL) {
  108ed5:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
  108ed9:	0f 84 6a 01 00 00    	je     109049 <ipc_sem_destroy+0x19a>
    if (ipc_sem_permcheck(semset,PERM_W)) {
  108edf:	8b 45 e8             	mov    -0x18(%ebp),%eax
  108ee2:	8b 58 14             	mov    0x14(%eax),%ebx
  108ee5:	a1 a0 e1 10 00       	mov    0x10e1a0,%eax
  108eea:	8b 70 10             	mov    0x10(%eax),%esi
  108eed:	a1 a0 e1 10 00       	mov    0x10e1a0,%eax
  108ef2:	8b 50 04             	mov    0x4(%eax),%edx
  108ef5:	8b 45 e8             	mov    -0x18(%ebp),%eax
  108ef8:	8b 40 0c             	mov    0xc(%eax),%eax
  108efb:	8b 48 10             	mov    0x10(%eax),%ecx
  108efe:	8b 45 e8             	mov    -0x18(%ebp),%eax
  108f01:	8b 40 0c             	mov    0xc(%eax),%eax
  108f04:	8b 00                	mov    (%eax),%eax
  108f06:	c7 44 24 14 02 00 00 	movl   $0x2,0x14(%esp)
  108f0d:	00 
  108f0e:	89 5c 24 10          	mov    %ebx,0x10(%esp)
  108f12:	89 74 24 0c          	mov    %esi,0xc(%esp)
  108f16:	89 54 24 08          	mov    %edx,0x8(%esp)
  108f1a:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  108f1e:	89 04 24             	mov    %eax,(%esp)
  108f21:	e8 0e 1f 00 00       	call   10ae34 <perm_check>
  108f26:	85 c0                	test   %eax,%eax
  108f28:	75 19                	jne    108f43 <ipc_sem_destroy+0x94>
  108f2a:	a1 a0 e1 10 00       	mov    0x10e1a0,%eax
  108f2f:	8b 50 04             	mov    0x4(%eax),%edx
  108f32:	8b 45 e8             	mov    -0x18(%ebp),%eax
  108f35:	8b 40 10             	mov    0x10(%eax),%eax
  108f38:	8b 40 04             	mov    0x4(%eax),%eax
  108f3b:	39 c2                	cmp    %eax,%edx
  108f3d:	0f 85 fd 00 00 00    	jne    109040 <ipc_sem_destroy+0x191>
      size_t i;
      for (i=0;i<semset->num;i++) {
  108f43:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
  108f4a:	e9 a0 00 00 00       	jmp    108fef <ipc_sem_destroy+0x140>
        proc_t *proc;
        ipc_sem_sleepn_t *sleepn;
        while ((proc = llist_pop(semset->sems[i].waitz))) proc_wake(proc);
  108f4f:	8b 45 f0             	mov    -0x10(%ebp),%eax
  108f52:	89 04 24             	mov    %eax,(%esp)
  108f55:	e8 33 d7 ff ff       	call   10668d <proc_wake>
  108f5a:	8b 45 e8             	mov    -0x18(%ebp),%eax
  108f5d:	8b 48 1c             	mov    0x1c(%eax),%ecx
  108f60:	8b 55 ec             	mov    -0x14(%ebp),%edx
  108f63:	89 d0                	mov    %edx,%eax
  108f65:	c1 e0 02             	shl    $0x2,%eax
  108f68:	01 d0                	add    %edx,%eax
  108f6a:	c1 e0 02             	shl    $0x2,%eax
  108f6d:	8d 04 01             	lea    (%ecx,%eax,1),%eax
  108f70:	8b 40 10             	mov    0x10(%eax),%eax
  108f73:	89 04 24             	mov    %eax,(%esp)
  108f76:	e8 2d 1a 00 00       	call   10a9a8 <llist_pop>
  108f7b:	89 45 f0             	mov    %eax,-0x10(%ebp)
  108f7e:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
  108f82:	75 cb                	jne    108f4f <ipc_sem_destroy+0xa0>
  108f84:	eb 3b                	jmp    108fc1 <ipc_sem_destroy+0x112>
        while ((sleepn = llist_pop(semset->sems[i].waitn))) {
          if (sleepn->val<semset->sems[i].val) {
  108f86:	8b 45 f4             	mov    -0xc(%ebp),%eax
  108f89:	8b 18                	mov    (%eax),%ebx
  108f8b:	8b 45 e8             	mov    -0x18(%ebp),%eax
  108f8e:	8b 48 1c             	mov    0x1c(%eax),%ecx
  108f91:	8b 55 ec             	mov    -0x14(%ebp),%edx
  108f94:	89 d0                	mov    %edx,%eax
  108f96:	c1 e0 02             	shl    $0x2,%eax
  108f99:	01 d0                	add    %edx,%eax
  108f9b:	c1 e0 02             	shl    $0x2,%eax
  108f9e:	8d 04 01             	lea    (%ecx,%eax,1),%eax
  108fa1:	8b 40 04             	mov    0x4(%eax),%eax
  108fa4:	39 c3                	cmp    %eax,%ebx
  108fa6:	7d 19                	jge    108fc1 <ipc_sem_destroy+0x112>
            free(sleepn);
  108fa8:	8b 45 f4             	mov    -0xc(%ebp),%eax
  108fab:	89 04 24             	mov    %eax,(%esp)
  108fae:	e8 ea 9f ff ff       	call   102f9d <free>
            proc_wake(sleepn->proc);
  108fb3:	8b 45 f4             	mov    -0xc(%ebp),%eax
  108fb6:	8b 40 04             	mov    0x4(%eax),%eax
  108fb9:	89 04 24             	mov    %eax,(%esp)
  108fbc:	e8 cc d6 ff ff       	call   10668d <proc_wake>
      size_t i;
      for (i=0;i<semset->num;i++) {
        proc_t *proc;
        ipc_sem_sleepn_t *sleepn;
        while ((proc = llist_pop(semset->sems[i].waitz))) proc_wake(proc);
        while ((sleepn = llist_pop(semset->sems[i].waitn))) {
  108fc1:	8b 45 e8             	mov    -0x18(%ebp),%eax
  108fc4:	8b 48 1c             	mov    0x1c(%eax),%ecx
  108fc7:	8b 55 ec             	mov    -0x14(%ebp),%edx
  108fca:	89 d0                	mov    %edx,%eax
  108fcc:	c1 e0 02             	shl    $0x2,%eax
  108fcf:	01 d0                	add    %edx,%eax
  108fd1:	c1 e0 02             	shl    $0x2,%eax
  108fd4:	8d 04 01             	lea    (%ecx,%eax,1),%eax
  108fd7:	8b 40 0c             	mov    0xc(%eax),%eax
  108fda:	89 04 24             	mov    %eax,(%esp)
  108fdd:	e8 c6 19 00 00       	call   10a9a8 <llist_pop>
  108fe2:	89 45 f4             	mov    %eax,-0xc(%ebp)
  108fe5:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
  108fe9:	75 9b                	jne    108f86 <ipc_sem_destroy+0xd7>
int ipc_sem_destroy(id_t id) {
  ipc_sem_t *semset = ipc_sem_find(-1,id);
  if (semset!=NULL) {
    if (ipc_sem_permcheck(semset,PERM_W)) {
      size_t i;
      for (i=0;i<semset->num;i++) {
  108feb:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
  108fef:	8b 45 e8             	mov    -0x18(%ebp),%eax
  108ff2:	8b 40 18             	mov    0x18(%eax),%eax
  108ff5:	3b 45 ec             	cmp    -0x14(%ebp),%eax
  108ff8:	0f 87 5c ff ff ff    	ja     108f5a <ipc_sem_destroy+0xab>
            free(sleepn);
            proc_wake(sleepn->proc);
          }
        }
      }
      free(semset->sems);
  108ffe:	8b 45 e8             	mov    -0x18(%ebp),%eax
  109001:	8b 40 1c             	mov    0x1c(%eax),%eax
  109004:	89 04 24             	mov    %eax,(%esp)
  109007:	e8 91 9f ff ff       	call   102f9d <free>
      free(semset);
  10900c:	8b 45 e8             	mov    -0x18(%ebp),%eax
  10900f:	89 04 24             	mov    %eax,(%esp)
  109012:	e8 86 9f ff ff       	call   102f9d <free>
      llist_remove(ipc_objects,llist_find(ipc_objects,semset));
  109017:	8b 15 90 e1 10 00    	mov    0x10e190,%edx
  10901d:	8b 45 e8             	mov    -0x18(%ebp),%eax
  109020:	89 44 24 04          	mov    %eax,0x4(%esp)
  109024:	89 14 24             	mov    %edx,(%esp)
  109027:	e8 f5 1b 00 00       	call   10ac21 <llist_find>
  10902c:	8b 15 90 e1 10 00    	mov    0x10e190,%edx
  109032:	89 44 24 04          	mov    %eax,0x4(%esp)
  109036:	89 14 24             	mov    %edx,(%esp)
  109039:	e8 1b 1b 00 00       	call   10ab59 <llist_remove>
  10903e:	eb 09                	jmp    109049 <ipc_sem_destroy+0x19a>
    }
    else return -EACCES;
  109040:	c7 45 e4 fe ff ff ff 	movl   $0xfffffffe,-0x1c(%ebp)
  109047:	eb 07                	jmp    109050 <ipc_sem_destroy+0x1a1>
  }
  return -EINVAL;
  109049:	c7 45 e4 e4 ff ff ff 	movl   $0xffffffe4,-0x1c(%ebp)
  109050:	8b 45 e4             	mov    -0x1c(%ebp),%eax
}
  109053:	83 c4 30             	add    $0x30,%esp
  109056:	5b                   	pop    %ebx
  109057:	5e                   	pop    %esi
  109058:	5d                   	pop    %ebp
  109059:	c3                   	ret    
	...

0010905c <ipc_shm_init>:

/**
 * Intitializes Shared Memory
 *  @return Success?
 */
int ipc_shm_init() {
  10905c:	55                   	push   %ebp
  10905d:	89 e5                	mov    %esp,%ebp
  10905f:	83 ec 18             	sub    $0x18,%esp
  if (syscall_create(SYSCALL_IPC_SHM_GET,ipc_shm_get,1)==-1) return -1;
  109062:	c7 44 24 08 01 00 00 	movl   $0x1,0x8(%esp)
  109069:	00 
  10906a:	c7 44 24 04 a0 91 10 	movl   $0x1091a0,0x4(%esp)
  109071:	00 
  109072:	c7 04 24 1a 00 00 00 	movl   $0x1a,(%esp)
  109079:	e8 bc 0d 00 00       	call   109e3a <syscall_create>
  10907e:	83 f8 ff             	cmp    $0xffffffff,%eax
  109081:	75 0c                	jne    10908f <ipc_shm_init+0x33>
  109083:	c7 45 fc ff ff ff ff 	movl   $0xffffffff,-0x4(%ebp)
  10908a:	e9 0c 01 00 00       	jmp    10919b <ipc_shm_init+0x13f>
  if (syscall_create(SYSCALL_IPC_SHM_CREATE,ipc_shm_create,4)==-1) return -1;
  10908f:	c7 44 24 08 04 00 00 	movl   $0x4,0x8(%esp)
  109096:	00 
  109097:	c7 44 24 04 e1 91 10 	movl   $0x1091e1,0x4(%esp)
  10909e:	00 
  10909f:	c7 04 24 1b 00 00 00 	movl   $0x1b,(%esp)
  1090a6:	e8 8f 0d 00 00       	call   109e3a <syscall_create>
  1090ab:	83 f8 ff             	cmp    $0xffffffff,%eax
  1090ae:	75 0c                	jne    1090bc <ipc_shm_init+0x60>
  1090b0:	c7 45 fc ff ff ff ff 	movl   $0xffffffff,-0x4(%ebp)
  1090b7:	e9 df 00 00 00       	jmp    10919b <ipc_shm_init+0x13f>
  if (syscall_create(SYSCALL_IPC_SHM_ATTACH,ipc_shm_attach,4)==-1) return -1;
  1090bc:	c7 44 24 08 04 00 00 	movl   $0x4,0x8(%esp)
  1090c3:	00 
  1090c4:	c7 44 24 04 68 93 10 	movl   $0x109368,0x4(%esp)
  1090cb:	00 
  1090cc:	c7 04 24 1c 00 00 00 	movl   $0x1c,(%esp)
  1090d3:	e8 62 0d 00 00       	call   109e3a <syscall_create>
  1090d8:	83 f8 ff             	cmp    $0xffffffff,%eax
  1090db:	75 0c                	jne    1090e9 <ipc_shm_init+0x8d>
  1090dd:	c7 45 fc ff ff ff ff 	movl   $0xffffffff,-0x4(%ebp)
  1090e4:	e9 b2 00 00 00       	jmp    10919b <ipc_shm_init+0x13f>
  if (syscall_create(SYSCALL_IPC_SHM_DETACH,ipc_shm_detach,2)==-1) return -1;
  1090e9:	c7 44 24 08 02 00 00 	movl   $0x2,0x8(%esp)
  1090f0:	00 
  1090f1:	c7 44 24 04 16 95 10 	movl   $0x109516,0x4(%esp)
  1090f8:	00 
  1090f9:	c7 04 24 1d 00 00 00 	movl   $0x1d,(%esp)
  109100:	e8 35 0d 00 00       	call   109e3a <syscall_create>
  109105:	83 f8 ff             	cmp    $0xffffffff,%eax
  109108:	75 0c                	jne    109116 <ipc_shm_init+0xba>
  10910a:	c7 45 fc ff ff ff ff 	movl   $0xffffffff,-0x4(%ebp)
  109111:	e9 85 00 00 00       	jmp    10919b <ipc_shm_init+0x13f>
  if (syscall_create(SYSCALL_IPC_SHM_STAT,ipc_shm_stat,13)==-1) return -1;
  109116:	c7 44 24 08 0d 00 00 	movl   $0xd,0x8(%esp)
  10911d:	00 
  10911e:	c7 44 24 04 36 96 10 	movl   $0x109636,0x4(%esp)
  109125:	00 
  109126:	c7 04 24 1e 00 00 00 	movl   $0x1e,(%esp)
  10912d:	e8 08 0d 00 00       	call   109e3a <syscall_create>
  109132:	83 f8 ff             	cmp    $0xffffffff,%eax
  109135:	75 09                	jne    109140 <ipc_shm_init+0xe4>
  109137:	c7 45 fc ff ff ff ff 	movl   $0xffffffff,-0x4(%ebp)
  10913e:	eb 5b                	jmp    10919b <ipc_shm_init+0x13f>
  if (syscall_create(SYSCALL_IPC_SHM_SET,ipc_shm_set,7)==-1) return -1;
  109140:	c7 44 24 08 07 00 00 	movl   $0x7,0x8(%esp)
  109147:	00 
  109148:	c7 44 24 04 89 97 10 	movl   $0x109789,0x4(%esp)
  10914f:	00 
  109150:	c7 04 24 1f 00 00 00 	movl   $0x1f,(%esp)
  109157:	e8 de 0c 00 00       	call   109e3a <syscall_create>
  10915c:	83 f8 ff             	cmp    $0xffffffff,%eax
  10915f:	75 09                	jne    10916a <ipc_shm_init+0x10e>
  109161:	c7 45 fc ff ff ff ff 	movl   $0xffffffff,-0x4(%ebp)
  109168:	eb 31                	jmp    10919b <ipc_shm_init+0x13f>
  if (syscall_create(SYSCALL_IPC_SHM_DESTROY,ipc_shm_destroy,1)==-1) return -1;
  10916a:	c7 44 24 08 01 00 00 	movl   $0x1,0x8(%esp)
  109171:	00 
  109172:	c7 44 24 04 4e 98 10 	movl   $0x10984e,0x4(%esp)
  109179:	00 
  10917a:	c7 04 24 20 00 00 00 	movl   $0x20,(%esp)
  109181:	e8 b4 0c 00 00       	call   109e3a <syscall_create>
  109186:	83 f8 ff             	cmp    $0xffffffff,%eax
  109189:	75 09                	jne    109194 <ipc_shm_init+0x138>
  10918b:	c7 45 fc ff ff ff ff 	movl   $0xffffffff,-0x4(%ebp)
  109192:	eb 07                	jmp    10919b <ipc_shm_init+0x13f>
  return 0;
  109194:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
  10919b:	8b 45 fc             	mov    -0x4(%ebp),%eax
}
  10919e:	c9                   	leave  
  10919f:	c3                   	ret    

001091a0 <ipc_shm_get>:
/**
 * Gets a shared memory object (Syscall)
 *  @param key IPC Key
 *  @return SHMID
 */
id_t ipc_shm_get(key_t key) {
  1091a0:	55                   	push   %ebp
  1091a1:	89 e5                	mov    %esp,%ebp
  1091a3:	83 ec 28             	sub    $0x28,%esp
  ipc_shm_t *shm = ipc_shm_find(key,-1);
  1091a6:	c7 44 24 08 04 00 00 	movl   $0x4,0x8(%esp)
  1091ad:	00 
  1091ae:	c7 44 24 04 ff ff ff 	movl   $0xffffffff,0x4(%esp)
  1091b5:	ff 
  1091b6:	8b 45 08             	mov    0x8(%ebp),%eax
  1091b9:	89 04 24             	mov    %eax,(%esp)
  1091bc:	e8 4a 83 ff ff       	call   10150b <ipc_find>
  1091c1:	89 45 fc             	mov    %eax,-0x4(%ebp)
  if (shm==NULL) return -EINVAL;
  1091c4:	83 7d fc 00          	cmpl   $0x0,-0x4(%ebp)
  1091c8:	75 09                	jne    1091d3 <ipc_shm_get+0x33>
  1091ca:	c7 45 ec e4 ff ff ff 	movl   $0xffffffe4,-0x14(%ebp)
  1091d1:	eb 09                	jmp    1091dc <ipc_shm_get+0x3c>
  else return shm->ipc.id;
  1091d3:	8b 45 fc             	mov    -0x4(%ebp),%eax
  1091d6:	8b 40 04             	mov    0x4(%eax),%eax
  1091d9:	89 45 ec             	mov    %eax,-0x14(%ebp)
  1091dc:	8b 45 ec             	mov    -0x14(%ebp),%eax
}
  1091df:	c9                   	leave  
  1091e0:	c3                   	ret    

001091e1 <ipc_shm_create>:
 *  @param size Size
 *  @param flags Flags
 *  @param time Current time
 *  @return SHMID
 */
id_t ipc_shm_create(key_t key,size_t size,int flags,time_t time) {
  1091e1:	55                   	push   %ebp
  1091e2:	89 e5                	mov    %esp,%ebp
  1091e4:	53                   	push   %ebx
  1091e5:	83 ec 24             	sub    $0x24,%esp
  ipc_shm_t *shm = key!=IPC_PRIVATE?ipc_shm_find(key,-1):NULL;
  1091e8:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
  1091ec:	74 20                	je     10920e <ipc_shm_create+0x2d>
  1091ee:	c7 44 24 08 04 00 00 	movl   $0x4,0x8(%esp)
  1091f5:	00 
  1091f6:	c7 44 24 04 ff ff ff 	movl   $0xffffffff,0x4(%esp)
  1091fd:	ff 
  1091fe:	8b 45 08             	mov    0x8(%ebp),%eax
  109201:	89 04 24             	mov    %eax,(%esp)
  109204:	e8 02 83 ff ff       	call   10150b <ipc_find>
  109209:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  10920c:	eb 07                	jmp    109215 <ipc_shm_create+0x34>
  10920e:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
  109215:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  109218:	89 45 f0             	mov    %eax,-0x10(%ebp)
  if (shm==NULL) {
  10921b:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
  10921f:	0f 85 33 01 00 00    	jne    109358 <ipc_shm_create+0x177>
    ipc_shm_t *new = malloc(sizeof(ipc_shm_t));
  109225:	c7 04 24 38 00 00 00 	movl   $0x38,(%esp)
  10922c:	e8 38 9d ff ff       	call   102f69 <malloc>
  109231:	89 45 f4             	mov    %eax,-0xc(%ebp)
    if (new!=NULL) {
  109234:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
  109238:	0f 84 11 01 00 00    	je     10934f <ipc_shm_create+0x16e>
      size_t i;
      memset(new,0,sizeof(ipc_shm_t));
  10923e:	c7 44 24 08 38 00 00 	movl   $0x38,0x8(%esp)
  109245:	00 
  109246:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  10924d:	00 
  10924e:	8b 45 f4             	mov    -0xc(%ebp),%eax
  109251:	89 04 24             	mov    %eax,(%esp)
  109254:	e8 08 2b 00 00       	call   10bd61 <memset>
      new->ipc.type = IPC_SHM;
  109259:	8b 45 f4             	mov    -0xc(%ebp),%eax
  10925c:	c7 00 04 00 00 00    	movl   $0x4,(%eax)
      new->ipc.id = ipc_lastid++;
  109262:	8b 15 98 e1 10 00    	mov    0x10e198,%edx
  109268:	8b 45 f4             	mov    -0xc(%ebp),%eax
  10926b:	89 50 04             	mov    %edx,0x4(%eax)
  10926e:	8d 42 01             	lea    0x1(%edx),%eax
  109271:	a3 98 e1 10 00       	mov    %eax,0x10e198
      new->ipc.key = key;
  109276:	8b 55 f4             	mov    -0xc(%ebp),%edx
  109279:	8b 45 08             	mov    0x8(%ebp),%eax
  10927c:	89 42 08             	mov    %eax,0x8(%edx)
      new->ipc.owner = proc_current;
  10927f:	8b 15 a0 e1 10 00    	mov    0x10e1a0,%edx
  109285:	8b 45 f4             	mov    -0xc(%ebp),%eax
  109288:	89 50 0c             	mov    %edx,0xc(%eax)
      new->ipc.creator = proc_current;
  10928b:	8b 15 a0 e1 10 00    	mov    0x10e1a0,%edx
  109291:	8b 45 f4             	mov    -0xc(%ebp),%eax
  109294:	89 50 10             	mov    %edx,0x10(%eax)
      new->ipc.mode = flags&0777;
  109297:	8b 45 10             	mov    0x10(%ebp),%eax
  10929a:	89 c2                	mov    %eax,%edx
  10929c:	81 e2 ff 01 00 00    	and    $0x1ff,%edx
  1092a2:	8b 45 f4             	mov    -0xc(%ebp),%eax
  1092a5:	89 50 14             	mov    %edx,0x14(%eax)
      new->size = size;
  1092a8:	8b 55 f4             	mov    -0xc(%ebp),%edx
  1092ab:	8b 45 0c             	mov    0xc(%ebp),%eax
  1092ae:	89 42 18             	mov    %eax,0x18(%edx)
      new->num_pages = ADDR2PAGE(PAGEUP(new->size));
  1092b1:	8b 45 f4             	mov    -0xc(%ebp),%eax
  1092b4:	8b 40 18             	mov    0x18(%eax),%eax
  1092b7:	83 e8 01             	sub    $0x1,%eax
  1092ba:	c1 e8 0c             	shr    $0xc,%eax
  1092bd:	83 c0 01             	add    $0x1,%eax
  1092c0:	c1 e0 0c             	shl    $0xc,%eax
  1092c3:	89 c2                	mov    %eax,%edx
  1092c5:	c1 ea 0c             	shr    $0xc,%edx
  1092c8:	8b 45 f4             	mov    -0xc(%ebp),%eax
  1092cb:	89 50 1c             	mov    %edx,0x1c(%eax)
      new->phys = malloc(sizeof(void*)*new->num_pages);
  1092ce:	8b 45 f4             	mov    -0xc(%ebp),%eax
  1092d1:	8b 40 1c             	mov    0x1c(%eax),%eax
  1092d4:	c1 e0 02             	shl    $0x2,%eax
  1092d7:	89 04 24             	mov    %eax,(%esp)
  1092da:	e8 8a 9c ff ff       	call   102f69 <malloc>
  1092df:	89 c2                	mov    %eax,%edx
  1092e1:	8b 45 f4             	mov    -0xc(%ebp),%eax
  1092e4:	89 50 20             	mov    %edx,0x20(%eax)
      for (i=0;i<new->num_pages;i++) new->phys[i] = memphys_alloc();
  1092e7:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
  1092ee:	eb 1a                	jmp    10930a <ipc_shm_create+0x129>
  1092f0:	8b 45 f4             	mov    -0xc(%ebp),%eax
  1092f3:	8b 50 20             	mov    0x20(%eax),%edx
  1092f6:	8b 45 f8             	mov    -0x8(%ebp),%eax
  1092f9:	c1 e0 02             	shl    $0x2,%eax
  1092fc:	8d 1c 02             	lea    (%edx,%eax,1),%ebx
  1092ff:	e8 b1 a1 ff ff       	call   1034b5 <memphys_pop>
  109304:	89 03                	mov    %eax,(%ebx)
  109306:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
  10930a:	8b 45 f4             	mov    -0xc(%ebp),%eax
  10930d:	8b 40 1c             	mov    0x1c(%eax),%eax
  109310:	3b 45 f8             	cmp    -0x8(%ebp),%eax
  109313:	77 db                	ja     1092f0 <ipc_shm_create+0x10f>
      new->atts = llist_create();
  109315:	e8 ba 15 00 00       	call   10a8d4 <llist_create>
  10931a:	89 c2                	mov    %eax,%edx
  10931c:	8b 45 f4             	mov    -0xc(%ebp),%eax
  10931f:	89 50 24             	mov    %edx,0x24(%eax)
      new->lopid = proc_current->pid;
  109322:	a1 a0 e1 10 00       	mov    0x10e1a0,%eax
  109327:	8b 10                	mov    (%eax),%edx
  109329:	8b 45 f4             	mov    -0xc(%ebp),%eax
  10932c:	89 50 28             	mov    %edx,0x28(%eax)
      llist_push(ipc_objects,new);
  10932f:	8b 15 90 e1 10 00    	mov    0x10e190,%edx
  109335:	8b 45 f4             	mov    -0xc(%ebp),%eax
  109338:	89 44 24 04          	mov    %eax,0x4(%esp)
  10933c:	89 14 24             	mov    %edx,(%esp)
  10933f:	e8 0b 16 00 00       	call   10a94f <llist_push>
      return new->ipc.id;
  109344:	8b 45 f4             	mov    -0xc(%ebp),%eax
  109347:	8b 40 04             	mov    0x4(%eax),%eax
  10934a:	89 45 e8             	mov    %eax,-0x18(%ebp)
  10934d:	eb 10                	jmp    10935f <ipc_shm_create+0x17e>
    }
    else return -ENOSPC;
  10934f:	c7 45 e8 cc ff ff ff 	movl   $0xffffffcc,-0x18(%ebp)
  109356:	eb 07                	jmp    10935f <ipc_shm_create+0x17e>
  }
  else return -EEXIST;
  109358:	c7 45 e8 ec ff ff ff 	movl   $0xffffffec,-0x18(%ebp)
  10935f:	8b 45 e8             	mov    -0x18(%ebp),%eax
}
  109362:	83 c4 24             	add    $0x24,%esp
  109365:	5b                   	pop    %ebx
  109366:	5d                   	pop    %ebp
  109367:	c3                   	ret    

00109368 <ipc_shm_attach>:
 *  @param id SHMID
 *  @param virt Virtual address to attatch to
 *  @param flags Flags
 *  @return Success?
 */
int ipc_shm_attach(id_t id,const void **addr,int flags,time_t time) {
  109368:	55                   	push   %ebp
  109369:	89 e5                	mov    %esp,%ebp
  10936b:	56                   	push   %esi
  10936c:	53                   	push   %ebx
  10936d:	83 ec 40             	sub    $0x40,%esp
  void *virt = (void*)*addr;
  109370:	8b 45 0c             	mov    0xc(%ebp),%eax
  109373:	8b 00                	mov    (%eax),%eax
  109375:	89 45 e8             	mov    %eax,-0x18(%ebp)
  if (virt>=(void*)USERDATA_ADDRESS || virt==NULL) {
  109378:	81 7d e8 ff ff ff 3f 	cmpl   $0x3fffffff,-0x18(%ebp)
  10937f:	77 0a                	ja     10938b <ipc_shm_attach+0x23>
  109381:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
  109385:	0f 85 7a 01 00 00    	jne    109505 <ipc_shm_attach+0x19d>
    ipc_shm_t *shm = ipc_shm_find(-1,id);
  10938b:	c7 44 24 08 04 00 00 	movl   $0x4,0x8(%esp)
  109392:	00 
  109393:	8b 45 08             	mov    0x8(%ebp),%eax
  109396:	89 44 24 04          	mov    %eax,0x4(%esp)
  10939a:	c7 04 24 ff ff ff ff 	movl   $0xffffffff,(%esp)
  1093a1:	e8 65 81 ff ff       	call   10150b <ipc_find>
  1093a6:	89 45 ec             	mov    %eax,-0x14(%ebp)
    if (shm!=NULL) {
  1093a9:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
  1093ad:	0f 84 52 01 00 00    	je     109505 <ipc_shm_attach+0x19d>
      ipc_shm_att_t *new = malloc(sizeof(ipc_shm_att_t));
  1093b3:	c7 04 24 10 00 00 00 	movl   $0x10,(%esp)
  1093ba:	e8 aa 9b ff ff       	call   102f69 <malloc>
  1093bf:	89 45 f0             	mov    %eax,-0x10(%ebp)
      if (new!=NULL) {
  1093c2:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
  1093c6:	0f 84 30 01 00 00    	je     1094fc <ipc_shm_attach+0x194>
        size_t i;
        new->shm = shm;
  1093cc:	8b 55 f0             	mov    -0x10(%ebp),%edx
  1093cf:	8b 45 ec             	mov    -0x14(%ebp),%eax
  1093d2:	89 02                	mov    %eax,(%edx)
        new->proc = proc_current;
  1093d4:	8b 15 a0 e1 10 00    	mov    0x10e1a0,%edx
  1093da:	8b 45 f0             	mov    -0x10(%ebp),%eax
  1093dd:	89 50 04             	mov    %edx,0x4(%eax)
        new->virt = virt==NULL?memuser_findvirt(proc_current->addrspace,shm->num_pages):(void*)virt;
  1093e0:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
  1093e4:	75 1f                	jne    109405 <ipc_shm_attach+0x9d>
  1093e6:	8b 45 ec             	mov    -0x14(%ebp),%eax
  1093e9:	8b 50 1c             	mov    0x1c(%eax),%edx
  1093ec:	a1 a0 e1 10 00       	mov    0x10e1a0,%eax
  1093f1:	8b 40 6c             	mov    0x6c(%eax),%eax
  1093f4:	89 54 24 04          	mov    %edx,0x4(%esp)
  1093f8:	89 04 24             	mov    %eax,(%esp)
  1093fb:	e8 3b a4 ff ff       	call   10383b <memuser_findvirt>
  109400:	89 45 e0             	mov    %eax,-0x20(%ebp)
  109403:	eb 06                	jmp    10940b <ipc_shm_attach+0xa3>
  109405:	8b 45 e8             	mov    -0x18(%ebp),%eax
  109408:	89 45 e0             	mov    %eax,-0x20(%ebp)
  10940b:	8b 45 f0             	mov    -0x10(%ebp),%eax
  10940e:	8b 55 e0             	mov    -0x20(%ebp),%edx
  109411:	89 50 08             	mov    %edx,0x8(%eax)
        new->readonly = flags&SHM_RDONLY;
  109414:	8b 45 10             	mov    0x10(%ebp),%eax
  109417:	89 c2                	mov    %eax,%edx
  109419:	81 e2 00 60 01 00    	and    $0x16000,%edx
  10941f:	8b 45 f0             	mov    -0x10(%ebp),%eax
  109422:	89 50 0c             	mov    %edx,0xc(%eax)
        if (virt==NULL) virt = memuser_findvirt(proc_current->addrspace,shm->num_pages);
  109425:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
  109429:	75 1d                	jne    109448 <ipc_shm_attach+0xe0>
  10942b:	8b 45 ec             	mov    -0x14(%ebp),%eax
  10942e:	8b 50 1c             	mov    0x1c(%eax),%edx
  109431:	a1 a0 e1 10 00       	mov    0x10e1a0,%eax
  109436:	8b 40 6c             	mov    0x6c(%eax),%eax
  109439:	89 54 24 04          	mov    %edx,0x4(%esp)
  10943d:	89 04 24             	mov    %eax,(%esp)
  109440:	e8 f6 a3 ff ff       	call   10383b <memuser_findvirt>
  109445:	89 45 e8             	mov    %eax,-0x18(%ebp)
        for (i=0;i<shm->num_pages;i++) paging_map(new->virt+i*PAGE_SIZE,shm->phys[i],1,!new->readonly);
  109448:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  10944f:	eb 64                	jmp    1094b5 <ipc_shm_attach+0x14d>
  109451:	8b 0d 74 e4 10 00    	mov    0x10e474,%ecx
  109457:	8b 45 f0             	mov    -0x10(%ebp),%eax
  10945a:	8b 40 0c             	mov    0xc(%eax),%eax
  10945d:	85 c0                	test   %eax,%eax
  10945f:	0f 94 c0             	sete   %al
  109462:	0f b6 d8             	movzbl %al,%ebx
  109465:	8b 45 ec             	mov    -0x14(%ebp),%eax
  109468:	8b 50 20             	mov    0x20(%eax),%edx
  10946b:	8b 45 f4             	mov    -0xc(%ebp),%eax
  10946e:	c1 e0 02             	shl    $0x2,%eax
  109471:	8d 04 02             	lea    (%edx,%eax,1),%eax
  109474:	8b 30                	mov    (%eax),%esi
  109476:	8b 45 f0             	mov    -0x10(%ebp),%eax
  109479:	8b 50 08             	mov    0x8(%eax),%edx
  10947c:	8b 45 f4             	mov    -0xc(%ebp),%eax
  10947f:	c1 e0 0c             	shl    $0xc,%eax
  109482:	8d 04 02             	lea    (%edx,%eax,1),%eax
  109485:	89 4c 24 18          	mov    %ecx,0x18(%esp)
  109489:	c7 44 24 14 00 00 00 	movl   $0x0,0x14(%esp)
  109490:	00 
  109491:	c7 44 24 10 00 00 00 	movl   $0x0,0x10(%esp)
  109498:	00 
  109499:	89 5c 24 0c          	mov    %ebx,0xc(%esp)
  10949d:	c7 44 24 08 01 00 00 	movl   $0x1,0x8(%esp)
  1094a4:	00 
  1094a5:	89 74 24 04          	mov    %esi,0x4(%esp)
  1094a9:	89 04 24             	mov    %eax,(%esp)
  1094ac:	e8 8c c3 ff ff       	call   10583d <paging_map_pd>
  1094b1:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
  1094b5:	8b 45 ec             	mov    -0x14(%ebp),%eax
  1094b8:	8b 40 1c             	mov    0x1c(%eax),%eax
  1094bb:	3b 45 f4             	cmp    -0xc(%ebp),%eax
  1094be:	77 91                	ja     109451 <ipc_shm_attach+0xe9>
        llist_push(shm->atts,new);
  1094c0:	8b 45 ec             	mov    -0x14(%ebp),%eax
  1094c3:	8b 50 24             	mov    0x24(%eax),%edx
  1094c6:	8b 45 f0             	mov    -0x10(%ebp),%eax
  1094c9:	89 44 24 04          	mov    %eax,0x4(%esp)
  1094cd:	89 14 24             	mov    %edx,(%esp)
  1094d0:	e8 7a 14 00 00       	call   10a94f <llist_push>
        shm->atime = time;
  1094d5:	8b 55 ec             	mov    -0x14(%ebp),%edx
  1094d8:	8b 45 14             	mov    0x14(%ebp),%eax
  1094db:	89 42 2c             	mov    %eax,0x2c(%edx)
        shm->lopid = proc_current->pid;
  1094de:	a1 a0 e1 10 00       	mov    0x10e1a0,%eax
  1094e3:	8b 10                	mov    (%eax),%edx
  1094e5:	8b 45 ec             	mov    -0x14(%ebp),%eax
  1094e8:	89 50 28             	mov    %edx,0x28(%eax)
        *addr = virt;
  1094eb:	8b 55 0c             	mov    0xc(%ebp),%edx
  1094ee:	8b 45 e8             	mov    -0x18(%ebp),%eax
  1094f1:	89 02                	mov    %eax,(%edx)
        return 0;
  1094f3:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
  1094fa:	eb 10                	jmp    10950c <ipc_shm_attach+0x1a4>
      }
      else return -ENOSPC;
  1094fc:	c7 45 e4 cc ff ff ff 	movl   $0xffffffcc,-0x1c(%ebp)
  109503:	eb 07                	jmp    10950c <ipc_shm_attach+0x1a4>
    }
  }
  return -EINVAL;
  109505:	c7 45 e4 e4 ff ff ff 	movl   $0xffffffe4,-0x1c(%ebp)
  10950c:	8b 45 e4             	mov    -0x1c(%ebp),%eax
}
  10950f:	83 c4 40             	add    $0x40,%esp
  109512:	5b                   	pop    %ebx
  109513:	5e                   	pop    %esi
  109514:	5d                   	pop    %ebp
  109515:	c3                   	ret    

00109516 <ipc_shm_detach>:
/**
 * Detaches process form shared memory object (Syscall)
 *  @param virt Virtual address to detach from
 *  @return Success?
 */
int ipc_shm_detach(const void *virt,time_t time) {
  109516:	55                   	push   %ebp
  109517:	89 e5                	mov    %esp,%ebp
  109519:	83 ec 38             	sub    $0x38,%esp
  size_t i,j,k;
  ipc_shm_t *shm;
  ipc_shm_att_t *att;
  if (virt<(void*)USERDATA_ADDRESS) return -1;
  10951c:	81 7d 08 ff ff ff 3f 	cmpl   $0x3fffffff,0x8(%ebp)
  109523:	77 0c                	ja     109531 <ipc_shm_detach+0x1b>
  109525:	c7 45 dc ff ff ff ff 	movl   $0xffffffff,-0x24(%ebp)
  10952c:	e9 00 01 00 00       	jmp    109631 <ipc_shm_detach+0x11b>
  for (i=0;(shm = llist_get(ipc_objects,i));i++) {
  109531:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
  109538:	e9 cc 00 00 00       	jmp    109609 <ipc_shm_detach+0xf3>
    if (shm->ipc.type==IPC_SHM) {
  10953d:	8b 45 f8             	mov    -0x8(%ebp),%eax
  109540:	8b 00                	mov    (%eax),%eax
  109542:	83 f8 04             	cmp    $0x4,%eax
  109545:	0f 85 ba 00 00 00    	jne    109605 <ipc_shm_detach+0xef>
      for (j=0;(att = llist_get(shm->atts,j));j++) {
  10954b:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
  109552:	e9 8c 00 00 00       	jmp    1095e3 <ipc_shm_detach+0xcd>
        if (att->proc==proc_current && att->virt==virt) {
  109557:	8b 45 fc             	mov    -0x4(%ebp),%eax
  10955a:	8b 50 04             	mov    0x4(%eax),%edx
  10955d:	a1 a0 e1 10 00       	mov    0x10e1a0,%eax
  109562:	39 c2                	cmp    %eax,%edx
  109564:	75 79                	jne    1095df <ipc_shm_detach+0xc9>
  109566:	8b 45 fc             	mov    -0x4(%ebp),%eax
  109569:	8b 40 08             	mov    0x8(%eax),%eax
  10956c:	3b 45 08             	cmp    0x8(%ebp),%eax
  10956f:	75 6e                	jne    1095df <ipc_shm_detach+0xc9>
          for (k=0;k<shm->num_pages;k++) paging_unmap(att->virt+k*PAGE_SIZE);
  109571:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  109578:	eb 1b                	jmp    109595 <ipc_shm_detach+0x7f>
  10957a:	8b 45 fc             	mov    -0x4(%ebp),%eax
  10957d:	8b 50 08             	mov    0x8(%eax),%edx
  109580:	8b 45 f4             	mov    -0xc(%ebp),%eax
  109583:	c1 e0 0c             	shl    $0xc,%eax
  109586:	8d 04 02             	lea    (%edx,%eax,1),%eax
  109589:	89 04 24             	mov    %eax,(%esp)
  10958c:	e8 c6 c4 ff ff       	call   105a57 <paging_unmap>
  109591:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
  109595:	8b 45 f8             	mov    -0x8(%ebp),%eax
  109598:	8b 40 1c             	mov    0x1c(%eax),%eax
  10959b:	3b 45 f4             	cmp    -0xc(%ebp),%eax
  10959e:	77 da                	ja     10957a <ipc_shm_detach+0x64>
          llist_remove(shm->atts,j);
  1095a0:	8b 45 f8             	mov    -0x8(%ebp),%eax
  1095a3:	8b 50 24             	mov    0x24(%eax),%edx
  1095a6:	8b 45 f0             	mov    -0x10(%ebp),%eax
  1095a9:	89 44 24 04          	mov    %eax,0x4(%esp)
  1095ad:	89 14 24             	mov    %edx,(%esp)
  1095b0:	e8 a4 15 00 00       	call   10ab59 <llist_remove>
          free(att);
  1095b5:	8b 45 fc             	mov    -0x4(%ebp),%eax
  1095b8:	89 04 24             	mov    %eax,(%esp)
  1095bb:	e8 dd 99 ff ff       	call   102f9d <free>
          shm->atime = time;
  1095c0:	8b 55 f8             	mov    -0x8(%ebp),%edx
  1095c3:	8b 45 0c             	mov    0xc(%ebp),%eax
  1095c6:	89 42 2c             	mov    %eax,0x2c(%edx)
          shm->lopid = proc_current->pid;
  1095c9:	a1 a0 e1 10 00       	mov    0x10e1a0,%eax
  1095ce:	8b 10                	mov    (%eax),%edx
  1095d0:	8b 45 f8             	mov    -0x8(%ebp),%eax
  1095d3:	89 50 28             	mov    %edx,0x28(%eax)
          return 0;
  1095d6:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
  1095dd:	eb 52                	jmp    109631 <ipc_shm_detach+0x11b>
  ipc_shm_t *shm;
  ipc_shm_att_t *att;
  if (virt<(void*)USERDATA_ADDRESS) return -1;
  for (i=0;(shm = llist_get(ipc_objects,i));i++) {
    if (shm->ipc.type==IPC_SHM) {
      for (j=0;(att = llist_get(shm->atts,j));j++) {
  1095df:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
  1095e3:	8b 45 f8             	mov    -0x8(%ebp),%eax
  1095e6:	8b 50 24             	mov    0x24(%eax),%edx
  1095e9:	8b 45 f0             	mov    -0x10(%ebp),%eax
  1095ec:	89 44 24 04          	mov    %eax,0x4(%esp)
  1095f0:	89 14 24             	mov    %edx,(%esp)
  1095f3:	e8 8f 14 00 00       	call   10aa87 <llist_get>
  1095f8:	89 45 fc             	mov    %eax,-0x4(%ebp)
  1095fb:	83 7d fc 00          	cmpl   $0x0,-0x4(%ebp)
  1095ff:	0f 85 52 ff ff ff    	jne    109557 <ipc_shm_detach+0x41>
int ipc_shm_detach(const void *virt,time_t time) {
  size_t i,j,k;
  ipc_shm_t *shm;
  ipc_shm_att_t *att;
  if (virt<(void*)USERDATA_ADDRESS) return -1;
  for (i=0;(shm = llist_get(ipc_objects,i));i++) {
  109605:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
  109609:	a1 90 e1 10 00       	mov    0x10e190,%eax
  10960e:	8b 55 ec             	mov    -0x14(%ebp),%edx
  109611:	89 54 24 04          	mov    %edx,0x4(%esp)
  109615:	89 04 24             	mov    %eax,(%esp)
  109618:	e8 6a 14 00 00       	call   10aa87 <llist_get>
  10961d:	89 45 f8             	mov    %eax,-0x8(%ebp)
  109620:	83 7d f8 00          	cmpl   $0x0,-0x8(%ebp)
  109624:	0f 85 13 ff ff ff    	jne    10953d <ipc_shm_detach+0x27>
          return 0;
        }
      }
    }
  }
  return -EINVAL;
  10962a:	c7 45 dc e4 ff ff ff 	movl   $0xffffffe4,-0x24(%ebp)
  109631:	8b 45 dc             	mov    -0x24(%ebp),%eax
}
  109634:	c9                   	leave  
  109635:	c3                   	ret    

00109636 <ipc_shm_stat>:

int ipc_shm_stat(id_t id,uid_t *uid,gid_t *gid,uid_t *cuid,gid_t *cgid,mode_t *mode,size_t *segsz,pid_t *lpid,pid_t *cpid,size_t *nattch,time_t *atime,time_t *dtime,time_t *ctime) {
  109636:	55                   	push   %ebp
  109637:	89 e5                	mov    %esp,%ebp
  109639:	56                   	push   %esi
  10963a:	53                   	push   %ebx
  10963b:	83 ec 30             	sub    $0x30,%esp
  ipc_shm_t *shm = ipc_shm_find(-1,id);
  10963e:	c7 44 24 08 04 00 00 	movl   $0x4,0x8(%esp)
  109645:	00 
  109646:	8b 45 08             	mov    0x8(%ebp),%eax
  109649:	89 44 24 04          	mov    %eax,0x4(%esp)
  10964d:	c7 04 24 ff ff ff ff 	movl   $0xffffffff,(%esp)
  109654:	e8 b2 7e ff ff       	call   10150b <ipc_find>
  109659:	89 45 f4             	mov    %eax,-0xc(%ebp)
  if (shm!=NULL) {
  10965c:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
  109660:	0f 84 12 01 00 00    	je     109778 <ipc_shm_stat+0x142>
    if (ipc_shm_permcheck(shm,PERM_R)) {
  109666:	8b 45 f4             	mov    -0xc(%ebp),%eax
  109669:	8b 58 14             	mov    0x14(%eax),%ebx
  10966c:	a1 a0 e1 10 00       	mov    0x10e1a0,%eax
  109671:	8b 70 10             	mov    0x10(%eax),%esi
  109674:	a1 a0 e1 10 00       	mov    0x10e1a0,%eax
  109679:	8b 50 04             	mov    0x4(%eax),%edx
  10967c:	8b 45 f4             	mov    -0xc(%ebp),%eax
  10967f:	8b 40 0c             	mov    0xc(%eax),%eax
  109682:	8b 48 10             	mov    0x10(%eax),%ecx
  109685:	8b 45 f4             	mov    -0xc(%ebp),%eax
  109688:	8b 40 0c             	mov    0xc(%eax),%eax
  10968b:	8b 00                	mov    (%eax),%eax
  10968d:	c7 44 24 14 01 00 00 	movl   $0x1,0x14(%esp)
  109694:	00 
  109695:	89 5c 24 10          	mov    %ebx,0x10(%esp)
  109699:	89 74 24 0c          	mov    %esi,0xc(%esp)
  10969d:	89 54 24 08          	mov    %edx,0x8(%esp)
  1096a1:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  1096a5:	89 04 24             	mov    %eax,(%esp)
  1096a8:	e8 87 17 00 00       	call   10ae34 <perm_check>
  1096ad:	85 c0                	test   %eax,%eax
  1096af:	75 19                	jne    1096ca <ipc_shm_stat+0x94>
  1096b1:	a1 a0 e1 10 00       	mov    0x10e1a0,%eax
  1096b6:	8b 50 04             	mov    0x4(%eax),%edx
  1096b9:	8b 45 f4             	mov    -0xc(%ebp),%eax
  1096bc:	8b 40 10             	mov    0x10(%eax),%eax
  1096bf:	8b 40 04             	mov    0x4(%eax),%eax
  1096c2:	39 c2                	cmp    %eax,%edx
  1096c4:	0f 85 a5 00 00 00    	jne    10976f <ipc_shm_stat+0x139>
      *uid = shm->ipc.owner->uid;
  1096ca:	8b 45 f4             	mov    -0xc(%ebp),%eax
  1096cd:	8b 40 0c             	mov    0xc(%eax),%eax
  1096d0:	8b 50 04             	mov    0x4(%eax),%edx
  1096d3:	8b 45 0c             	mov    0xc(%ebp),%eax
  1096d6:	89 10                	mov    %edx,(%eax)
      *gid = shm->ipc.owner->gid;
  1096d8:	8b 45 f4             	mov    -0xc(%ebp),%eax
  1096db:	8b 40 0c             	mov    0xc(%eax),%eax
  1096de:	8b 50 10             	mov    0x10(%eax),%edx
  1096e1:	8b 45 10             	mov    0x10(%ebp),%eax
  1096e4:	89 10                	mov    %edx,(%eax)
      *cuid = shm->ipc.creator->uid;
  1096e6:	8b 45 f4             	mov    -0xc(%ebp),%eax
  1096e9:	8b 40 10             	mov    0x10(%eax),%eax
  1096ec:	8b 50 04             	mov    0x4(%eax),%edx
  1096ef:	8b 45 14             	mov    0x14(%ebp),%eax
  1096f2:	89 10                	mov    %edx,(%eax)
      *cgid = shm->ipc.creator->gid;
  1096f4:	8b 45 f4             	mov    -0xc(%ebp),%eax
  1096f7:	8b 40 10             	mov    0x10(%eax),%eax
  1096fa:	8b 50 10             	mov    0x10(%eax),%edx
  1096fd:	8b 45 18             	mov    0x18(%ebp),%eax
  109700:	89 10                	mov    %edx,(%eax)
      *cpid = shm->ipc.creator->pid;
  109702:	8b 45 f4             	mov    -0xc(%ebp),%eax
  109705:	8b 40 10             	mov    0x10(%eax),%eax
  109708:	8b 10                	mov    (%eax),%edx
  10970a:	8b 45 28             	mov    0x28(%ebp),%eax
  10970d:	89 10                	mov    %edx,(%eax)
      *mode = shm->ipc.mode;
  10970f:	8b 45 f4             	mov    -0xc(%ebp),%eax
  109712:	8b 50 14             	mov    0x14(%eax),%edx
  109715:	8b 45 1c             	mov    0x1c(%ebp),%eax
  109718:	89 10                	mov    %edx,(%eax)
      *segsz = shm->size;
  10971a:	8b 45 f4             	mov    -0xc(%ebp),%eax
  10971d:	8b 50 18             	mov    0x18(%eax),%edx
  109720:	8b 45 20             	mov    0x20(%ebp),%eax
  109723:	89 10                	mov    %edx,(%eax)
      *lpid = shm->lopid;
  109725:	8b 45 f4             	mov    -0xc(%ebp),%eax
  109728:	8b 50 28             	mov    0x28(%eax),%edx
  10972b:	8b 45 24             	mov    0x24(%ebp),%eax
  10972e:	89 10                	mov    %edx,(%eax)
      *nattch = llist_size(shm->atts);
  109730:	8b 45 f4             	mov    -0xc(%ebp),%eax
  109733:	8b 40 24             	mov    0x24(%eax),%eax
  109736:	89 04 24             	mov    %eax,(%esp)
  109739:	e8 e5 11 00 00       	call   10a923 <llist_size>
  10973e:	89 c2                	mov    %eax,%edx
  109740:	8b 45 2c             	mov    0x2c(%ebp),%eax
  109743:	89 10                	mov    %edx,(%eax)
      *atime = shm->atime;
  109745:	8b 45 f4             	mov    -0xc(%ebp),%eax
  109748:	8b 50 2c             	mov    0x2c(%eax),%edx
  10974b:	8b 45 30             	mov    0x30(%ebp),%eax
  10974e:	89 10                	mov    %edx,(%eax)
      *dtime = shm->dtime;
  109750:	8b 45 f4             	mov    -0xc(%ebp),%eax
  109753:	8b 50 30             	mov    0x30(%eax),%edx
  109756:	8b 45 34             	mov    0x34(%ebp),%eax
  109759:	89 10                	mov    %edx,(%eax)
      *ctime = shm->ctime;
  10975b:	8b 45 f4             	mov    -0xc(%ebp),%eax
  10975e:	8b 50 34             	mov    0x34(%eax),%edx
  109761:	8b 45 38             	mov    0x38(%ebp),%eax
  109764:	89 10                	mov    %edx,(%eax)
      return 0;
  109766:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
  10976d:	eb 10                	jmp    10977f <ipc_shm_stat+0x149>
    }
    else return -EACCES;
  10976f:	c7 45 e4 fe ff ff ff 	movl   $0xfffffffe,-0x1c(%ebp)
  109776:	eb 07                	jmp    10977f <ipc_shm_stat+0x149>
  }
  return -EINVAL;
  109778:	c7 45 e4 e4 ff ff ff 	movl   $0xffffffe4,-0x1c(%ebp)
  10977f:	8b 45 e4             	mov    -0x1c(%ebp),%eax
}
  109782:	83 c4 30             	add    $0x30,%esp
  109785:	5b                   	pop    %ebx
  109786:	5e                   	pop    %esi
  109787:	5d                   	pop    %ebp
  109788:	c3                   	ret    

00109789 <ipc_shm_set>:

int ipc_shm_set(id_t id,uid_t uid,gid_t gid,mode_t mode,time_t time) {
  109789:	55                   	push   %ebp
  10978a:	89 e5                	mov    %esp,%ebp
  10978c:	56                   	push   %esi
  10978d:	53                   	push   %ebx
  10978e:	83 ec 30             	sub    $0x30,%esp
  ipc_shm_t *shm = ipc_shm_find(-1,id);
  109791:	c7 44 24 08 04 00 00 	movl   $0x4,0x8(%esp)
  109798:	00 
  109799:	8b 45 08             	mov    0x8(%ebp),%eax
  10979c:	89 44 24 04          	mov    %eax,0x4(%esp)
  1097a0:	c7 04 24 ff ff ff ff 	movl   $0xffffffff,(%esp)
  1097a7:	e8 5f 7d ff ff       	call   10150b <ipc_find>
  1097ac:	89 45 f4             	mov    %eax,-0xc(%ebp)
  if (shm!=NULL) {
  1097af:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
  1097b3:	0f 84 84 00 00 00    	je     10983d <ipc_shm_set+0xb4>
    if (ipc_shm_permcheck(shm,PERM_W)) {
  1097b9:	8b 45 f4             	mov    -0xc(%ebp),%eax
  1097bc:	8b 58 14             	mov    0x14(%eax),%ebx
  1097bf:	a1 a0 e1 10 00       	mov    0x10e1a0,%eax
  1097c4:	8b 70 10             	mov    0x10(%eax),%esi
  1097c7:	a1 a0 e1 10 00       	mov    0x10e1a0,%eax
  1097cc:	8b 50 04             	mov    0x4(%eax),%edx
  1097cf:	8b 45 f4             	mov    -0xc(%ebp),%eax
  1097d2:	8b 40 0c             	mov    0xc(%eax),%eax
  1097d5:	8b 48 10             	mov    0x10(%eax),%ecx
  1097d8:	8b 45 f4             	mov    -0xc(%ebp),%eax
  1097db:	8b 40 0c             	mov    0xc(%eax),%eax
  1097de:	8b 00                	mov    (%eax),%eax
  1097e0:	c7 44 24 14 02 00 00 	movl   $0x2,0x14(%esp)
  1097e7:	00 
  1097e8:	89 5c 24 10          	mov    %ebx,0x10(%esp)
  1097ec:	89 74 24 0c          	mov    %esi,0xc(%esp)
  1097f0:	89 54 24 08          	mov    %edx,0x8(%esp)
  1097f4:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  1097f8:	89 04 24             	mov    %eax,(%esp)
  1097fb:	e8 34 16 00 00       	call   10ae34 <perm_check>
  109800:	85 c0                	test   %eax,%eax
  109802:	75 15                	jne    109819 <ipc_shm_set+0x90>
  109804:	a1 a0 e1 10 00       	mov    0x10e1a0,%eax
  109809:	8b 50 04             	mov    0x4(%eax),%edx
  10980c:	8b 45 f4             	mov    -0xc(%ebp),%eax
  10980f:	8b 40 10             	mov    0x10(%eax),%eax
  109812:	8b 40 04             	mov    0x4(%eax),%eax
  109815:	39 c2                	cmp    %eax,%edx
  109817:	75 1b                	jne    109834 <ipc_shm_set+0xab>
      shm->ipc.mode = mode;
  109819:	8b 55 f4             	mov    -0xc(%ebp),%edx
  10981c:	8b 45 14             	mov    0x14(%ebp),%eax
  10981f:	89 42 14             	mov    %eax,0x14(%edx)
      shm->ctime = time;
  109822:	8b 55 f4             	mov    -0xc(%ebp),%edx
  109825:	8b 45 18             	mov    0x18(%ebp),%eax
  109828:	89 42 34             	mov    %eax,0x34(%edx)
      return 0;
  10982b:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
  109832:	eb 10                	jmp    109844 <ipc_shm_set+0xbb>
    }
    else return -EACCES;
  109834:	c7 45 e4 fe ff ff ff 	movl   $0xfffffffe,-0x1c(%ebp)
  10983b:	eb 07                	jmp    109844 <ipc_shm_set+0xbb>
  }
  return -EINVAL;
  10983d:	c7 45 e4 e4 ff ff ff 	movl   $0xffffffe4,-0x1c(%ebp)
  109844:	8b 45 e4             	mov    -0x1c(%ebp),%eax
}
  109847:	83 c4 30             	add    $0x30,%esp
  10984a:	5b                   	pop    %ebx
  10984b:	5e                   	pop    %esi
  10984c:	5d                   	pop    %ebp
  10984d:	c3                   	ret    

0010984e <ipc_shm_destroy>:
/**
 * Destroys a shared memory object
 *  @param id SHMID
 *  @return Success
 */
int ipc_shm_destroy(id_t id) {
  10984e:	55                   	push   %ebp
  10984f:	89 e5                	mov    %esp,%ebp
  109851:	83 ec 28             	sub    $0x28,%esp
  ipc_shm_t *shm = ipc_shm_find(-1,id);
  109854:	c7 44 24 08 04 00 00 	movl   $0x4,0x8(%esp)
  10985b:	00 
  10985c:	8b 45 08             	mov    0x8(%ebp),%eax
  10985f:	89 44 24 04          	mov    %eax,0x4(%esp)
  109863:	c7 04 24 ff ff ff ff 	movl   $0xffffffff,(%esp)
  10986a:	e8 9c 7c ff ff       	call   10150b <ipc_find>
  10986f:	89 45 f4             	mov    %eax,-0xc(%ebp)
  if (shm!=NULL) {
  109872:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
  109876:	0f 84 cd 00 00 00    	je     109949 <ipc_shm_destroy+0xfb>
  10987c:	eb 3a                	jmp    1098b8 <ipc_shm_destroy+0x6a>
    ipc_shm_att_t *att;
    size_t i;
    while ((att = llist_pop(shm->atts))) {
      for (i=0;i<shm->num_pages;i++) paging_unmap(att->virt+i*PAGE_SIZE);
  10987e:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
  109885:	eb 1b                	jmp    1098a2 <ipc_shm_destroy+0x54>
  109887:	8b 45 f8             	mov    -0x8(%ebp),%eax
  10988a:	8b 50 08             	mov    0x8(%eax),%edx
  10988d:	8b 45 fc             	mov    -0x4(%ebp),%eax
  109890:	c1 e0 0c             	shl    $0xc,%eax
  109893:	8d 04 02             	lea    (%edx,%eax,1),%eax
  109896:	89 04 24             	mov    %eax,(%esp)
  109899:	e8 b9 c1 ff ff       	call   105a57 <paging_unmap>
  10989e:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
  1098a2:	8b 45 f4             	mov    -0xc(%ebp),%eax
  1098a5:	8b 40 1c             	mov    0x1c(%eax),%eax
  1098a8:	3b 45 fc             	cmp    -0x4(%ebp),%eax
  1098ab:	77 da                	ja     109887 <ipc_shm_destroy+0x39>
      free(att);
  1098ad:	8b 45 f8             	mov    -0x8(%ebp),%eax
  1098b0:	89 04 24             	mov    %eax,(%esp)
  1098b3:	e8 e5 96 ff ff       	call   102f9d <free>
int ipc_shm_destroy(id_t id) {
  ipc_shm_t *shm = ipc_shm_find(-1,id);
  if (shm!=NULL) {
    ipc_shm_att_t *att;
    size_t i;
    while ((att = llist_pop(shm->atts))) {
  1098b8:	8b 45 f4             	mov    -0xc(%ebp),%eax
  1098bb:	8b 40 24             	mov    0x24(%eax),%eax
  1098be:	89 04 24             	mov    %eax,(%esp)
  1098c1:	e8 e2 10 00 00       	call   10a9a8 <llist_pop>
  1098c6:	89 45 f8             	mov    %eax,-0x8(%ebp)
  1098c9:	83 7d f8 00          	cmpl   $0x0,-0x8(%ebp)
  1098cd:	75 af                	jne    10987e <ipc_shm_destroy+0x30>
      for (i=0;i<shm->num_pages;i++) paging_unmap(att->virt+i*PAGE_SIZE);
      free(att);
    }
    for (i=0;i<shm->num_pages;i++) memphys_free(shm->phys[i]);
  1098cf:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
  1098d6:	eb 1d                	jmp    1098f5 <ipc_shm_destroy+0xa7>
  1098d8:	8b 45 f4             	mov    -0xc(%ebp),%eax
  1098db:	8b 50 20             	mov    0x20(%eax),%edx
  1098de:	8b 45 fc             	mov    -0x4(%ebp),%eax
  1098e1:	c1 e0 02             	shl    $0x2,%eax
  1098e4:	8d 04 02             	lea    (%edx,%eax,1),%eax
  1098e7:	8b 00                	mov    (%eax),%eax
  1098e9:	89 04 24             	mov    %eax,(%esp)
  1098ec:	e8 23 9b ff ff       	call   103414 <memphys_push>
  1098f1:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
  1098f5:	8b 45 f4             	mov    -0xc(%ebp),%eax
  1098f8:	8b 40 1c             	mov    0x1c(%eax),%eax
  1098fb:	3b 45 fc             	cmp    -0x4(%ebp),%eax
  1098fe:	77 d8                	ja     1098d8 <ipc_shm_destroy+0x8a>
    free(shm->phys);
  109900:	8b 45 f4             	mov    -0xc(%ebp),%eax
  109903:	8b 40 20             	mov    0x20(%eax),%eax
  109906:	89 04 24             	mov    %eax,(%esp)
  109909:	e8 8f 96 ff ff       	call   102f9d <free>
    free(shm);
  10990e:	8b 45 f4             	mov    -0xc(%ebp),%eax
  109911:	89 04 24             	mov    %eax,(%esp)
  109914:	e8 84 96 ff ff       	call   102f9d <free>
    llist_remove(ipc_objects,llist_find(ipc_objects,shm));
  109919:	8b 15 90 e1 10 00    	mov    0x10e190,%edx
  10991f:	8b 45 f4             	mov    -0xc(%ebp),%eax
  109922:	89 44 24 04          	mov    %eax,0x4(%esp)
  109926:	89 14 24             	mov    %edx,(%esp)
  109929:	e8 f3 12 00 00       	call   10ac21 <llist_find>
  10992e:	8b 15 90 e1 10 00    	mov    0x10e190,%edx
  109934:	89 44 24 04          	mov    %eax,0x4(%esp)
  109938:	89 14 24             	mov    %edx,(%esp)
  10993b:	e8 19 12 00 00       	call   10ab59 <llist_remove>
    return 0;
  109940:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
  109947:	eb 07                	jmp    109950 <ipc_shm_destroy+0x102>
  }
  return -1;
  109949:	c7 45 ec ff ff ff ff 	movl   $0xffffffff,-0x14(%ebp)
  109950:	8b 45 ec             	mov    -0x14(%ebp),%eax
}
  109953:	c9                   	leave  
  109954:	c3                   	ret    
  109955:	00 00                	add    %al,(%eax)
	...

00109958 <signal_init>:
#include <procm.h>
#include <syscall.h>
#include <debug.h>
#include <perm.h>

int signal_init() {
  109958:	55                   	push   %ebp
  109959:	89 e5                	mov    %esp,%ebp
  10995b:	83 ec 18             	sub    $0x18,%esp
  if (syscall_create(SYSCALL_SIG_SETUP,signal_setup,1)==-1) return -1;
  10995e:	c7 44 24 08 01 00 00 	movl   $0x1,0x8(%esp)
  109965:	00 
  109966:	c7 44 24 04 be 99 10 	movl   $0x1099be,0x4(%esp)
  10996d:	00 
  10996e:	c7 04 24 4c 00 00 00 	movl   $0x4c,(%esp)
  109975:	e8 c0 04 00 00       	call   109e3a <syscall_create>
  10997a:	83 f8 ff             	cmp    $0xffffffff,%eax
  10997d:	75 09                	jne    109988 <signal_init+0x30>
  10997f:	c7 45 fc ff ff ff ff 	movl   $0xffffffff,-0x4(%ebp)
  109986:	eb 31                	jmp    1099b9 <signal_init+0x61>
  if (syscall_create(SYSCALL_SIG_SEND,signal_send_syscall,2)==-1) return -1;
  109988:	c7 44 24 08 02 00 00 	movl   $0x2,0x8(%esp)
  10998f:	00 
  109990:	c7 44 24 04 1f 9a 10 	movl   $0x109a1f,0x4(%esp)
  109997:	00 
  109998:	c7 04 24 4d 00 00 00 	movl   $0x4d,(%esp)
  10999f:	e8 96 04 00 00       	call   109e3a <syscall_create>
  1099a4:	83 f8 ff             	cmp    $0xffffffff,%eax
  1099a7:	75 09                	jne    1099b2 <signal_init+0x5a>
  1099a9:	c7 45 fc ff ff ff ff 	movl   $0xffffffff,-0x4(%ebp)
  1099b0:	eb 07                	jmp    1099b9 <signal_init+0x61>
  return 0;
  1099b2:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
  1099b9:	8b 45 fc             	mov    -0x4(%ebp),%eax
}
  1099bc:	c9                   	leave  
  1099bd:	c3                   	ret    

001099be <signal_setup>:

void signal_setup(void (*handler)(int)) {
  1099be:	55                   	push   %ebp
  1099bf:	89 e5                	mov    %esp,%ebp
  proc_current->signal = handler;
  1099c1:	8b 15 a0 e1 10 00    	mov    0x10e1a0,%edx
  1099c7:	8b 45 08             	mov    0x8(%ebp),%eax
  1099ca:	89 82 8c 00 00 00    	mov    %eax,0x8c(%edx)
}
  1099d0:	5d                   	pop    %ebp
  1099d1:	c3                   	ret    

001099d2 <signal_send>:

void signal_send(proc_t *proc,int sig) {
  1099d2:	55                   	push   %ebp
  1099d3:	89 e5                	mov    %esp,%ebp
  1099d5:	83 ec 18             	sub    $0x18,%esp
  if (sig==SIGCONT) proc_wake(proc); // wake process even if it has no signal handler for it
  1099d8:	83 7d 0c 12          	cmpl   $0x12,0xc(%ebp)
  1099dc:	75 0b                	jne    1099e9 <signal_send+0x17>
  1099de:	8b 45 08             	mov    0x8(%ebp),%eax
  1099e1:	89 04 24             	mov    %eax,(%esp)
  1099e4:	e8 a4 cc ff ff       	call   10668d <proc_wake>
  if (proc->signal!=NULL) proc_call(proc,proc->signal,1,sig);
  1099e9:	8b 45 08             	mov    0x8(%ebp),%eax
  1099ec:	8b 80 8c 00 00 00    	mov    0x8c(%eax),%eax
  1099f2:	85 c0                	test   %eax,%eax
  1099f4:	74 27                	je     109a1d <signal_send+0x4b>
  1099f6:	8b 45 08             	mov    0x8(%ebp),%eax
  1099f9:	8b 90 8c 00 00 00    	mov    0x8c(%eax),%edx
  1099ff:	8b 45 0c             	mov    0xc(%ebp),%eax
  109a02:	89 44 24 0c          	mov    %eax,0xc(%esp)
  109a06:	c7 44 24 08 01 00 00 	movl   $0x1,0x8(%esp)
  109a0d:	00 
  109a0e:	89 54 24 04          	mov    %edx,0x4(%esp)
  109a12:	8b 45 08             	mov    0x8(%ebp),%eax
  109a15:	89 04 24             	mov    %eax,(%esp)
  109a18:	e8 a1 d5 ff ff       	call   106fbe <proc_call>
}
  109a1d:	c9                   	leave  
  109a1e:	c3                   	ret    

00109a1f <signal_send_syscall>:

void signal_send_syscall(pid_t pid,int sig) {
  109a1f:	55                   	push   %ebp
  109a20:	89 e5                	mov    %esp,%ebp
  109a22:	83 ec 18             	sub    $0x18,%esp
  proc_t *proc = proc_find(pid);
  109a25:	8b 45 08             	mov    0x8(%ebp),%eax
  109a28:	89 04 24             	mov    %eax,(%esp)
  109a2b:	e8 3f cb ff ff       	call   10656f <proc_find>
  109a30:	89 45 fc             	mov    %eax,-0x4(%ebp)
  if (proc!=NULL) {
  109a33:	83 7d fc 00          	cmpl   $0x0,-0x4(%ebp)
  109a37:	74 50                	je     109a89 <signal_send_syscall+0x6a>
    if (proc->uid==proc_current->uid || proc->gid==proc_current->gid || proc_current->uid==PERM_ROOTUID || proc_current->gid==PERM_ROOTGID) signal_send(proc,sig);
  109a39:	8b 45 fc             	mov    -0x4(%ebp),%eax
  109a3c:	8b 50 04             	mov    0x4(%eax),%edx
  109a3f:	a1 a0 e1 10 00       	mov    0x10e1a0,%eax
  109a44:	8b 40 04             	mov    0x4(%eax),%eax
  109a47:	39 c2                	cmp    %eax,%edx
  109a49:	74 2c                	je     109a77 <signal_send_syscall+0x58>
  109a4b:	8b 45 fc             	mov    -0x4(%ebp),%eax
  109a4e:	8b 50 10             	mov    0x10(%eax),%edx
  109a51:	a1 a0 e1 10 00       	mov    0x10e1a0,%eax
  109a56:	8b 40 10             	mov    0x10(%eax),%eax
  109a59:	39 c2                	cmp    %eax,%edx
  109a5b:	74 1a                	je     109a77 <signal_send_syscall+0x58>
  109a5d:	a1 a0 e1 10 00       	mov    0x10e1a0,%eax
  109a62:	8b 40 04             	mov    0x4(%eax),%eax
  109a65:	83 f8 01             	cmp    $0x1,%eax
  109a68:	74 0d                	je     109a77 <signal_send_syscall+0x58>
  109a6a:	a1 a0 e1 10 00       	mov    0x10e1a0,%eax
  109a6f:	8b 40 10             	mov    0x10(%eax),%eax
  109a72:	83 f8 01             	cmp    $0x1,%eax
  109a75:	75 12                	jne    109a89 <signal_send_syscall+0x6a>
  109a77:	8b 45 0c             	mov    0xc(%ebp),%eax
  109a7a:	89 44 24 04          	mov    %eax,0x4(%esp)
  109a7e:	8b 45 fc             	mov    -0x4(%ebp),%eax
  109a81:	89 04 24             	mov    %eax,(%esp)
  109a84:	e8 49 ff ff ff       	call   1099d2 <signal_send>
  }
}
  109a89:	c9                   	leave  
  109a8a:	c3                   	ret    
	...

00109a8c <swap_init>:

/**
 * Initializes swapping
 *  @return Success?
 */
int swap_init() {
  109a8c:	55                   	push   %ebp
  109a8d:	89 e5                	mov    %esp,%ebp
  swap_proc = NULL;
  109a8f:	c7 05 44 e9 10 00 00 	movl   $0x0,0x10e944
  109a96:	00 00 00 
  //if (syscall_create(SYSCALL_SWAP_ENABLE,swap_enable,1)==-1) return -1;
  return 0;
  109a99:	b8 00 00 00 00       	mov    $0x0,%eax
}
  109a9e:	5d                   	pop    %ebp
  109a9f:	c3                   	ret    

00109aa0 <swap_enable>:

/**
 * Enables swapping (Syscall)
 *  @return Success?
 */
int swap_enable(void *buf) {
  109aa0:	55                   	push   %ebp
  109aa1:	89 e5                	mov    %esp,%ebp
  109aa3:	83 ec 08             	sub    $0x8,%esp
  if (swap_proc!=NULL) return -1;
  109aa6:	a1 44 e9 10 00       	mov    0x10e944,%eax
  109aab:	85 c0                	test   %eax,%eax
  109aad:	74 09                	je     109ab8 <swap_enable+0x18>
  109aaf:	c7 45 fc ff ff ff ff 	movl   $0xffffffff,-0x4(%ebp)
  109ab6:	eb 23                	jmp    109adb <swap_enable+0x3b>
  swap_queue = llist_create();
  109ab8:	e8 17 0e 00 00       	call   10a8d4 <llist_create>
  109abd:	a3 4c e9 10 00       	mov    %eax,0x10e94c
  swap_proc = proc_current;
  109ac2:	a1 a0 e1 10 00       	mov    0x10e1a0,%eax
  109ac7:	a3 44 e9 10 00       	mov    %eax,0x10e944
  swap_buf = buf;
  109acc:	8b 45 08             	mov    0x8(%ebp),%eax
  109acf:	a3 48 e9 10 00       	mov    %eax,0x10e948
  return 0;
  109ad4:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
  109adb:	8b 45 fc             	mov    -0x4(%ebp),%eax
}
  109ade:	c9                   	leave  
  109adf:	c3                   	ret    

00109ae0 <swap_call>:
 *  @param op Operation
 *  @param proc Owner of page
 *  @param page Page
 *  @return Success?
 */
int swap_call(int op,proc_t *proc,void *page) {
  109ae0:	55                   	push   %ebp
  109ae1:	89 e5                	mov    %esp,%ebp
  109ae3:	83 ec 28             	sub    $0x28,%esp
  swap_call_t *new = malloc(sizeof(swap_call_t));
  109ae6:	c7 04 24 0c 00 00 00 	movl   $0xc,(%esp)
  109aed:	e8 77 94 ff ff       	call   102f69 <malloc>
  109af2:	89 45 fc             	mov    %eax,-0x4(%ebp)
  if (new!=NULL) {
  109af5:	83 7d fc 00          	cmpl   $0x0,-0x4(%ebp)
  109af9:	74 3a                	je     109b35 <swap_call+0x55>
    new->op = op;
  109afb:	8b 55 fc             	mov    -0x4(%ebp),%edx
  109afe:	8b 45 08             	mov    0x8(%ebp),%eax
  109b01:	89 02                	mov    %eax,(%edx)
    new->pid = proc->pid;
  109b03:	8b 45 0c             	mov    0xc(%ebp),%eax
  109b06:	8b 10                	mov    (%eax),%edx
  109b08:	8b 45 fc             	mov    -0x4(%ebp),%eax
  109b0b:	89 50 04             	mov    %edx,0x4(%eax)
    new->page = page;
  109b0e:	8b 55 fc             	mov    -0x4(%ebp),%edx
  109b11:	8b 45 10             	mov    0x10(%ebp),%eax
  109b14:	89 42 08             	mov    %eax,0x8(%edx)
    llist_push(swap_queue,new);
  109b17:	8b 15 4c e9 10 00    	mov    0x10e94c,%edx
  109b1d:	8b 45 fc             	mov    -0x4(%ebp),%eax
  109b20:	89 44 24 04          	mov    %eax,0x4(%esp)
  109b24:	89 14 24             	mov    %edx,(%esp)
  109b27:	e8 23 0e 00 00       	call   10a94f <llist_push>
    return 0;
  109b2c:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
  109b33:	eb 07                	jmp    109b3c <swap_call+0x5c>
  }
  else return -1;
  109b35:	c7 45 ec ff ff ff ff 	movl   $0xffffffff,-0x14(%ebp)
  109b3c:	8b 45 ec             	mov    -0x14(%ebp),%eax
}
  109b3f:	c9                   	leave  
  109b40:	c3                   	ret    

00109b41 <swap_in>:
/**
 * Swaps page in
 *  @param proc Onwer of page
 *  @param page Page to swap
 */
int swap_in(proc_t *proc,void *page) {
  109b41:	55                   	push   %ebp
  109b42:	89 e5                	mov    %esp,%ebp
  109b44:	83 ec 28             	sub    $0x28,%esp
  if (swap_proc!=NULL) {
  109b47:	a1 44 e9 10 00       	mov    0x10e944,%eax
  109b4c:	85 c0                	test   %eax,%eax
  109b4e:	0f 84 c0 00 00 00    	je     109c14 <swap_in+0xd3>
    pte_t pte = paging_getpte_pd(page,proc->addrspace->pagedir);
  109b54:	8b 45 08             	mov    0x8(%ebp),%eax
  109b57:	8b 40 6c             	mov    0x6c(%eax),%eax
  109b5a:	8b 40 10             	mov    0x10(%eax),%eax
  109b5d:	8d 55 f8             	lea    -0x8(%ebp),%edx
  109b60:	89 44 24 08          	mov    %eax,0x8(%esp)
  109b64:	8b 45 0c             	mov    0xc(%ebp),%eax
  109b67:	89 44 24 04          	mov    %eax,0x4(%esp)
  109b6b:	89 14 24             	mov    %edx,(%esp)
  109b6e:	e8 77 bb ff ff       	call   1056ea <paging_getpte_pd>
  109b73:	83 ec 04             	sub    $0x4,%esp
    if (!pte.in_memory && pte.swapped) {
  109b76:	0f b6 45 f8          	movzbl -0x8(%ebp),%eax
  109b7a:	83 e0 01             	and    $0x1,%eax
  109b7d:	84 c0                	test   %al,%al
  109b7f:	0f 85 8f 00 00 00    	jne    109c14 <swap_in+0xd3>
  109b85:	0f b6 45 f9          	movzbl -0x7(%ebp),%eax
  109b89:	83 e0 08             	and    $0x8,%eax
  109b8c:	84 c0                	test   %al,%al
  109b8e:	0f 84 80 00 00 00    	je     109c14 <swap_in+0xd3>
      memuser_load_addrspace(proc->addrspace);
  109b94:	8b 45 08             	mov    0x8(%ebp),%eax
  109b97:	8b 40 6c             	mov    0x6c(%eax),%eax
  109b9a:	89 04 24             	mov    %eax,(%esp)
  109b9d:	e8 79 a0 ff ff       	call   103c1b <memuser_load_addrspace>
      if (swap_call(SWAP_IN,proc,page)) {
  109ba2:	8b 45 0c             	mov    0xc(%ebp),%eax
  109ba5:	89 44 24 08          	mov    %eax,0x8(%esp)
  109ba9:	8b 45 08             	mov    0x8(%ebp),%eax
  109bac:	89 44 24 04          	mov    %eax,0x4(%esp)
  109bb0:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
  109bb7:	e8 24 ff ff ff       	call   109ae0 <swap_call>
  109bbc:	85 c0                	test   %eax,%eax
  109bbe:	74 54                	je     109c14 <swap_in+0xd3>
        void *phys = memphys_alloc();
  109bc0:	e8 f0 98 ff ff       	call   1034b5 <memphys_pop>
  109bc5:	89 45 fc             	mov    %eax,-0x4(%ebp)
        pte.page = ADDR2PAGE(phys);
  109bc8:	8b 45 fc             	mov    -0x4(%ebp),%eax
  109bcb:	c1 e8 0c             	shr    $0xc,%eax
  109bce:	25 ff ff 0f 00       	and    $0xfffff,%eax
  109bd3:	89 c2                	mov    %eax,%edx
  109bd5:	c1 e2 0c             	shl    $0xc,%edx
  109bd8:	8b 45 f8             	mov    -0x8(%ebp),%eax
  109bdb:	25 ff 0f 00 00       	and    $0xfff,%eax
  109be0:	09 d0                	or     %edx,%eax
  109be2:	89 45 f8             	mov    %eax,-0x8(%ebp)
        pte.in_memory = 1;
  109be5:	0f b6 45 f8          	movzbl -0x8(%ebp),%eax
  109be9:	83 c8 01             	or     $0x1,%eax
  109bec:	88 45 f8             	mov    %al,-0x8(%ebp)
        paging_physwrite(phys,swap_buf,PAGE_SIZE);
  109bef:	a1 48 e9 10 00       	mov    0x10e948,%eax
  109bf4:	c7 44 24 08 00 10 00 	movl   $0x1000,0x8(%esp)
  109bfb:	00 
  109bfc:	89 44 24 04          	mov    %eax,0x4(%esp)
  109c00:	8b 45 fc             	mov    -0x4(%ebp),%eax
  109c03:	89 04 24             	mov    %eax,(%esp)
  109c06:	e8 c5 b6 ff ff       	call   1052d0 <paging_physwrite>
        return 0;
  109c0b:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
  109c12:	eb 07                	jmp    109c1b <swap_in+0xda>
      }
    }
  }
  return -1;
  109c14:	c7 45 ec ff ff ff ff 	movl   $0xffffffff,-0x14(%ebp)
  109c1b:	8b 45 ec             	mov    -0x14(%ebp),%eax
}
  109c1e:	c9                   	leave  
  109c1f:	c3                   	ret    

00109c20 <swap_out>:
 * Swaps page out
 *  @param proc Owner of page
 *  @param page Page to swap
 *  @return Success?
 */
int swap_out(proc_t *proc,void *page) {
  109c20:	55                   	push   %ebp
  109c21:	89 e5                	mov    %esp,%ebp
  109c23:	83 ec 28             	sub    $0x28,%esp
  if (swap_proc!=NULL) {
  109c26:	a1 44 e9 10 00       	mov    0x10e944,%eax
  109c2b:	85 c0                	test   %eax,%eax
  109c2d:	0f 84 e7 00 00 00    	je     109d1a <swap_out+0xfa>
    pte_t pte = paging_getpte_pd(page,proc->addrspace->pagedir);
  109c33:	8b 45 08             	mov    0x8(%ebp),%eax
  109c36:	8b 40 6c             	mov    0x6c(%eax),%eax
  109c39:	8b 40 10             	mov    0x10(%eax),%eax
  109c3c:	8d 55 f8             	lea    -0x8(%ebp),%edx
  109c3f:	89 44 24 08          	mov    %eax,0x8(%esp)
  109c43:	8b 45 0c             	mov    0xc(%ebp),%eax
  109c46:	89 44 24 04          	mov    %eax,0x4(%esp)
  109c4a:	89 14 24             	mov    %edx,(%esp)
  109c4d:	e8 98 ba ff ff       	call   1056ea <paging_getpte_pd>
  109c52:	83 ec 04             	sub    $0x4,%esp
    if (pte.swappable) {
  109c55:	0f b6 45 f9          	movzbl -0x7(%ebp),%eax
  109c59:	83 e0 04             	and    $0x4,%eax
  109c5c:	84 c0                	test   %al,%al
  109c5e:	0f 84 b6 00 00 00    	je     109d1a <swap_out+0xfa>
      memuser_load_addrspace(proc->addrspace);
  109c64:	8b 45 08             	mov    0x8(%ebp),%eax
  109c67:	8b 40 6c             	mov    0x6c(%eax),%eax
  109c6a:	89 04 24             	mov    %eax,(%esp)
  109c6d:	e8 a9 9f ff ff       	call   103c1b <memuser_load_addrspace>
      void *phys = PAGE2ADDR(pte.page);
  109c72:	8b 45 f8             	mov    -0x8(%ebp),%eax
  109c75:	c1 e8 0c             	shr    $0xc,%eax
  109c78:	c1 e0 0c             	shl    $0xc,%eax
  109c7b:	89 45 fc             	mov    %eax,-0x4(%ebp)
      if (phys!=NULL && pte.in_memory) {
  109c7e:	83 7d fc 00          	cmpl   $0x0,-0x4(%ebp)
  109c82:	0f 84 92 00 00 00    	je     109d1a <swap_out+0xfa>
  109c88:	0f b6 45 f8          	movzbl -0x8(%ebp),%eax
  109c8c:	83 e0 01             	and    $0x1,%eax
  109c8f:	84 c0                	test   %al,%al
  109c91:	0f 84 83 00 00 00    	je     109d1a <swap_out+0xfa>
        paging_physread(swap_buf,phys,PAGE_SIZE);
  109c97:	8b 15 48 e9 10 00    	mov    0x10e948,%edx
  109c9d:	c7 44 24 08 00 10 00 	movl   $0x1000,0x8(%esp)
  109ca4:	00 
  109ca5:	8b 45 fc             	mov    -0x4(%ebp),%eax
  109ca8:	89 44 24 04          	mov    %eax,0x4(%esp)
  109cac:	89 14 24             	mov    %edx,(%esp)
  109caf:	e8 67 b5 ff ff       	call   10521b <paging_physread>
        if (swap_call(SWAP_OUT,proc,page)!=-1) {
  109cb4:	8b 45 0c             	mov    0xc(%ebp),%eax
  109cb7:	89 44 24 08          	mov    %eax,0x8(%esp)
  109cbb:	8b 45 08             	mov    0x8(%ebp),%eax
  109cbe:	89 44 24 04          	mov    %eax,0x4(%esp)
  109cc2:	c7 04 24 02 00 00 00 	movl   $0x2,(%esp)
  109cc9:	e8 12 fe ff ff       	call   109ae0 <swap_call>
  109cce:	83 f8 ff             	cmp    $0xffffffff,%eax
  109cd1:	74 47                	je     109d1a <swap_out+0xfa>
          pte.in_memory = 0;
  109cd3:	0f b6 45 f8          	movzbl -0x8(%ebp),%eax
  109cd7:	83 e0 fe             	and    $0xfffffffe,%eax
  109cda:	88 45 f8             	mov    %al,-0x8(%ebp)
          pte.swapped = 1;
  109cdd:	0f b6 45 f9          	movzbl -0x7(%ebp),%eax
  109ce1:	83 c8 08             	or     $0x8,%eax
  109ce4:	88 45 f9             	mov    %al,-0x7(%ebp)
          memphys_free(page);
  109ce7:	8b 45 0c             	mov    0xc(%ebp),%eax
  109cea:	89 04 24             	mov    %eax,(%esp)
  109ced:	e8 22 97 ff ff       	call   103414 <memphys_push>
          paging_setpte_pd(page,pte,proc->addrspace->pagedir);
  109cf2:	8b 45 08             	mov    0x8(%ebp),%eax
  109cf5:	8b 40 6c             	mov    0x6c(%eax),%eax
  109cf8:	8b 40 10             	mov    0x10(%eax),%eax
  109cfb:	89 44 24 08          	mov    %eax,0x8(%esp)
  109cff:	8b 45 f8             	mov    -0x8(%ebp),%eax
  109d02:	89 44 24 04          	mov    %eax,0x4(%esp)
  109d06:	8b 45 0c             	mov    0xc(%ebp),%eax
  109d09:	89 04 24             	mov    %eax,(%esp)
  109d0c:	e8 82 ba ff ff       	call   105793 <paging_setpte_pd>
          return 0;
  109d11:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
  109d18:	eb 07                	jmp    109d21 <swap_out+0x101>
        }
      }
    }
  }
  return -1;
  109d1a:	c7 45 ec ff ff ff ff 	movl   $0xffffffff,-0x14(%ebp)
  109d21:	8b 45 ec             	mov    -0x14(%ebp),%eax
}
  109d24:	c9                   	leave  
  109d25:	c3                   	ret    

00109d26 <swap_remove>:
 * Removes a page from swap
 *  @param proc Owner of page
 *  @param page Page
 *  @return Success?
 */
int swap_remove(proc_t *proc,void *page) {
  109d26:	55                   	push   %ebp
  109d27:	89 e5                	mov    %esp,%ebp
  109d29:	83 ec 18             	sub    $0x18,%esp
  if (swap_proc!=NULL) return swap_call(SWAP_REM,proc,page);
  109d2c:	a1 44 e9 10 00       	mov    0x10e944,%eax
  109d31:	85 c0                	test   %eax,%eax
  109d33:	74 1f                	je     109d54 <swap_remove+0x2e>
  109d35:	8b 45 0c             	mov    0xc(%ebp),%eax
  109d38:	89 44 24 08          	mov    %eax,0x8(%esp)
  109d3c:	8b 45 08             	mov    0x8(%ebp),%eax
  109d3f:	89 44 24 04          	mov    %eax,0x4(%esp)
  109d43:	c7 04 24 03 00 00 00 	movl   $0x3,(%esp)
  109d4a:	e8 91 fd ff ff       	call   109ae0 <swap_call>
  109d4f:	89 45 fc             	mov    %eax,-0x4(%ebp)
  109d52:	eb 07                	jmp    109d5b <swap_remove+0x35>
  else return -1;
  109d54:	c7 45 fc ff ff ff ff 	movl   $0xffffffff,-0x4(%ebp)
  109d5b:	8b 45 fc             	mov    -0x4(%ebp),%eax
}
  109d5e:	c9                   	leave  
  109d5f:	c3                   	ret    

00109d60 <syscall_init>:

/**
 * Initializes Syscall Management
 *  @return 0=Success; -1=Failure
 */
int syscall_init() {
  109d60:	55                   	push   %ebp
  109d61:	89 e5                	mov    %esp,%ebp
  109d63:	83 ec 18             	sub    $0x18,%esp
  memset(&syscalls,0,SYSCALL_MAXNUM*sizeof(struct syscall));
  109d66:	c7 44 24 08 88 02 00 	movl   $0x288,0x8(%esp)
  109d6d:	00 
  109d6e:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  109d75:	00 
  109d76:	c7 04 24 c0 e1 10 00 	movl   $0x10e1c0,(%esp)
  109d7d:	e8 df 1f 00 00       	call   10bd61 <memset>
  return 0;
  109d82:	b8 00 00 00 00       	mov    $0x0,%eax
}
  109d87:	c9                   	leave  
  109d88:	c3                   	ret    

00109d89 <syscall_handler>:

/**
 * Syscall handler
 *  @param params Pointer to parameter list
 */
void syscall_handler(uint32_t *stack) {
  109d89:	55                   	push   %ebp
  109d8a:	89 e5                	mov    %esp,%ebp
  109d8c:	83 ec 28             	sub    $0x28,%esp
  proc_t *proc_call = proc_current;
  109d8f:	a1 a0 e1 10 00       	mov    0x10e1a0,%eax
  109d94:	89 45 f0             	mov    %eax,-0x10(%ebp)
  int res = -1;
  109d97:	c7 45 f4 ff ff ff ff 	movl   $0xffffffff,-0xc(%ebp)
  interrupt_save_stack(stack,NULL);
  109d9e:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  109da5:	00 
  109da6:	8b 45 08             	mov    0x8(%ebp),%eax
  109da9:	89 04 24             	mov    %eax,(%esp)
  109dac:	e8 56 75 ff ff       	call   101307 <interrupt_save_stack>
  int cmd = ((int*)*interrupt_curregs.esp)[0];
  109db1:	a1 3c e7 10 00       	mov    0x10e73c,%eax
  109db6:	8b 00                	mov    (%eax),%eax
  109db8:	8b 00                	mov    (%eax),%eax
  109dba:	89 45 f8             	mov    %eax,-0x8(%ebp)
  int *params = ((void**)*interrupt_curregs.esp)[1];
  109dbd:	a1 3c e7 10 00       	mov    0x10e73c,%eax
  109dc2:	8b 00                	mov    (%eax),%eax
  109dc4:	83 c0 04             	add    $0x4,%eax
  109dc7:	8b 00                	mov    (%eax),%eax
  109dc9:	89 45 fc             	mov    %eax,-0x4(%ebp)

  if (cmd<=SYSCALL_MAXNUM) {
  109dcc:	83 7d f8 51          	cmpl   $0x51,-0x8(%ebp)
  109dd0:	7f 51                	jg     109e23 <syscall_handler+0x9a>
    if (syscalls[cmd].func!=NULL) res = dyn_call(syscalls[cmd].func,params,syscalls[cmd].numparams);
  109dd2:	8b 45 f8             	mov    -0x8(%ebp),%eax
  109dd5:	8b 04 c5 c0 e1 10 00 	mov    0x10e1c0(,%eax,8),%eax
  109ddc:	85 c0                	test   %eax,%eax
  109dde:	74 2e                	je     109e0e <syscall_handler+0x85>
  109de0:	8b 45 f8             	mov    -0x8(%ebp),%eax
  109de3:	8b 04 c5 c4 e1 10 00 	mov    0x10e1c4(,%eax,8),%eax
  109dea:	89 c2                	mov    %eax,%edx
  109dec:	8b 45 f8             	mov    -0x8(%ebp),%eax
  109def:	8b 0c c5 c0 e1 10 00 	mov    0x10e1c0(,%eax,8),%ecx
  109df6:	89 54 24 08          	mov    %edx,0x8(%esp)
  109dfa:	8b 45 fc             	mov    -0x4(%ebp),%eax
  109dfd:	89 44 24 04          	mov    %eax,0x4(%esp)
  109e01:	89 0c 24             	mov    %ecx,(%esp)
  109e04:	e8 97 0a 00 00       	call   10a8a0 <dyn_call>
  109e09:	89 45 f4             	mov    %eax,-0xc(%ebp)
  109e0c:	eb 15                	jmp    109e23 <syscall_handler+0x9a>
    else kill(proc_current,SIGSYS);
  109e0e:	a1 a0 e1 10 00       	mov    0x10e1a0,%eax
  109e13:	c7 44 24 04 1f 00 00 	movl   $0x1f,0x4(%esp)
  109e1a:	00 
  109e1b:	89 04 24             	mov    %eax,(%esp)
  109e1e:	e8 af fb ff ff       	call   1099d2 <signal_send>
  }

  if (proc_current==proc_call) *interrupt_curregs.eax = res;
  109e23:	a1 a0 e1 10 00       	mov    0x10e1a0,%eax
  109e28:	3b 45 f0             	cmp    -0x10(%ebp),%eax
  109e2b:	75 0b                	jne    109e38 <syscall_handler+0xaf>
  109e2d:	8b 15 20 e7 10 00    	mov    0x10e720,%edx
  109e33:	8b 45 f4             	mov    -0xc(%ebp),%eax
  109e36:	89 02                	mov    %eax,(%edx)
}
  109e38:	c9                   	leave  
  109e39:	c3                   	ret    

00109e3a <syscall_create>:
 *  @param cmd Syscall number
 *  @param func Pointer to function
 *  @param numparams Number of parameters
 *  @return 0=Success; -1=Failure
 */
int syscall_create(int cmd,void *func,int numparams) {
  109e3a:	55                   	push   %ebp
  109e3b:	89 e5                	mov    %esp,%ebp
  109e3d:	83 ec 04             	sub    $0x4,%esp
  if (cmd>SYSCALL_MAXNUM || syscalls[cmd].func!=NULL) return -1;
  109e40:	83 7d 08 51          	cmpl   $0x51,0x8(%ebp)
  109e44:	7f 0e                	jg     109e54 <syscall_create+0x1a>
  109e46:	8b 45 08             	mov    0x8(%ebp),%eax
  109e49:	8b 04 c5 c0 e1 10 00 	mov    0x10e1c0(,%eax,8),%eax
  109e50:	85 c0                	test   %eax,%eax
  109e52:	74 09                	je     109e5d <syscall_create+0x23>
  109e54:	c7 45 fc ff ff ff ff 	movl   $0xffffffff,-0x4(%ebp)
  109e5b:	eb 21                	jmp    109e7e <syscall_create+0x44>
  syscalls[cmd].func = func;
  109e5d:	8b 55 08             	mov    0x8(%ebp),%edx
  109e60:	8b 45 0c             	mov    0xc(%ebp),%eax
  109e63:	89 04 d5 c0 e1 10 00 	mov    %eax,0x10e1c0(,%edx,8)
  syscalls[cmd].numparams = numparams;
  109e6a:	8b 55 08             	mov    0x8(%ebp),%edx
  109e6d:	8b 45 10             	mov    0x10(%ebp),%eax
  109e70:	89 04 d5 c4 e1 10 00 	mov    %eax,0x10e1c4(,%edx,8)
  return 0;
  109e77:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
  109e7e:	8b 45 fc             	mov    -0x4(%ebp),%eax
}
  109e81:	c9                   	leave  
  109e82:	c3                   	ret    

00109e83 <syscall_destroy>:

/**
 * Unregisters a syscall
 *  @param cmd Syscall number
 */
void syscall_destroy(int cmd) {
  109e83:	55                   	push   %ebp
  109e84:	89 e5                	mov    %esp,%ebp
  if (cmd<SYSCALL_MAXNUM) syscalls[cmd].func = NULL;
  109e86:	83 7d 08 50          	cmpl   $0x50,0x8(%ebp)
  109e8a:	7f 0e                	jg     109e9a <syscall_destroy+0x17>
  109e8c:	8b 45 08             	mov    0x8(%ebp),%eax
  109e8f:	c7 04 c5 c0 e1 10 00 	movl   $0x0,0x10e1c0(,%eax,8)
  109e96:	00 00 00 00 
}
  109e9a:	5d                   	pop    %ebp
  109e9b:	c3                   	ret    

00109e9c <tss_init>:

/**
 * Initializes TSS
 *  @return 0=Success; -1=Failure
 */
int tss_init() {
  109e9c:	55                   	push   %ebp
  109e9d:	89 e5                	mov    %esp,%ebp
  109e9f:	83 ec 28             	sub    $0x28,%esp
  cpu_t *cpu = cpu_this;
  109ea2:	a1 54 e4 10 00       	mov    0x10e454,%eax
  109ea7:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  109eae:	00 
  109eaf:	89 04 24             	mov    %eax,(%esp)
  109eb2:	e8 d0 0b 00 00       	call   10aa87 <llist_get>
  109eb7:	89 45 f4             	mov    %eax,-0xc(%ebp)

  // create TSS
  tss_t *tss = malloc(sizeof(tss_t));
  109eba:	c7 04 24 68 20 00 00 	movl   $0x2068,(%esp)
  109ec1:	e8 a3 90 ff ff       	call   102f69 <malloc>
  109ec6:	89 45 f8             	mov    %eax,-0x8(%ebp)
  if (tss==NULL) return -1;
  109ec9:	83 7d f8 00          	cmpl   $0x0,-0x8(%ebp)
  109ecd:	75 0c                	jne    109edb <tss_init+0x3f>
  109ecf:	c7 45 ec ff ff ff ff 	movl   $0xffffffff,-0x14(%ebp)
  109ed6:	e9 d6 00 00 00       	jmp    109fb1 <tss_init+0x115>
  memset(tss,0,sizeof(tss_t));
  109edb:	c7 44 24 08 68 20 00 	movl   $0x2068,0x8(%esp)
  109ee2:	00 
  109ee3:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  109eea:	00 
  109eeb:	8b 45 f8             	mov    -0x8(%ebp),%eax
  109eee:	89 04 24             	mov    %eax,(%esp)
  109ef1:	e8 6b 1e 00 00       	call   10bd61 <memset>
  tss->ss0 = IDX2SEL(2,PRIV_KERNEL);
  109ef6:	8b 45 f8             	mov    -0x8(%ebp),%eax
  109ef9:	c7 40 08 10 00 00 00 	movl   $0x10,0x8(%eax)
  tss->esp0 = (uint32_t)(cpu->stack+cpu->stacksize-4)+sizeof(struct vm86_segmentregs);
  109f00:	8b 45 f4             	mov    -0xc(%ebp),%eax
  109f03:	8b 50 08             	mov    0x8(%eax),%edx
  109f06:	8b 45 f4             	mov    -0xc(%ebp),%eax
  109f09:	8b 40 0c             	mov    0xc(%eax),%eax
  109f0c:	83 c0 0c             	add    $0xc,%eax
  109f0f:	8d 04 02             	lea    (%edx,%eax,1),%eax
  109f12:	89 c2                	mov    %eax,%edx
  109f14:	8b 45 f8             	mov    -0x8(%ebp),%eax
  109f17:	89 50 04             	mov    %edx,0x4(%eax)
  tss->iopb_offset = offsetof(tss_t,iopb);
  109f1a:	8b 45 f8             	mov    -0x8(%ebp),%eax
  109f1d:	66 c7 40 66 68 00    	movw   $0x68,0x66(%eax)
  cpu->tss = tss;
  109f23:	8b 55 f4             	mov    -0xc(%ebp),%edx
  109f26:	8b 45 f8             	mov    -0x8(%ebp),%eax
  109f29:	89 42 50             	mov    %eax,0x50(%edx)

  // create TSS descriptor
  int index = GDT_TSSDESC+cpu_getid();
  109f2c:	c7 45 fc 08 00 00 00 	movl   $0x8,-0x4(%ebp)
  gdt_set_descriptor(index,sizeof(tss_t)-1,tss,GDT_PRESENT|GDT_TSS,PRIV_USER);
  109f33:	c7 44 24 10 03 00 00 	movl   $0x3,0x10(%esp)
  109f3a:	00 
  109f3b:	c7 44 24 0c 89 00 00 	movl   $0x89,0xc(%esp)
  109f42:	00 
  109f43:	8b 45 f8             	mov    -0x8(%ebp),%eax
  109f46:	89 44 24 08          	mov    %eax,0x8(%esp)
  109f4a:	c7 44 24 04 67 20 00 	movl   $0x2067,0x4(%esp)
  109f51:	00 
  109f52:	8b 45 fc             	mov    -0x4(%ebp),%eax
  109f55:	89 04 24             	mov    %eax,(%esp)
  109f58:	e8 c0 68 ff ff       	call   10081d <gdt_set_descriptor>
  gdt[index].flags &= 0x0F;
  109f5d:	8b 55 fc             	mov    -0x4(%ebp),%edx
  109f60:	8b 45 fc             	mov    -0x4(%ebp),%eax
  109f63:	0f b6 04 c5 a6 e4 10 	movzbl 0x10e4a6(,%eax,8),%eax
  109f6a:	00 
  109f6b:	83 e0 0f             	and    $0xf,%eax
  109f6e:	88 04 d5 a6 e4 10 00 	mov    %al,0x10e4a6(,%edx,8)
  // load TSS descriptor
  selector_t selector = {
    .index = index,
    .ti = 0,
    .priv = PRIV_KERNEL
  };
  109f75:	8b 45 fc             	mov    -0x4(%ebp),%eax
  109f78:	89 c2                	mov    %eax,%edx
  109f7a:	66 81 e2 ff 1f       	and    $0x1fff,%dx
  109f7f:	0f b6 45 f2          	movzbl -0xe(%ebp),%eax
  109f83:	83 e0 fc             	and    $0xfffffffc,%eax
  109f86:	88 45 f2             	mov    %al,-0xe(%ebp)
  109f89:	0f b6 45 f2          	movzbl -0xe(%ebp),%eax
  109f8d:	83 e0 fb             	and    $0xfffffffb,%eax
  109f90:	88 45 f2             	mov    %al,-0xe(%ebp)
  109f93:	c1 e2 03             	shl    $0x3,%edx
  109f96:	0f b7 45 f2          	movzwl -0xe(%ebp),%eax
  109f9a:	83 e0 07             	and    $0x7,%eax
  109f9d:	09 d0                	or     %edx,%eax
  109f9f:	66 89 45 f2          	mov    %ax,-0xe(%ebp)
  asm("ltr %0"::"a"(selector));
  109fa3:	0f b7 45 f2          	movzwl -0xe(%ebp),%eax
  109fa7:	0f 00 d8             	ltr    %ax

  return 0;
  109faa:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
  109fb1:	8b 45 ec             	mov    -0x14(%ebp),%eax
}
  109fb4:	c9                   	leave  
  109fb5:	c3                   	ret    
	...

00109fb8 <vga_init>:
#include <vga.h>

/**
 * Initializes VGA
 */
void vga_init() {
  109fb8:	55                   	push   %ebp
  109fb9:	89 e5                	mov    %esp,%ebp
  109fbb:	83 ec 08             	sub    $0x8,%esp
  com_init();
  109fbe:	e8 f5 02 00 00       	call   10a2b8 <com_init>
  vga_text_video = (vga_text_char_t*)VGA_TEXT_ADDRESS;
  109fc3:	c7 05 a0 e6 10 00 00 	movl   $0xb8000,0x10e6a0
  109fca:	80 0b 00 
  vga_text_set_hwcursor(0,VGA_TEXT_HEIGHT+1);
  109fcd:	c7 44 24 04 1a 00 00 	movl   $0x1a,0x4(%esp)
  109fd4:	00 
  109fd5:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  109fdc:	e8 5e 00 00 00       	call   10a03f <vga_text_set_hwcursor>
  vga_text_clear();
  109fe1:	e8 02 00 00 00       	call   109fe8 <vga_text_clear>
}
  109fe6:	c9                   	leave  
  109fe7:	c3                   	ret    

00109fe8 <vga_text_clear>:

/**
 * Clears VGA text screen
 */
void vga_text_clear() {
  109fe8:	55                   	push   %ebp
  109fe9:	89 e5                	mov    %esp,%ebp
  109feb:	83 ec 18             	sub    $0x18,%esp
  vga_text_cursor.x = 0;
  109fee:	c7 05 00 e7 10 00 00 	movl   $0x0,0x10e700
  109ff5:	00 00 00 
  vga_text_cursor.y = 0;
  109ff8:	c7 05 04 e7 10 00 00 	movl   $0x0,0x10e704
  109fff:	00 00 00 
  vga_text_cursor.color = VGA_TEXT_COLOR_DEFAULT;
  10a002:	c7 05 08 e7 10 00 07 	movl   $0x7,0x10e708
  10a009:	00 00 00 
  // trick: just set whole screen with bg color as bg and front color
  memset(vga_text_video,(vga_text_cursor.color&0xF0)|(vga_text_cursor.color>>4),VGA_TEXT_SIZE);
  10a00c:	a1 08 e7 10 00       	mov    0x10e708,%eax
  10a011:	89 c2                	mov    %eax,%edx
  10a013:	81 e2 f0 00 00 00    	and    $0xf0,%edx
  10a019:	a1 08 e7 10 00       	mov    0x10e708,%eax
  10a01e:	c1 e8 04             	shr    $0x4,%eax
  10a021:	09 d0                	or     %edx,%eax
  10a023:	8b 15 a0 e6 10 00    	mov    0x10e6a0,%edx
  10a029:	c7 44 24 08 a0 0f 00 	movl   $0xfa0,0x8(%esp)
  10a030:	00 
  10a031:	89 44 24 04          	mov    %eax,0x4(%esp)
  10a035:	89 14 24             	mov    %edx,(%esp)
  10a038:	e8 24 1d 00 00       	call   10bd61 <memset>
}
  10a03d:	c9                   	leave  
  10a03e:	c3                   	ret    

0010a03f <vga_text_set_hwcursor>:
/**
 * Moves VGA text hardware cursor
 *  @param x New X position
 *  @param y New Y position
 */
void vga_text_set_hwcursor(int x,int y) {
  10a03f:	55                   	push   %ebp
  10a040:	89 e5                	mov    %esp,%ebp
  10a042:	83 ec 18             	sub    $0x18,%esp
  int off = y*VGA_TEXT_WIDTH+x;
  10a045:	8b 55 0c             	mov    0xc(%ebp),%edx
  10a048:	89 d0                	mov    %edx,%eax
  10a04a:	c1 e0 02             	shl    $0x2,%eax
  10a04d:	01 d0                	add    %edx,%eax
  10a04f:	c1 e0 04             	shl    $0x4,%eax
  10a052:	03 45 08             	add    0x8(%ebp),%eax
  10a055:	89 45 fc             	mov    %eax,-0x4(%ebp)

  outb(0x3D4,14);
  10a058:	c7 44 24 04 0e 00 00 	movl   $0xe,0x4(%esp)
  10a05f:	00 
  10a060:	c7 04 24 d4 03 00 00 	movl   $0x3d4,(%esp)
  10a067:	e8 45 00 00 00       	call   10a0b1 <outb>
  outb(0x3D5,off>>8);
  10a06c:	8b 45 fc             	mov    -0x4(%ebp),%eax
  10a06f:	c1 f8 08             	sar    $0x8,%eax
  10a072:	0f b6 c0             	movzbl %al,%eax
  10a075:	89 44 24 04          	mov    %eax,0x4(%esp)
  10a079:	c7 04 24 d5 03 00 00 	movl   $0x3d5,(%esp)
  10a080:	e8 2c 00 00 00       	call   10a0b1 <outb>
  outb(0x3D4,15);
  10a085:	c7 44 24 04 0f 00 00 	movl   $0xf,0x4(%esp)
  10a08c:	00 
  10a08d:	c7 04 24 d4 03 00 00 	movl   $0x3d4,(%esp)
  10a094:	e8 18 00 00 00       	call   10a0b1 <outb>
  outb(0x3D5,off);
  10a099:	8b 45 fc             	mov    -0x4(%ebp),%eax
  10a09c:	0f b6 c0             	movzbl %al,%eax
  10a09f:	89 44 24 04          	mov    %eax,0x4(%esp)
  10a0a3:	c7 04 24 d5 03 00 00 	movl   $0x3d5,(%esp)
  10a0aa:	e8 02 00 00 00       	call   10a0b1 <outb>
}
  10a0af:	c9                   	leave  
  10a0b0:	c3                   	ret    

0010a0b1 <outb>:

static inline void outw(uint16_t _port,uint16_t _data) {
  __asm__("outw %0, %1"::"a"(_data),"Nd"(_port));
}

static inline void outb(uint16_t _port,uint8_t _data) {
  10a0b1:	55                   	push   %ebp
  10a0b2:	89 e5                	mov    %esp,%ebp
  10a0b4:	83 ec 08             	sub    $0x8,%esp
  10a0b7:	8b 45 08             	mov    0x8(%ebp),%eax
  10a0ba:	8b 55 0c             	mov    0xc(%ebp),%edx
  10a0bd:	66 89 45 fc          	mov    %ax,-0x4(%ebp)
  10a0c1:	88 55 f8             	mov    %dl,-0x8(%ebp)
  __asm__("outb %0, %1"::"a"(_data),"Nd"(_port));
  10a0c4:	0f b6 45 f8          	movzbl -0x8(%ebp),%eax
  10a0c8:	0f b7 55 fc          	movzwl -0x4(%ebp),%edx
  10a0cc:	ee                   	out    %al,(%dx)
}
  10a0cd:	c9                   	leave  
  10a0ce:	c3                   	ret    

0010a0cf <vga_text_setcolor>:

/**
 * Set color of next chars
 *  @param color Color
 */
void vga_text_setcolor(vga_text_color_t color) {
  10a0cf:	55                   	push   %ebp
  10a0d0:	89 e5                	mov    %esp,%ebp
  vga_text_cursor.color = color;
  10a0d2:	8b 45 08             	mov    0x8(%ebp),%eax
  10a0d5:	a3 08 e7 10 00       	mov    %eax,0x10e708
}
  10a0da:	5d                   	pop    %ebp
  10a0db:	c3                   	ret    

0010a0dc <vga_text_printchar>:

/**
 * Prints character to VGA text screen
 */
void vga_text_printchar(char chr) {
  10a0dc:	55                   	push   %ebp
  10a0dd:	89 e5                	mov    %esp,%ebp
  10a0df:	83 ec 28             	sub    $0x28,%esp
  10a0e2:	8b 45 08             	mov    0x8(%ebp),%eax
  10a0e5:	88 45 ec             	mov    %al,-0x14(%ebp)
  if (chr=='\b') vga_text_cursor.x = vga_text_cursor.x>0?vga_text_cursor.x-1:vga_text_cursor.x;
  10a0e8:	80 7d ec 08          	cmpb   $0x8,-0x14(%ebp)
  10a0ec:	75 2b                	jne    10a119 <vga_text_printchar+0x3d>
  10a0ee:	a1 00 e7 10 00       	mov    0x10e700,%eax
  10a0f3:	85 c0                	test   %eax,%eax
  10a0f5:	7e 0d                	jle    10a104 <vga_text_printchar+0x28>
  10a0f7:	a1 00 e7 10 00       	mov    0x10e700,%eax
  10a0fc:	83 e8 01             	sub    $0x1,%eax
  10a0ff:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  10a102:	eb 08                	jmp    10a10c <vga_text_printchar+0x30>
  10a104:	a1 00 e7 10 00       	mov    0x10e700,%eax
  10a109:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  10a10c:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  10a10f:	a3 00 e7 10 00       	mov    %eax,0x10e700
  10a114:	e9 f5 00 00 00       	jmp    10a20e <vga_text_printchar+0x132>
  else if (chr=='\r') vga_text_cursor.x = 0;
  10a119:	80 7d ec 0d          	cmpb   $0xd,-0x14(%ebp)
  10a11d:	75 0f                	jne    10a12e <vga_text_printchar+0x52>
  10a11f:	c7 05 00 e7 10 00 00 	movl   $0x0,0x10e700
  10a126:	00 00 00 
  10a129:	e9 e0 00 00 00       	jmp    10a20e <vga_text_printchar+0x132>
  else if (chr=='\n') {
  10a12e:	80 7d ec 0a          	cmpb   $0xa,-0x14(%ebp)
  10a132:	75 1c                	jne    10a150 <vga_text_printchar+0x74>
    vga_text_cursor.y++;
  10a134:	a1 04 e7 10 00       	mov    0x10e704,%eax
  10a139:	83 c0 01             	add    $0x1,%eax
  10a13c:	a3 04 e7 10 00       	mov    %eax,0x10e704
    vga_text_cursor.x = 0;
  10a141:	c7 05 00 e7 10 00 00 	movl   $0x0,0x10e700
  10a148:	00 00 00 
  10a14b:	e9 be 00 00 00       	jmp    10a20e <vga_text_printchar+0x132>
  }
  else if (chr=='\f') vga_text_clear();
  10a150:	80 7d ec 0c          	cmpb   $0xc,-0x14(%ebp)
  10a154:	75 0a                	jne    10a160 <vga_text_printchar+0x84>
  10a156:	e8 8d fe ff ff       	call   109fe8 <vga_text_clear>
  10a15b:	e9 ae 00 00 00       	jmp    10a20e <vga_text_printchar+0x132>
  else if (chr=='\t') vga_text_cursor.x = vga_text_cursor.x = vga_text_cursor.x>0?(vga_text_cursor.x/VGA_TEXT_TABSIZE+1)*VGA_TEXT_TABSIZE:0;
  10a160:	80 7d ec 09          	cmpb   $0x9,-0x14(%ebp)
  10a164:	75 42                	jne    10a1a8 <vga_text_printchar+0xcc>
  10a166:	a1 00 e7 10 00       	mov    0x10e700,%eax
  10a16b:	85 c0                	test   %eax,%eax
  10a16d:	7e 1e                	jle    10a18d <vga_text_printchar+0xb1>
  10a16f:	8b 15 00 e7 10 00    	mov    0x10e700,%edx
  10a175:	89 d0                	mov    %edx,%eax
  10a177:	c1 f8 1f             	sar    $0x1f,%eax
  10a17a:	c1 e8 1d             	shr    $0x1d,%eax
  10a17d:	01 d0                	add    %edx,%eax
  10a17f:	c1 f8 03             	sar    $0x3,%eax
  10a182:	83 c0 01             	add    $0x1,%eax
  10a185:	c1 e0 03             	shl    $0x3,%eax
  10a188:	89 45 e8             	mov    %eax,-0x18(%ebp)
  10a18b:	eb 07                	jmp    10a194 <vga_text_printchar+0xb8>
  10a18d:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
  10a194:	8b 45 e8             	mov    -0x18(%ebp),%eax
  10a197:	a3 00 e7 10 00       	mov    %eax,0x10e700
  10a19c:	a1 00 e7 10 00       	mov    0x10e700,%eax
  10a1a1:	a3 00 e7 10 00       	mov    %eax,0x10e700
  10a1a6:	eb 66                	jmp    10a20e <vga_text_printchar+0x132>
  else if (isprint(chr)) {
  10a1a8:	80 7d ec 1f          	cmpb   $0x1f,-0x14(%ebp)
  10a1ac:	7e 60                	jle    10a20e <vga_text_printchar+0x132>
    int off = vga_text_cursor.x+vga_text_cursor.y*VGA_TEXT_WIDTH;
  10a1ae:	8b 0d 00 e7 10 00    	mov    0x10e700,%ecx
  10a1b4:	8b 15 04 e7 10 00    	mov    0x10e704,%edx
  10a1ba:	89 d0                	mov    %edx,%eax
  10a1bc:	c1 e0 02             	shl    $0x2,%eax
  10a1bf:	01 d0                	add    %edx,%eax
  10a1c1:	c1 e0 04             	shl    $0x4,%eax
  10a1c4:	8d 04 01             	lea    (%ecx,%eax,1),%eax
  10a1c7:	89 45 fc             	mov    %eax,-0x4(%ebp)
    if (off==0x3FD) asm("hlt"::"a"(0xD00FC0DE));
  10a1ca:	81 7d fc fd 03 00 00 	cmpl   $0x3fd,-0x4(%ebp)
  10a1d1:	75 06                	jne    10a1d9 <vga_text_printchar+0xfd>
  10a1d3:	b8 de c0 0f d0       	mov    $0xd00fc0de,%eax
  10a1d8:	f4                   	hlt    
    vga_text_video[off].chr = chr;
  10a1d9:	8b 15 a0 e6 10 00    	mov    0x10e6a0,%edx
  10a1df:	8b 45 fc             	mov    -0x4(%ebp),%eax
  10a1e2:	01 c0                	add    %eax,%eax
  10a1e4:	01 c2                	add    %eax,%edx
  10a1e6:	0f b6 45 ec          	movzbl -0x14(%ebp),%eax
  10a1ea:	88 02                	mov    %al,(%edx)
    vga_text_video[off].attr = vga_text_cursor.color;
  10a1ec:	8b 15 a0 e6 10 00    	mov    0x10e6a0,%edx
  10a1f2:	8b 45 fc             	mov    -0x4(%ebp),%eax
  10a1f5:	01 c0                	add    %eax,%eax
  10a1f7:	01 c2                	add    %eax,%edx
  10a1f9:	a1 08 e7 10 00       	mov    0x10e708,%eax
  10a1fe:	88 42 01             	mov    %al,0x1(%edx)
    vga_text_cursor.x++;
  10a201:	a1 00 e7 10 00       	mov    0x10e700,%eax
  10a206:	83 c0 01             	add    $0x1,%eax
  10a209:	a3 00 e7 10 00       	mov    %eax,0x10e700
  }

  com_send(chr);
  10a20e:	0f be 45 ec          	movsbl -0x14(%ebp),%eax
  10a212:	89 04 24             	mov    %eax,(%esp)
  10a215:	e8 75 01 00 00       	call   10a38f <com_send>
  bochs_send(chr);
  10a21a:	0f be 45 ec          	movsbl -0x14(%ebp),%eax
  10a21e:	89 04 24             	mov    %eax,(%esp)
  10a221:	e8 97 01 00 00       	call   10a3bd <bochs_send>

  if (vga_text_cursor.x>=VGA_TEXT_WIDTH) {
  10a226:	a1 00 e7 10 00       	mov    0x10e700,%eax
  10a22b:	83 f8 4f             	cmp    $0x4f,%eax
  10a22e:	7e 17                	jle    10a247 <vga_text_printchar+0x16b>
    vga_text_cursor.x = 0;
  10a230:	c7 05 00 e7 10 00 00 	movl   $0x0,0x10e700
  10a237:	00 00 00 
    vga_text_cursor.y++;
  10a23a:	a1 04 e7 10 00       	mov    0x10e704,%eax
  10a23f:	83 c0 01             	add    $0x1,%eax
  10a242:	a3 04 e7 10 00       	mov    %eax,0x10e704
  }
  if (vga_text_cursor.y>=VGA_TEXT_HEIGHT) {
  10a247:	a1 04 e7 10 00       	mov    0x10e704,%eax
  10a24c:	83 f8 18             	cmp    $0x18,%eax
  10a24f:	7e 65                	jle    10a2b6 <vga_text_printchar+0x1da>
    memmove(vga_text_video,vga_text_video+VGA_TEXT_WIDTH,VGA_TEXT_WIDTH*(VGA_TEXT_HEIGHT-1)*VGA_TEXT_BPC);
  10a251:	a1 a0 e6 10 00       	mov    0x10e6a0,%eax
  10a256:	05 a0 00 00 00       	add    $0xa0,%eax
  10a25b:	8b 15 a0 e6 10 00    	mov    0x10e6a0,%edx
  10a261:	c7 44 24 08 00 0f 00 	movl   $0xf00,0x8(%esp)
  10a268:	00 
  10a269:	89 44 24 04          	mov    %eax,0x4(%esp)
  10a26d:	89 14 24             	mov    %edx,(%esp)
  10a270:	e8 c7 19 00 00       	call   10bc3c <memmove>
    memset(vga_text_video+VGA_TEXT_WIDTH*(VGA_TEXT_HEIGHT-1),(vga_text_cursor.color&0xF0)|(vga_text_cursor.color>>4),VGA_TEXT_WIDTH*VGA_TEXT_BPC);
  10a275:	a1 08 e7 10 00       	mov    0x10e708,%eax
  10a27a:	89 c2                	mov    %eax,%edx
  10a27c:	81 e2 f0 00 00 00    	and    $0xf0,%edx
  10a282:	a1 08 e7 10 00       	mov    0x10e708,%eax
  10a287:	c1 e8 04             	shr    $0x4,%eax
  10a28a:	09 d0                	or     %edx,%eax
  10a28c:	89 c2                	mov    %eax,%edx
  10a28e:	a1 a0 e6 10 00       	mov    0x10e6a0,%eax
  10a293:	05 00 0f 00 00       	add    $0xf00,%eax
  10a298:	c7 44 24 08 a0 00 00 	movl   $0xa0,0x8(%esp)
  10a29f:	00 
  10a2a0:	89 54 24 04          	mov    %edx,0x4(%esp)
  10a2a4:	89 04 24             	mov    %eax,(%esp)
  10a2a7:	e8 b5 1a 00 00       	call   10bd61 <memset>
    vga_text_cursor.y = VGA_TEXT_HEIGHT-1;
  10a2ac:	c7 05 04 e7 10 00 18 	movl   $0x18,0x10e704
  10a2b3:	00 00 00 
  }
}
  10a2b6:	c9                   	leave  
  10a2b7:	c3                   	ret    

0010a2b8 <com_init>:

/// @todo remove
#define COM_PORT 0x3f8   /* COM1 */
#define BAUDRATE 9600
void com_init() {
  10a2b8:	55                   	push   %ebp
  10a2b9:	89 e5                	mov    %esp,%ebp
  10a2bb:	83 ec 18             	sub    $0x18,%esp
  int baud = 115200/BAUDRATE;
  10a2be:	c7 45 fc 0c 00 00 00 	movl   $0xc,-0x4(%ebp)
  // Keine Parität
  outb(COM_PORT+1,0x00); // no interrupts
  10a2c5:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  10a2cc:	00 
  10a2cd:	c7 04 24 f9 03 00 00 	movl   $0x3f9,(%esp)
  10a2d4:	e8 d8 fd ff ff       	call   10a0b1 <outb>
  outb(COM_PORT+3,0x80); // dlab
  10a2d9:	c7 44 24 04 80 00 00 	movl   $0x80,0x4(%esp)
  10a2e0:	00 
  10a2e1:	c7 04 24 fb 03 00 00 	movl   $0x3fb,(%esp)
  10a2e8:	e8 c4 fd ff ff       	call   10a0b1 <outb>
  outb(COM_PORT+0,baud); // Baudrate (low)
  10a2ed:	8b 45 fc             	mov    -0x4(%ebp),%eax
  10a2f0:	0f b6 c0             	movzbl %al,%eax
  10a2f3:	89 44 24 04          	mov    %eax,0x4(%esp)
  10a2f7:	c7 04 24 f8 03 00 00 	movl   $0x3f8,(%esp)
  10a2fe:	e8 ae fd ff ff       	call   10a0b1 <outb>
  outb(COM_PORT+1,baud>>8); // Baudrate (high)
  10a303:	8b 45 fc             	mov    -0x4(%ebp),%eax
  10a306:	c1 f8 08             	sar    $0x8,%eax
  10a309:	0f b6 c0             	movzbl %al,%eax
  10a30c:	89 44 24 04          	mov    %eax,0x4(%esp)
  10a310:	c7 04 24 f9 03 00 00 	movl   $0x3f9,(%esp)
  10a317:	e8 95 fd ff ff       	call   10a0b1 <outb>
  outb(COM_PORT+3,0x03); // 8 Bits, 1 stopbit
  10a31c:	c7 44 24 04 03 00 00 	movl   $0x3,0x4(%esp)
  10a323:	00 
  10a324:	c7 04 24 fb 03 00 00 	movl   $0x3fb,(%esp)
  10a32b:	e8 81 fd ff ff       	call   10a0b1 <outb>
  outb(COM_PORT+2,0xC7);
  10a330:	c7 44 24 04 c7 00 00 	movl   $0xc7,0x4(%esp)
  10a337:	00 
  10a338:	c7 04 24 fa 03 00 00 	movl   $0x3fa,(%esp)
  10a33f:	e8 6d fd ff ff       	call   10a0b1 <outb>
  outb(COM_PORT+4,0x0B);
  10a344:	c7 44 24 04 0b 00 00 	movl   $0xb,0x4(%esp)
  10a34b:	00 
  10a34c:	c7 04 24 fc 03 00 00 	movl   $0x3fc,(%esp)
  10a353:	e8 59 fd ff ff       	call   10a0b1 <outb>
}
  10a358:	c9                   	leave  
  10a359:	c3                   	ret    

0010a35a <is_transmit_empty>:
int is_transmit_empty() {
  10a35a:	55                   	push   %ebp
  10a35b:	89 e5                	mov    %esp,%ebp
  10a35d:	83 ec 08             	sub    $0x8,%esp
  return inb(COM_PORT+5)&0x20;
  10a360:	c7 04 24 fd 03 00 00 	movl   $0x3fd,(%esp)
  10a367:	e8 08 00 00 00       	call   10a374 <inb>
  10a36c:	0f b6 c0             	movzbl %al,%eax
  10a36f:	83 e0 20             	and    $0x20,%eax
}
  10a372:	c9                   	leave  
  10a373:	c3                   	ret    

0010a374 <inb>:

#define IOPORT_MAXNUM 0x10000

int *iopb_general;

static inline uint8_t inb(uint16_t _port) {
  10a374:	55                   	push   %ebp
  10a375:	89 e5                	mov    %esp,%ebp
  10a377:	83 ec 14             	sub    $0x14,%esp
  10a37a:	8b 45 08             	mov    0x8(%ebp),%eax
  10a37d:	66 89 45 ec          	mov    %ax,-0x14(%ebp)
  uint8_t _result;
  __asm__("inb %1, %0":"=a"(_result):"Nd"(_port));
  10a381:	0f b7 55 ec          	movzwl -0x14(%ebp),%edx
  10a385:	ec                   	in     (%dx),%al
  10a386:	88 45 ff             	mov    %al,-0x1(%ebp)
  return _result;
  10a389:	0f b6 45 ff          	movzbl -0x1(%ebp),%eax
}
  10a38d:	c9                   	leave  
  10a38e:	c3                   	ret    

0010a38f <com_send>:
void com_send(char a) {
  10a38f:	55                   	push   %ebp
  10a390:	89 e5                	mov    %esp,%ebp
  10a392:	83 ec 18             	sub    $0x18,%esp
  10a395:	8b 45 08             	mov    0x8(%ebp),%eax
  10a398:	88 45 fc             	mov    %al,-0x4(%ebp)
  while (!is_transmit_empty());
  10a39b:	e8 ba ff ff ff       	call   10a35a <is_transmit_empty>
  10a3a0:	85 c0                	test   %eax,%eax
  10a3a2:	74 f7                	je     10a39b <com_send+0xc>
  outb(COM_PORT,a);
  10a3a4:	0f b6 45 fc          	movzbl -0x4(%ebp),%eax
  10a3a8:	0f b6 c0             	movzbl %al,%eax
  10a3ab:	89 44 24 04          	mov    %eax,0x4(%esp)
  10a3af:	c7 04 24 f8 03 00 00 	movl   $0x3f8,(%esp)
  10a3b6:	e8 f6 fc ff ff       	call   10a0b1 <outb>
}
  10a3bb:	c9                   	leave  
  10a3bc:	c3                   	ret    

0010a3bd <bochs_send>:

#define BOCHS_PORT 0xE9
void bochs_send(char a) {
  10a3bd:	55                   	push   %ebp
  10a3be:	89 e5                	mov    %esp,%ebp
  10a3c0:	83 ec 0c             	sub    $0xc,%esp
  10a3c3:	8b 45 08             	mov    0x8(%ebp),%eax
  10a3c6:	88 45 fc             	mov    %al,-0x4(%ebp)
  outb(BOCHS_PORT,a);
  10a3c9:	0f b6 45 fc          	movzbl -0x4(%ebp),%eax
  10a3cd:	0f b6 c0             	movzbl %al,%eax
  10a3d0:	89 44 24 04          	mov    %eax,0x4(%esp)
  10a3d4:	c7 04 24 e9 00 00 00 	movl   $0xe9,(%esp)
  10a3db:	e8 d1 fc ff ff       	call   10a0b1 <outb>
}
  10a3e0:	c9                   	leave  
  10a3e1:	c3                   	ret    
	...

0010a3e4 <vm86_proc_create>:
#include <string.h>
#include <gdt.h>
#include <memkernel.h>
#include <llist.h>

proc_t *vm86_proc_create(const char *name,uid_t uid,gid_t gid,proc_t *parent) {
  10a3e4:	55                   	push   %ebp
  10a3e5:	89 e5                	mov    %esp,%ebp
  10a3e7:	83 ec 28             	sub    $0x28,%esp
  proc_t *new = malloc(sizeof(proc_t));
  10a3ea:	c7 04 24 b4 00 00 00 	movl   $0xb4,(%esp)
  10a3f1:	e8 73 8b ff ff       	call   102f69 <malloc>
  10a3f6:	89 45 fc             	mov    %eax,-0x4(%ebp)

  new->pid = proc_nextpid++;
  10a3f9:	8b 15 60 e4 10 00    	mov    0x10e460,%edx
  10a3ff:	8b 45 fc             	mov    -0x4(%ebp),%eax
  10a402:	89 10                	mov    %edx,(%eax)
  10a404:	8d 42 01             	lea    0x1(%edx),%eax
  10a407:	a3 60 e4 10 00       	mov    %eax,0x10e460
  new->uid = uid;
  10a40c:	8b 55 fc             	mov    -0x4(%ebp),%edx
  10a40f:	8b 45 0c             	mov    0xc(%ebp),%eax
  10a412:	89 42 04             	mov    %eax,0x4(%edx)
  new->euid = uid;
  10a415:	8b 55 fc             	mov    -0x4(%ebp),%edx
  10a418:	8b 45 0c             	mov    0xc(%ebp),%eax
  10a41b:	89 42 08             	mov    %eax,0x8(%edx)
  new->suid = uid;
  10a41e:	8b 55 fc             	mov    -0x4(%ebp),%edx
  10a421:	8b 45 0c             	mov    0xc(%ebp),%eax
  10a424:	89 42 0c             	mov    %eax,0xc(%edx)
  new->gid = gid;
  10a427:	8b 55 fc             	mov    -0x4(%ebp),%edx
  10a42a:	8b 45 10             	mov    0x10(%ebp),%eax
  10a42d:	89 42 10             	mov    %eax,0x10(%edx)
  new->egid = gid;
  10a430:	8b 55 fc             	mov    -0x4(%ebp),%edx
  10a433:	8b 45 10             	mov    0x10(%ebp),%eax
  10a436:	89 42 14             	mov    %eax,0x14(%edx)
  new->sgid = gid;
  10a439:	8b 55 fc             	mov    -0x4(%ebp),%edx
  10a43c:	8b 45 10             	mov    0x10(%ebp),%eax
  10a43f:	89 42 18             	mov    %eax,0x18(%edx)
  new->name = strdup(name);
  10a442:	8b 45 08             	mov    0x8(%ebp),%eax
  10a445:	89 04 24             	mov    %eax,(%esp)
  10a448:	e8 a4 1a 00 00       	call   10bef1 <strdup>
  10a44d:	89 c2                	mov    %eax,%edx
  10a44f:	8b 45 fc             	mov    -0x4(%ebp),%eax
  10a452:	89 50 20             	mov    %edx,0x20(%eax)
  new->parent = parent;
  10a455:	8b 55 fc             	mov    -0x4(%ebp),%edx
  10a458:	8b 45 14             	mov    0x14(%ebp),%eax
  10a45b:	89 42 24             	mov    %eax,0x24(%edx)
  if (parent!=NULL) llist_push(parent->children,new);
  10a45e:	83 7d 14 00          	cmpl   $0x0,0x14(%ebp)
  10a462:	74 15                	je     10a479 <vm86_proc_create+0x95>
  10a464:	8b 45 14             	mov    0x14(%ebp),%eax
  10a467:	8b 50 28             	mov    0x28(%eax),%edx
  10a46a:	8b 45 fc             	mov    -0x4(%ebp),%eax
  10a46d:	89 44 24 04          	mov    %eax,0x4(%esp)
  10a471:	89 14 24             	mov    %edx,(%esp)
  10a474:	e8 d6 04 00 00       	call   10a94f <llist_push>
  new->children = llist_create();
  10a479:	e8 56 04 00 00       	call   10a8d4 <llist_create>
  10a47e:	89 c2                	mov    %eax,%edx
  10a480:	8b 45 fc             	mov    -0x4(%ebp),%eax
  10a483:	89 50 28             	mov    %edx,0x28(%eax)
  memset(&(new->registers),0,sizeof(new->registers));
  10a486:	8b 45 fc             	mov    -0x4(%ebp),%eax
  10a489:	83 c0 2c             	add    $0x2c,%eax
  10a48c:	c7 44 24 08 40 00 00 	movl   $0x40,0x8(%esp)
  10a493:	00 
  10a494:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  10a49b:	00 
  10a49c:	89 04 24             	mov    %eax,(%esp)
  10a49f:	e8 bd 18 00 00       	call   10bd61 <memset>
  new->registers.efl = 0x20202;
  10a4a4:	8b 45 fc             	mov    -0x4(%ebp),%eax
  10a4a7:	c7 40 50 02 02 02 00 	movl   $0x20202,0x50(%eax)
  new->registers.cs = IDX2SEL(3,PRIV_USER);
  10a4ae:	8b 45 fc             	mov    -0x4(%ebp),%eax
  10a4b1:	c7 40 54 1b 00 00 00 	movl   $0x1b,0x54(%eax)
  new->registers.ds = IDX2SEL(4,PRIV_USER);
  10a4b8:	8b 45 fc             	mov    -0x4(%ebp),%eax
  10a4bb:	c7 40 58 23 00 00 00 	movl   $0x23,0x58(%eax)
  new->registers.es = IDX2SEL(4,PRIV_USER);
  10a4c2:	8b 45 fc             	mov    -0x4(%ebp),%eax
  10a4c5:	c7 40 5c 23 00 00 00 	movl   $0x23,0x5c(%eax)
  new->registers.fs = IDX2SEL(4,PRIV_USER);
  10a4cc:	8b 45 fc             	mov    -0x4(%ebp),%eax
  10a4cf:	c7 40 60 23 00 00 00 	movl   $0x23,0x60(%eax)
  new->registers.gs = IDX2SEL(4,PRIV_USER);
  10a4d6:	8b 45 fc             	mov    -0x4(%ebp),%eax
  10a4d9:	c7 40 64 23 00 00 00 	movl   $0x23,0x64(%eax)
  new->registers.ss = IDX2SEL(4,PRIV_USER);
  10a4e0:	8b 45 fc             	mov    -0x4(%ebp),%eax
  10a4e3:	c7 40 68 23 00 00 00 	movl   $0x23,0x68(%eax)
  new->addrspace = NULL;
  10a4ea:	8b 45 fc             	mov    -0x4(%ebp),%eax
  10a4ed:	c7 40 6c 00 00 00 00 	movl   $0x0,0x6c(%eax)
  new->vm86_pagedir = NULL;
  10a4f4:	8b 45 fc             	mov    -0x4(%ebp),%eax
  10a4f7:	c7 80 94 00 00 00 00 	movl   $0x0,0x94(%eax)
  10a4fe:	00 00 00 
  new->nice = 0;
  10a501:	8b 45 fc             	mov    -0x4(%ebp),%eax
  10a504:	c7 40 74 00 00 00 00 	movl   $0x0,0x74(%eax)
  new->ticks_rem = NICE2TICKS(new->nice);
  10a50b:	8b 45 fc             	mov    -0x4(%ebp),%eax
  10a50e:	c7 40 78 01 00 00 00 	movl   $0x1,0x78(%eax)
  new->var = -1;
  10a515:	8b 45 fc             	mov    -0x4(%ebp),%eax
  10a518:	c7 80 80 00 00 00 ff 	movl   $0xffffffff,0x80(%eax)
  10a51f:	ff ff ff 
  new->defunc = 0;
  10a522:	8b 45 fc             	mov    -0x4(%ebp),%eax
  10a525:	c7 80 84 00 00 00 00 	movl   $0x0,0x84(%eax)
  10a52c:	00 00 00 
  new->is_sleeping = 0;
  10a52f:	8b 45 fc             	mov    -0x4(%ebp),%eax
  10a532:	c7 40 7c 00 00 00 00 	movl   $0x0,0x7c(%eax)
  new->signal = NULL;
  10a539:	8b 45 fc             	mov    -0x4(%ebp),%eax
  10a53c:	c7 80 8c 00 00 00 00 	movl   $0x0,0x8c(%eax)
  10a543:	00 00 00 
  new->is_vm86 = 1;
  10a546:	8b 45 fc             	mov    -0x4(%ebp),%eax
  10a549:	c7 80 90 00 00 00 01 	movl   $0x1,0x90(%eax)
  10a550:	00 00 00 

  //llist_push(proc_all,new);
  //llist_push(proc_running,new);
  return new;
  10a553:	8b 45 fc             	mov    -0x4(%ebp),%eax
}
  10a556:	c9                   	leave  
  10a557:	c3                   	ret    

0010a558 <vm86_save_segregs>:

void vm86_save_segregs(proc_t *proc) {
  10a558:	55                   	push   %ebp
  10a559:	89 e5                	mov    %esp,%ebp
  proc->vm86_segregs.es = *vm86_curregs.es;
  10a55b:	a1 a4 e1 10 00       	mov    0x10e1a4,%eax
  10a560:	8b 10                	mov    (%eax),%edx
  10a562:	8b 45 08             	mov    0x8(%ebp),%eax
  10a565:	89 90 a4 00 00 00    	mov    %edx,0xa4(%eax)
  proc->vm86_segregs.ds = *vm86_curregs.ds;
  10a56b:	a1 a8 e1 10 00       	mov    0x10e1a8,%eax
  10a570:	8b 10                	mov    (%eax),%edx
  10a572:	8b 45 08             	mov    0x8(%ebp),%eax
  10a575:	89 90 a8 00 00 00    	mov    %edx,0xa8(%eax)
  proc->vm86_segregs.fs = *vm86_curregs.fs;
  10a57b:	a1 ac e1 10 00       	mov    0x10e1ac,%eax
  10a580:	8b 10                	mov    (%eax),%edx
  10a582:	8b 45 08             	mov    0x8(%ebp),%eax
  10a585:	89 90 ac 00 00 00    	mov    %edx,0xac(%eax)
  proc->vm86_segregs.gs = *vm86_curregs.gs;
  10a58b:	a1 b0 e1 10 00       	mov    0x10e1b0,%eax
  10a590:	8b 10                	mov    (%eax),%edx
  10a592:	8b 45 08             	mov    0x8(%ebp),%eax
  10a595:	89 90 b0 00 00 00    	mov    %edx,0xb0(%eax)
}
  10a59b:	5d                   	pop    %ebp
  10a59c:	c3                   	ret    

0010a59d <vm86_load_segregs>:

void vm86_load_segregs(proc_t *proc) {
  10a59d:	55                   	push   %ebp
  10a59e:	89 e5                	mov    %esp,%ebp
  *vm86_curregs.es = proc->vm86_segregs.es;
  10a5a0:	8b 15 a4 e1 10 00    	mov    0x10e1a4,%edx
  10a5a6:	8b 45 08             	mov    0x8(%ebp),%eax
  10a5a9:	8b 80 a4 00 00 00    	mov    0xa4(%eax),%eax
  10a5af:	89 02                	mov    %eax,(%edx)
  *vm86_curregs.ds = proc->vm86_segregs.ds;
  10a5b1:	8b 15 a8 e1 10 00    	mov    0x10e1a8,%edx
  10a5b7:	8b 45 08             	mov    0x8(%ebp),%eax
  10a5ba:	8b 80 a8 00 00 00    	mov    0xa8(%eax),%eax
  10a5c0:	89 02                	mov    %eax,(%edx)
  *vm86_curregs.fs = proc->vm86_segregs.fs;
  10a5c2:	8b 15 ac e1 10 00    	mov    0x10e1ac,%edx
  10a5c8:	8b 45 08             	mov    0x8(%ebp),%eax
  10a5cb:	8b 80 ac 00 00 00    	mov    0xac(%eax),%eax
  10a5d1:	89 02                	mov    %eax,(%edx)
  *vm86_curregs.gs = proc->vm86_segregs.gs;
  10a5d3:	8b 15 b0 e1 10 00    	mov    0x10e1b0,%edx
  10a5d9:	8b 45 08             	mov    0x8(%ebp),%eax
  10a5dc:	8b 80 b0 00 00 00    	mov    0xb0(%eax),%eax
  10a5e2:	89 02                	mov    %eax,(%edx)
}
  10a5e4:	5d                   	pop    %ebp
  10a5e5:	c3                   	ret    
	...

0010a5f0 <__udivdi3>:
  10a5f0:	55                   	push   %ebp
  10a5f1:	89 e5                	mov    %esp,%ebp
  10a5f3:	83 ec 30             	sub    $0x30,%esp
  10a5f6:	57                   	push   %edi
  10a5f7:	56                   	push   %esi
  10a5f8:	8b 45 08             	mov    0x8(%ebp),%eax
  10a5fb:	8b 55 0c             	mov    0xc(%ebp),%edx
  10a5fe:	8b 7d 10             	mov    0x10(%ebp),%edi
  10a601:	8b 4d 14             	mov    0x14(%ebp),%ecx
  10a604:	89 4d e8             	mov    %ecx,-0x18(%ebp)
  10a607:	89 45 fc             	mov    %eax,-0x4(%ebp)
  10a60a:	89 55 e4             	mov    %edx,-0x1c(%ebp)
  10a60d:	85 c9                	test   %ecx,%ecx
  10a60f:	75 3f                	jne    10a650 <__udivdi3+0x60>
  10a611:	39 d7                	cmp    %edx,%edi
  10a613:	76 0b                	jbe    10a620 <__udivdi3+0x30>
  10a615:	f7 f7                	div    %edi
  10a617:	89 45 e0             	mov    %eax,-0x20(%ebp)
  10a61a:	e9 d6 00 00 00       	jmp    10a6f5 <__udivdi3+0x105>
  10a61f:	90                   	nop    
  10a620:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
  10a624:	75 0d                	jne    10a633 <__udivdi3+0x43>
  10a626:	be 01 00 00 00       	mov    $0x1,%esi
  10a62b:	89 f0                	mov    %esi,%eax
  10a62d:	31 d2                	xor    %edx,%edx
  10a62f:	f7 f7                	div    %edi
  10a631:	89 c7                	mov    %eax,%edi
  10a633:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  10a636:	8b 55 e8             	mov    -0x18(%ebp),%edx
  10a639:	f7 f7                	div    %edi
  10a63b:	89 c1                	mov    %eax,%ecx
  10a63d:	8b 45 fc             	mov    -0x4(%ebp),%eax
  10a640:	89 55 e4             	mov    %edx,-0x1c(%ebp)
  10a643:	f7 f7                	div    %edi
  10a645:	89 45 e0             	mov    %eax,-0x20(%ebp)
  10a648:	e9 aa 00 00 00       	jmp    10a6f7 <__udivdi3+0x107>
  10a64d:	8d 76 00             	lea    0x0(%esi),%esi
  10a650:	8b 55 e4             	mov    -0x1c(%ebp),%edx
  10a653:	39 55 e8             	cmp    %edx,-0x18(%ebp)
  10a656:	76 0c                	jbe    10a664 <__udivdi3+0x74>
  10a658:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
  10a65f:	e9 91 00 00 00       	jmp    10a6f5 <__udivdi3+0x105>
  10a664:	0f bd 75 e8          	bsr    -0x18(%ebp),%esi
  10a668:	83 f6 1f             	xor    $0x1f,%esi
  10a66b:	75 23                	jne    10a690 <__udivdi3+0xa0>
  10a66d:	8b 4d e8             	mov    -0x18(%ebp),%ecx
  10a670:	39 4d e4             	cmp    %ecx,-0x1c(%ebp)
  10a673:	77 0b                	ja     10a680 <__udivdi3+0x90>
  10a675:	39 7d fc             	cmp    %edi,-0x4(%ebp)
  10a678:	72 de                	jb     10a658 <__udivdi3+0x68>
  10a67a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
  10a680:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)
  10a687:	eb 6c                	jmp    10a6f5 <__udivdi3+0x105>
  10a689:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
  10a690:	8b 45 e8             	mov    -0x18(%ebp),%eax
  10a693:	c7 45 f8 20 00 00 00 	movl   $0x20,-0x8(%ebp)
  10a69a:	29 75 f8             	sub    %esi,-0x8(%ebp)
  10a69d:	89 f1                	mov    %esi,%ecx
  10a69f:	d3 e0                	shl    %cl,%eax
  10a6a1:	8b 4d f8             	mov    -0x8(%ebp),%ecx
  10a6a4:	89 7d e8             	mov    %edi,-0x18(%ebp)
  10a6a7:	d3 6d e8             	shrl   %cl,-0x18(%ebp)
  10a6aa:	8b 55 e8             	mov    -0x18(%ebp),%edx
  10a6ad:	09 d0                	or     %edx,%eax
  10a6af:	89 45 e0             	mov    %eax,-0x20(%ebp)
  10a6b2:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  10a6b5:	89 f1                	mov    %esi,%ecx
  10a6b7:	d3 e7                	shl    %cl,%edi
  10a6b9:	8b 4d f8             	mov    -0x8(%ebp),%ecx
  10a6bc:	8b 55 fc             	mov    -0x4(%ebp),%edx
  10a6bf:	89 45 f4             	mov    %eax,-0xc(%ebp)
  10a6c2:	d3 6d f4             	shrl   %cl,-0xc(%ebp)
  10a6c5:	89 f1                	mov    %esi,%ecx
  10a6c7:	d3 e0                	shl    %cl,%eax
  10a6c9:	8b 4d f8             	mov    -0x8(%ebp),%ecx
  10a6cc:	d3 ea                	shr    %cl,%edx
  10a6ce:	09 d0                	or     %edx,%eax
  10a6d0:	8b 55 f4             	mov    -0xc(%ebp),%edx
  10a6d3:	89 45 e8             	mov    %eax,-0x18(%ebp)
  10a6d6:	f7 75 e0             	divl   -0x20(%ebp)
  10a6d9:	89 f1                	mov    %esi,%ecx
  10a6db:	d3 65 fc             	shll   %cl,-0x4(%ebp)
  10a6de:	89 45 e0             	mov    %eax,-0x20(%ebp)
  10a6e1:	89 d1                	mov    %edx,%ecx
  10a6e3:	f7 e7                	mul    %edi
  10a6e5:	89 c6                	mov    %eax,%esi
  10a6e7:	39 ca                	cmp    %ecx,%edx
  10a6e9:	77 07                	ja     10a6f2 <__udivdi3+0x102>
  10a6eb:	75 08                	jne    10a6f5 <__udivdi3+0x105>
  10a6ed:	3b 75 fc             	cmp    -0x4(%ebp),%esi
  10a6f0:	76 03                	jbe    10a6f5 <__udivdi3+0x105>
  10a6f2:	ff 4d e0             	decl   -0x20(%ebp)
  10a6f5:	31 c9                	xor    %ecx,%ecx
  10a6f7:	8b 75 e0             	mov    -0x20(%ebp),%esi
  10a6fa:	89 75 ec             	mov    %esi,-0x14(%ebp)
  10a6fd:	8b 45 ec             	mov    -0x14(%ebp),%eax
  10a700:	89 4d f0             	mov    %ecx,-0x10(%ebp)
  10a703:	8b 55 f0             	mov    -0x10(%ebp),%edx
  10a706:	5e                   	pop    %esi
  10a707:	5f                   	pop    %edi
  10a708:	89 ec                	mov    %ebp,%esp
  10a70a:	5d                   	pop    %ebp
  10a70b:	c3                   	ret    

0010a70c <Letext>:
  10a70c:	00 00                	add    %al,(%eax)
	...

0010a710 <__umoddi3>:
  10a710:	55                   	push   %ebp
  10a711:	89 e5                	mov    %esp,%ebp
  10a713:	83 ec 30             	sub    $0x30,%esp
  10a716:	57                   	push   %edi
  10a717:	56                   	push   %esi
  10a718:	8b 55 10             	mov    0x10(%ebp),%edx
  10a71b:	8b 4d 14             	mov    0x14(%ebp),%ecx
  10a71e:	8d 45 f8             	lea    -0x8(%ebp),%eax
  10a721:	89 45 f4             	mov    %eax,-0xc(%ebp)
  10a724:	8b 45 08             	mov    0x8(%ebp),%eax
  10a727:	89 55 f0             	mov    %edx,-0x10(%ebp)
  10a72a:	8b 55 0c             	mov    0xc(%ebp),%edx
  10a72d:	89 4d ec             	mov    %ecx,-0x14(%ebp)
  10a730:	89 45 e8             	mov    %eax,-0x18(%ebp)
  10a733:	89 55 dc             	mov    %edx,-0x24(%ebp)
  10a736:	85 c9                	test   %ecx,%ecx
  10a738:	75 4e                	jne    10a788 <__umoddi3+0x78>
  10a73a:	39 55 f0             	cmp    %edx,-0x10(%ebp)
  10a73d:	76 05                	jbe    10a744 <__umoddi3+0x34>
  10a73f:	f7 75 f0             	divl   -0x10(%ebp)
  10a742:	eb 25                	jmp    10a769 <__umoddi3+0x59>
  10a744:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
  10a748:	75 0d                	jne    10a757 <__umoddi3+0x47>
  10a74a:	b8 01 00 00 00       	mov    $0x1,%eax
  10a74f:	31 d2                	xor    %edx,%edx
  10a751:	f7 75 f0             	divl   -0x10(%ebp)
  10a754:	89 45 f0             	mov    %eax,-0x10(%ebp)
  10a757:	8b 45 dc             	mov    -0x24(%ebp),%eax
  10a75a:	8b 55 ec             	mov    -0x14(%ebp),%edx
  10a75d:	f7 75 f0             	divl   -0x10(%ebp)
  10a760:	8b 45 e8             	mov    -0x18(%ebp),%eax
  10a763:	89 55 dc             	mov    %edx,-0x24(%ebp)
  10a766:	f7 75 f0             	divl   -0x10(%ebp)
  10a769:	89 55 e8             	mov    %edx,-0x18(%ebp)
  10a76c:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
  10a770:	0f 84 16 01 00 00    	je     10a88c <__umoddi3+0x17c>
  10a776:	8b 75 e8             	mov    -0x18(%ebp),%esi
  10a779:	8b 4d f4             	mov    -0xc(%ebp),%ecx
  10a77c:	31 ff                	xor    %edi,%edi
  10a77e:	89 31                	mov    %esi,(%ecx)
  10a780:	89 79 04             	mov    %edi,0x4(%ecx)
  10a783:	e9 04 01 00 00       	jmp    10a88c <__umoddi3+0x17c>
  10a788:	8b 45 dc             	mov    -0x24(%ebp),%eax
  10a78b:	39 45 ec             	cmp    %eax,-0x14(%ebp)
  10a78e:	76 10                	jbe    10a7a0 <__umoddi3+0x90>
  10a790:	8b 75 08             	mov    0x8(%ebp),%esi
  10a793:	89 c7                	mov    %eax,%edi
  10a795:	89 75 f8             	mov    %esi,-0x8(%ebp)
  10a798:	89 7d fc             	mov    %edi,-0x4(%ebp)
  10a79b:	e9 ec 00 00 00       	jmp    10a88c <__umoddi3+0x17c>
  10a7a0:	0f bd 55 ec          	bsr    -0x14(%ebp),%edx
  10a7a4:	83 f2 1f             	xor    $0x1f,%edx
  10a7a7:	89 55 e4             	mov    %edx,-0x1c(%ebp)
  10a7aa:	75 44                	jne    10a7f0 <__umoddi3+0xe0>
  10a7ac:	8b 4d ec             	mov    -0x14(%ebp),%ecx
  10a7af:	39 4d dc             	cmp    %ecx,-0x24(%ebp)
  10a7b2:	77 0c                	ja     10a7c0 <__umoddi3+0xb0>
  10a7b4:	8b 45 f0             	mov    -0x10(%ebp),%eax
  10a7b7:	39 45 e8             	cmp    %eax,-0x18(%ebp)
  10a7ba:	72 16                	jb     10a7d2 <__umoddi3+0xc2>
  10a7bc:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
  10a7c0:	8b 4d dc             	mov    -0x24(%ebp),%ecx
  10a7c3:	8b 55 e8             	mov    -0x18(%ebp),%edx
  10a7c6:	2b 55 f0             	sub    -0x10(%ebp),%edx
  10a7c9:	1b 4d ec             	sbb    -0x14(%ebp),%ecx
  10a7cc:	89 4d dc             	mov    %ecx,-0x24(%ebp)
  10a7cf:	89 55 e8             	mov    %edx,-0x18(%ebp)
  10a7d2:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
  10a7d6:	0f 84 b0 00 00 00    	je     10a88c <__umoddi3+0x17c>
  10a7dc:	8b 75 e8             	mov    -0x18(%ebp),%esi
  10a7df:	8b 7d dc             	mov    -0x24(%ebp),%edi
  10a7e2:	8b 45 f4             	mov    -0xc(%ebp),%eax
  10a7e5:	e9 9d 00 00 00       	jmp    10a887 <__umoddi3+0x177>
  10a7ea:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
  10a7f0:	8b 55 e4             	mov    -0x1c(%ebp),%edx
  10a7f3:	8b 45 f0             	mov    -0x10(%ebp),%eax
  10a7f6:	c7 45 e0 20 00 00 00 	movl   $0x20,-0x20(%ebp)
  10a7fd:	29 55 e0             	sub    %edx,-0x20(%ebp)
  10a800:	89 d1                	mov    %edx,%ecx
  10a802:	d3 65 ec             	shll   %cl,-0x14(%ebp)
  10a805:	8b 4d e0             	mov    -0x20(%ebp),%ecx
  10a808:	d3 e8                	shr    %cl,%eax
  10a80a:	89 d1                	mov    %edx,%ecx
  10a80c:	8b 55 dc             	mov    -0x24(%ebp),%edx
  10a80f:	d3 65 f0             	shll   %cl,-0x10(%ebp)
  10a812:	8b 4d e0             	mov    -0x20(%ebp),%ecx
  10a815:	d3 ea                	shr    %cl,%edx
  10a817:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
  10a81a:	09 45 ec             	or     %eax,-0x14(%ebp)
  10a81d:	8b 45 e8             	mov    -0x18(%ebp),%eax
  10a820:	d3 65 dc             	shll   %cl,-0x24(%ebp)
  10a823:	8b 4d e0             	mov    -0x20(%ebp),%ecx
  10a826:	d3 e8                	shr    %cl,%eax
  10a828:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
  10a82b:	09 45 dc             	or     %eax,-0x24(%ebp)
  10a82e:	8b 45 dc             	mov    -0x24(%ebp),%eax
  10a831:	f7 75 ec             	divl   -0x14(%ebp)
  10a834:	89 55 dc             	mov    %edx,-0x24(%ebp)
  10a837:	f7 65 f0             	mull   -0x10(%ebp)
  10a83a:	d3 65 e8             	shll   %cl,-0x18(%ebp)
  10a83d:	89 45 d8             	mov    %eax,-0x28(%ebp)
  10a840:	3b 55 dc             	cmp    -0x24(%ebp),%edx
  10a843:	77 0a                	ja     10a84f <__umoddi3+0x13f>
  10a845:	75 14                	jne    10a85b <__umoddi3+0x14b>
  10a847:	8b 45 e8             	mov    -0x18(%ebp),%eax
  10a84a:	39 45 d8             	cmp    %eax,-0x28(%ebp)
  10a84d:	76 0c                	jbe    10a85b <__umoddi3+0x14b>
  10a84f:	8b 4d d8             	mov    -0x28(%ebp),%ecx
  10a852:	2b 4d f0             	sub    -0x10(%ebp),%ecx
  10a855:	1b 55 ec             	sbb    -0x14(%ebp),%edx
  10a858:	89 4d d8             	mov    %ecx,-0x28(%ebp)
  10a85b:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
  10a85f:	74 2b                	je     10a88c <__umoddi3+0x17c>
  10a861:	8b 4d dc             	mov    -0x24(%ebp),%ecx
  10a864:	8b 45 e8             	mov    -0x18(%ebp),%eax
  10a867:	2b 45 d8             	sub    -0x28(%ebp),%eax
  10a86a:	19 d1                	sbb    %edx,%ecx
  10a86c:	89 4d dc             	mov    %ecx,-0x24(%ebp)
  10a86f:	89 ca                	mov    %ecx,%edx
  10a871:	8b 4d e0             	mov    -0x20(%ebp),%ecx
  10a874:	d3 e2                	shl    %cl,%edx
  10a876:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
  10a879:	8b 7d dc             	mov    -0x24(%ebp),%edi
  10a87c:	d3 e8                	shr    %cl,%eax
  10a87e:	89 c6                	mov    %eax,%esi
  10a880:	8b 45 f4             	mov    -0xc(%ebp),%eax
  10a883:	09 d6                	or     %edx,%esi
  10a885:	d3 ef                	shr    %cl,%edi
  10a887:	89 30                	mov    %esi,(%eax)
  10a889:	89 78 04             	mov    %edi,0x4(%eax)
  10a88c:	8b 45 f8             	mov    -0x8(%ebp),%eax
  10a88f:	8b 55 fc             	mov    -0x4(%ebp),%edx
  10a892:	5e                   	pop    %esi
  10a893:	5f                   	pop    %edi
  10a894:	89 ec                	mov    %ebp,%esp
  10a896:	5d                   	pop    %ebp
  10a897:	c3                   	ret    

0010a898 <Letext>:
	...

0010a8a0 <dyn_call>:
  10a8a0:	55                   	push   %ebp
  10a8a1:	53                   	push   %ebx
  10a8a2:	89 e5                	mov    %esp,%ebp
  10a8a4:	8b 45 0c             	mov    0xc(%ebp),%eax
  10a8a7:	8b 5d 10             	mov    0x10(%ebp),%ebx
  10a8aa:	8b 55 14             	mov    0x14(%ebp),%edx
  10a8ad:	50                   	push   %eax
  10a8ae:	52                   	push   %edx
  10a8af:	b8 04 00 00 00       	mov    $0x4,%eax
  10a8b4:	f7 e2                	mul    %edx
  10a8b6:	01 c3                	add    %eax,%ebx
  10a8b8:	5a                   	pop    %edx
  10a8b9:	58                   	pop    %eax
  10a8ba:	09 d2                	or     %edx,%edx
  10a8bc:	74 0c                	je     10a8ca <dyn_call.lpe>
  10a8be:	89 d1                	mov    %edx,%ecx

0010a8c0 <dyn_call.lpb>:
  10a8c0:	81 eb 04 00 00 00    	sub    $0x4,%ebx
  10a8c6:	ff 33                	pushl  (%ebx)
  10a8c8:	e2 f6                	loop   10a8c0 <dyn_call.lpb>

0010a8ca <dyn_call.lpe>:
  10a8ca:	ff d0                	call   *%eax
  10a8cc:	89 ec                	mov    %ebp,%esp
  10a8ce:	5b                   	pop    %ebx
  10a8cf:	5d                   	pop    %ebp
  10a8d0:	c3                   	ret    
  10a8d1:	00 00                	add    %al,(%eax)
	...

0010a8d4 <llist_create>:
  10a8d4:	55                   	push   %ebp
  10a8d5:	89 e5                	mov    %esp,%ebp
  10a8d7:	83 ec 18             	sub    $0x18,%esp
  10a8da:	c7 04 24 08 00 00 00 	movl   $0x8,(%esp)
  10a8e1:	e8 83 86 ff ff       	call   102f69 <malloc>
  10a8e6:	89 45 fc             	mov    %eax,-0x4(%ebp)
  10a8e9:	8b 45 fc             	mov    -0x4(%ebp),%eax
  10a8ec:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
  10a8f2:	8b 45 fc             	mov    -0x4(%ebp),%eax
  10a8f5:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
  10a8fc:	8b 45 fc             	mov    -0x4(%ebp),%eax
  10a8ff:	c9                   	leave  
  10a900:	c3                   	ret    

0010a901 <llist_destroy>:
  10a901:	55                   	push   %ebp
  10a902:	89 e5                	mov    %esp,%ebp
  10a904:	83 ec 08             	sub    $0x8,%esp
  10a907:	8b 45 08             	mov    0x8(%ebp),%eax
  10a90a:	89 04 24             	mov    %eax,(%esp)
  10a90d:	e8 96 00 00 00       	call   10a9a8 <llist_pop>
  10a912:	85 c0                	test   %eax,%eax
  10a914:	75 f1                	jne    10a907 <llist_destroy+0x6>
  10a916:	8b 45 08             	mov    0x8(%ebp),%eax
  10a919:	89 04 24             	mov    %eax,(%esp)
  10a91c:	e8 7c 86 ff ff       	call   102f9d <free>
  10a921:	c9                   	leave  
  10a922:	c3                   	ret    

0010a923 <llist_size>:
  10a923:	55                   	push   %ebp
  10a924:	89 e5                	mov    %esp,%ebp
  10a926:	83 ec 04             	sub    $0x4,%esp
  10a929:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
  10a92d:	74 09                	je     10a938 <llist_size+0x15>
  10a92f:	8b 45 08             	mov    0x8(%ebp),%eax
  10a932:	8b 00                	mov    (%eax),%eax
  10a934:	85 c0                	test   %eax,%eax
  10a936:	75 09                	jne    10a941 <llist_size+0x1e>
  10a938:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
  10a93f:	eb 09                	jmp    10a94a <llist_size+0x27>
  10a941:	8b 45 08             	mov    0x8(%ebp),%eax
  10a944:	8b 40 04             	mov    0x4(%eax),%eax
  10a947:	89 45 fc             	mov    %eax,-0x4(%ebp)
  10a94a:	8b 45 fc             	mov    -0x4(%ebp),%eax
  10a94d:	c9                   	leave  
  10a94e:	c3                   	ret    

0010a94f <llist_push>:
  10a94f:	55                   	push   %ebp
  10a950:	89 e5                	mov    %esp,%ebp
  10a952:	83 ec 18             	sub    $0x18,%esp
  10a955:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
  10a959:	75 09                	jne    10a964 <llist_push+0x15>
  10a95b:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
  10a962:	eb 3f                	jmp    10a9a3 <llist_push+0x54>
  10a964:	c7 04 24 08 00 00 00 	movl   $0x8,(%esp)
  10a96b:	e8 f9 85 ff ff       	call   102f69 <malloc>
  10a970:	89 45 fc             	mov    %eax,-0x4(%ebp)
  10a973:	8b 55 fc             	mov    -0x4(%ebp),%edx
  10a976:	8b 45 0c             	mov    0xc(%ebp),%eax
  10a979:	89 42 04             	mov    %eax,0x4(%edx)
  10a97c:	8b 45 08             	mov    0x8(%ebp),%eax
  10a97f:	8b 10                	mov    (%eax),%edx
  10a981:	8b 45 fc             	mov    -0x4(%ebp),%eax
  10a984:	89 10                	mov    %edx,(%eax)
  10a986:	8b 55 08             	mov    0x8(%ebp),%edx
  10a989:	8b 45 fc             	mov    -0x4(%ebp),%eax
  10a98c:	89 02                	mov    %eax,(%edx)
  10a98e:	8b 45 08             	mov    0x8(%ebp),%eax
  10a991:	8b 40 04             	mov    0x4(%eax),%eax
  10a994:	8d 50 01             	lea    0x1(%eax),%edx
  10a997:	8b 45 08             	mov    0x8(%ebp),%eax
  10a99a:	89 50 04             	mov    %edx,0x4(%eax)
  10a99d:	8b 45 08             	mov    0x8(%ebp),%eax
  10a9a0:	89 45 ec             	mov    %eax,-0x14(%ebp)
  10a9a3:	8b 45 ec             	mov    -0x14(%ebp),%eax
  10a9a6:	c9                   	leave  
  10a9a7:	c3                   	ret    

0010a9a8 <llist_pop>:
  10a9a8:	55                   	push   %ebp
  10a9a9:	89 e5                	mov    %esp,%ebp
  10a9ab:	83 ec 18             	sub    $0x18,%esp
  10a9ae:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
  10a9b2:	75 09                	jne    10a9bd <llist_pop+0x15>
  10a9b4:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
  10a9bb:	eb 51                	jmp    10aa0e <llist_pop+0x66>
  10a9bd:	8b 45 08             	mov    0x8(%ebp),%eax
  10a9c0:	8b 00                	mov    (%eax),%eax
  10a9c2:	85 c0                	test   %eax,%eax
  10a9c4:	74 3b                	je     10aa01 <llist_pop+0x59>
  10a9c6:	8b 45 08             	mov    0x8(%ebp),%eax
  10a9c9:	8b 00                	mov    (%eax),%eax
  10a9cb:	8b 40 04             	mov    0x4(%eax),%eax
  10a9ce:	89 45 fc             	mov    %eax,-0x4(%ebp)
  10a9d1:	8b 45 08             	mov    0x8(%ebp),%eax
  10a9d4:	8b 00                	mov    (%eax),%eax
  10a9d6:	89 45 f8             	mov    %eax,-0x8(%ebp)
  10a9d9:	8b 45 08             	mov    0x8(%ebp),%eax
  10a9dc:	8b 00                	mov    (%eax),%eax
  10a9de:	8b 10                	mov    (%eax),%edx
  10a9e0:	8b 45 08             	mov    0x8(%ebp),%eax
  10a9e3:	89 10                	mov    %edx,(%eax)
  10a9e5:	8b 45 f8             	mov    -0x8(%ebp),%eax
  10a9e8:	89 04 24             	mov    %eax,(%esp)
  10a9eb:	e8 ad 85 ff ff       	call   102f9d <free>
  10a9f0:	8b 45 08             	mov    0x8(%ebp),%eax
  10a9f3:	8b 40 04             	mov    0x4(%eax),%eax
  10a9f6:	8d 50 ff             	lea    -0x1(%eax),%edx
  10a9f9:	8b 45 08             	mov    0x8(%ebp),%eax
  10a9fc:	89 50 04             	mov    %edx,0x4(%eax)
  10a9ff:	eb 07                	jmp    10aa08 <llist_pop+0x60>
  10aa01:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
  10aa08:	8b 45 fc             	mov    -0x4(%ebp),%eax
  10aa0b:	89 45 ec             	mov    %eax,-0x14(%ebp)
  10aa0e:	8b 45 ec             	mov    -0x14(%ebp),%eax
  10aa11:	c9                   	leave  
  10aa12:	c3                   	ret    

0010aa13 <llist_get_node_at>:
  10aa13:	55                   	push   %ebp
  10aa14:	89 e5                	mov    %esp,%ebp
  10aa16:	83 ec 14             	sub    $0x14,%esp
  10aa19:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
  10aa1d:	74 09                	je     10aa28 <llist_get_node_at+0x15>
  10aa1f:	8b 45 08             	mov    0x8(%ebp),%eax
  10aa22:	8b 00                	mov    (%eax),%eax
  10aa24:	85 c0                	test   %eax,%eax
  10aa26:	75 09                	jne    10aa31 <llist_get_node_at+0x1e>
  10aa28:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
  10aa2f:	eb 51                	jmp    10aa82 <llist_get_node_at+0x6f>
  10aa31:	8b 45 08             	mov    0x8(%ebp),%eax
  10aa34:	8b 00                	mov    (%eax),%eax
  10aa36:	89 45 f8             	mov    %eax,-0x8(%ebp)
  10aa39:	8b 45 0c             	mov    0xc(%ebp),%eax
  10aa3c:	89 45 fc             	mov    %eax,-0x4(%ebp)
  10aa3f:	8b 45 08             	mov    0x8(%ebp),%eax
  10aa42:	8b 40 04             	mov    0x4(%eax),%eax
  10aa45:	83 e8 01             	sub    $0x1,%eax
  10aa48:	3b 45 0c             	cmp    0xc(%ebp),%eax
  10aa4b:	73 20                	jae    10aa6d <llist_get_node_at+0x5a>
  10aa4d:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
  10aa54:	eb 2c                	jmp    10aa82 <llist_get_node_at+0x6f>
  10aa56:	8b 45 f8             	mov    -0x8(%ebp),%eax
  10aa59:	8b 00                	mov    (%eax),%eax
  10aa5b:	89 45 f8             	mov    %eax,-0x8(%ebp)
  10aa5e:	83 7d f8 00          	cmpl   $0x0,-0x8(%ebp)
  10aa62:	75 09                	jne    10aa6d <llist_get_node_at+0x5a>
  10aa64:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
  10aa6b:	eb 15                	jmp    10aa82 <llist_get_node_at+0x6f>
  10aa6d:	83 7d fc 00          	cmpl   $0x0,-0x4(%ebp)
  10aa71:	0f 95 c0             	setne  %al
  10aa74:	83 6d fc 01          	subl   $0x1,-0x4(%ebp)
  10aa78:	84 c0                	test   %al,%al
  10aa7a:	75 da                	jne    10aa56 <llist_get_node_at+0x43>
  10aa7c:	8b 45 f8             	mov    -0x8(%ebp),%eax
  10aa7f:	89 45 ec             	mov    %eax,-0x14(%ebp)
  10aa82:	8b 45 ec             	mov    -0x14(%ebp),%eax
  10aa85:	c9                   	leave  
  10aa86:	c3                   	ret    

0010aa87 <llist_get>:
  10aa87:	55                   	push   %ebp
  10aa88:	89 e5                	mov    %esp,%ebp
  10aa8a:	83 ec 1c             	sub    $0x1c,%esp
  10aa8d:	8b 45 0c             	mov    0xc(%ebp),%eax
  10aa90:	89 44 24 04          	mov    %eax,0x4(%esp)
  10aa94:	8b 45 08             	mov    0x8(%ebp),%eax
  10aa97:	89 04 24             	mov    %eax,(%esp)
  10aa9a:	e8 74 ff ff ff       	call   10aa13 <llist_get_node_at>
  10aa9f:	89 45 fc             	mov    %eax,-0x4(%ebp)
  10aaa2:	83 7d fc 00          	cmpl   $0x0,-0x4(%ebp)
  10aaa6:	75 09                	jne    10aab1 <llist_get+0x2a>
  10aaa8:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
  10aaaf:	eb 09                	jmp    10aaba <llist_get+0x33>
  10aab1:	8b 45 fc             	mov    -0x4(%ebp),%eax
  10aab4:	8b 40 04             	mov    0x4(%eax),%eax
  10aab7:	89 45 ec             	mov    %eax,-0x14(%ebp)
  10aaba:	8b 45 ec             	mov    -0x14(%ebp),%eax
  10aabd:	c9                   	leave  
  10aabe:	c3                   	ret    

0010aabf <llist_insert>:
  10aabf:	55                   	push   %ebp
  10aac0:	89 e5                	mov    %esp,%ebp
  10aac2:	83 ec 28             	sub    $0x28,%esp
  10aac5:	c7 04 24 08 00 00 00 	movl   $0x8,(%esp)
  10aacc:	e8 98 84 ff ff       	call   102f69 <malloc>
  10aad1:	89 45 f8             	mov    %eax,-0x8(%ebp)
  10aad4:	8b 55 f8             	mov    -0x8(%ebp),%edx
  10aad7:	8b 45 10             	mov    0x10(%ebp),%eax
  10aada:	89 42 04             	mov    %eax,0x4(%edx)
  10aadd:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
  10aae1:	75 09                	jne    10aaec <llist_insert+0x2d>
  10aae3:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
  10aaea:	eb 68                	jmp    10ab54 <llist_insert+0x95>
  10aaec:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
  10aaf0:	74 3b                	je     10ab2d <llist_insert+0x6e>
  10aaf2:	8b 45 0c             	mov    0xc(%ebp),%eax
  10aaf5:	83 e8 01             	sub    $0x1,%eax
  10aaf8:	89 44 24 04          	mov    %eax,0x4(%esp)
  10aafc:	8b 45 08             	mov    0x8(%ebp),%eax
  10aaff:	89 04 24             	mov    %eax,(%esp)
  10ab02:	e8 0c ff ff ff       	call   10aa13 <llist_get_node_at>
  10ab07:	89 45 fc             	mov    %eax,-0x4(%ebp)
  10ab0a:	83 7d fc 00          	cmpl   $0x0,-0x4(%ebp)
  10ab0e:	75 09                	jne    10ab19 <llist_insert+0x5a>
  10ab10:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
  10ab17:	eb 3b                	jmp    10ab54 <llist_insert+0x95>
  10ab19:	8b 45 fc             	mov    -0x4(%ebp),%eax
  10ab1c:	8b 10                	mov    (%eax),%edx
  10ab1e:	8b 45 f8             	mov    -0x8(%ebp),%eax
  10ab21:	89 10                	mov    %edx,(%eax)
  10ab23:	8b 55 fc             	mov    -0x4(%ebp),%edx
  10ab26:	8b 45 f8             	mov    -0x8(%ebp),%eax
  10ab29:	89 02                	mov    %eax,(%edx)
  10ab2b:	eb 12                	jmp    10ab3f <llist_insert+0x80>
  10ab2d:	8b 45 08             	mov    0x8(%ebp),%eax
  10ab30:	8b 10                	mov    (%eax),%edx
  10ab32:	8b 45 f8             	mov    -0x8(%ebp),%eax
  10ab35:	89 10                	mov    %edx,(%eax)
  10ab37:	8b 55 08             	mov    0x8(%ebp),%edx
  10ab3a:	8b 45 f8             	mov    -0x8(%ebp),%eax
  10ab3d:	89 02                	mov    %eax,(%edx)
  10ab3f:	8b 45 08             	mov    0x8(%ebp),%eax
  10ab42:	8b 40 04             	mov    0x4(%eax),%eax
  10ab45:	8d 50 01             	lea    0x1(%eax),%edx
  10ab48:	8b 45 08             	mov    0x8(%ebp),%eax
  10ab4b:	89 50 04             	mov    %edx,0x4(%eax)
  10ab4e:	8b 45 08             	mov    0x8(%ebp),%eax
  10ab51:	89 45 ec             	mov    %eax,-0x14(%ebp)
  10ab54:	8b 45 ec             	mov    -0x14(%ebp),%eax
  10ab57:	c9                   	leave  
  10ab58:	c3                   	ret    

0010ab59 <llist_remove>:
  10ab59:	55                   	push   %ebp
  10ab5a:	89 e5                	mov    %esp,%ebp
  10ab5c:	83 ec 28             	sub    $0x28,%esp
  10ab5f:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
  10ab63:	75 0c                	jne    10ab71 <llist_remove+0x18>
  10ab65:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
  10ab6c:	e9 ab 00 00 00       	jmp    10ac1c <llist_remove+0xc3>
  10ab71:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
  10ab75:	74 58                	je     10abcf <llist_remove+0x76>
  10ab77:	8b 45 0c             	mov    0xc(%ebp),%eax
  10ab7a:	83 e8 01             	sub    $0x1,%eax
  10ab7d:	89 44 24 04          	mov    %eax,0x4(%esp)
  10ab81:	8b 45 08             	mov    0x8(%ebp),%eax
  10ab84:	89 04 24             	mov    %eax,(%esp)
  10ab87:	e8 87 fe ff ff       	call   10aa13 <llist_get_node_at>
  10ab8c:	89 45 fc             	mov    %eax,-0x4(%ebp)
  10ab8f:	83 7d fc 00          	cmpl   $0x0,-0x4(%ebp)
  10ab93:	74 09                	je     10ab9e <llist_remove+0x45>
  10ab95:	8b 45 fc             	mov    -0x4(%ebp),%eax
  10ab98:	8b 00                	mov    (%eax),%eax
  10ab9a:	85 c0                	test   %eax,%eax
  10ab9c:	75 09                	jne    10aba7 <llist_remove+0x4e>
  10ab9e:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
  10aba5:	eb 75                	jmp    10ac1c <llist_remove+0xc3>
  10aba7:	8b 45 fc             	mov    -0x4(%ebp),%eax
  10abaa:	8b 00                	mov    (%eax),%eax
  10abac:	89 45 f8             	mov    %eax,-0x8(%ebp)
  10abaf:	8b 45 f8             	mov    -0x8(%ebp),%eax
  10abb2:	8b 10                	mov    (%eax),%edx
  10abb4:	8b 45 fc             	mov    -0x4(%ebp),%eax
  10abb7:	89 10                	mov    %edx,(%eax)
  10abb9:	8b 45 f8             	mov    -0x8(%ebp),%eax
  10abbc:	8b 40 04             	mov    0x4(%eax),%eax
  10abbf:	89 45 f4             	mov    %eax,-0xc(%ebp)
  10abc2:	8b 45 f8             	mov    -0x8(%ebp),%eax
  10abc5:	89 04 24             	mov    %eax,(%esp)
  10abc8:	e8 d0 83 ff ff       	call   102f9d <free>
  10abcd:	eb 38                	jmp    10ac07 <llist_remove+0xae>
  10abcf:	8b 45 08             	mov    0x8(%ebp),%eax
  10abd2:	8b 00                	mov    (%eax),%eax
  10abd4:	85 c0                	test   %eax,%eax
  10abd6:	75 09                	jne    10abe1 <llist_remove+0x88>
  10abd8:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
  10abdf:	eb 3b                	jmp    10ac1c <llist_remove+0xc3>
  10abe1:	8b 45 08             	mov    0x8(%ebp),%eax
  10abe4:	8b 00                	mov    (%eax),%eax
  10abe6:	89 45 f8             	mov    %eax,-0x8(%ebp)
  10abe9:	8b 45 f8             	mov    -0x8(%ebp),%eax
  10abec:	8b 10                	mov    (%eax),%edx
  10abee:	8b 45 08             	mov    0x8(%ebp),%eax
  10abf1:	89 10                	mov    %edx,(%eax)
  10abf3:	8b 45 f8             	mov    -0x8(%ebp),%eax
  10abf6:	8b 40 04             	mov    0x4(%eax),%eax
  10abf9:	89 45 f4             	mov    %eax,-0xc(%ebp)
  10abfc:	8b 45 f8             	mov    -0x8(%ebp),%eax
  10abff:	89 04 24             	mov    %eax,(%esp)
  10ac02:	e8 96 83 ff ff       	call   102f9d <free>
  10ac07:	8b 45 08             	mov    0x8(%ebp),%eax
  10ac0a:	8b 40 04             	mov    0x4(%eax),%eax
  10ac0d:	8d 50 ff             	lea    -0x1(%eax),%edx
  10ac10:	8b 45 08             	mov    0x8(%ebp),%eax
  10ac13:	89 50 04             	mov    %edx,0x4(%eax)
  10ac16:	8b 45 f4             	mov    -0xc(%ebp),%eax
  10ac19:	89 45 ec             	mov    %eax,-0x14(%ebp)
  10ac1c:	8b 45 ec             	mov    -0x14(%ebp),%eax
  10ac1f:	c9                   	leave  
  10ac20:	c3                   	ret    

0010ac21 <llist_find>:
  10ac21:	55                   	push   %ebp
  10ac22:	89 e5                	mov    %esp,%ebp
  10ac24:	83 ec 1c             	sub    $0x1c,%esp
  10ac27:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
  10ac2e:	eb 14                	jmp    10ac44 <llist_find+0x23>
  10ac30:	8b 45 f8             	mov    -0x8(%ebp),%eax
  10ac33:	3b 45 0c             	cmp    0xc(%ebp),%eax
  10ac36:	75 08                	jne    10ac40 <llist_find+0x1f>
  10ac38:	8b 45 fc             	mov    -0x4(%ebp),%eax
  10ac3b:	89 45 ec             	mov    %eax,-0x14(%ebp)
  10ac3e:	eb 26                	jmp    10ac66 <llist_find+0x45>
  10ac40:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
  10ac44:	8b 45 fc             	mov    -0x4(%ebp),%eax
  10ac47:	89 44 24 04          	mov    %eax,0x4(%esp)
  10ac4b:	8b 45 08             	mov    0x8(%ebp),%eax
  10ac4e:	89 04 24             	mov    %eax,(%esp)
  10ac51:	e8 31 fe ff ff       	call   10aa87 <llist_get>
  10ac56:	89 45 f8             	mov    %eax,-0x8(%ebp)
  10ac59:	83 7d f8 00          	cmpl   $0x0,-0x8(%ebp)
  10ac5d:	75 d1                	jne    10ac30 <llist_find+0xf>
  10ac5f:	c7 45 ec ff ff ff ff 	movl   $0xffffffff,-0x14(%ebp)
  10ac66:	8b 45 ec             	mov    -0x14(%ebp),%eax
  10ac69:	c9                   	leave  
  10ac6a:	c3                   	ret    

0010ac6b <llist_copy>:
  10ac6b:	55                   	push   %ebp
  10ac6c:	89 e5                	mov    %esp,%ebp
  10ac6e:	83 ec 18             	sub    $0x18,%esp
  10ac71:	e8 5e fc ff ff       	call   10a8d4 <llist_create>
  10ac76:	89 45 fc             	mov    %eax,-0x4(%ebp)
  10ac79:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  10ac80:	eb 16                	jmp    10ac98 <llist_copy+0x2d>
  10ac82:	8b 45 f8             	mov    -0x8(%ebp),%eax
  10ac85:	89 44 24 04          	mov    %eax,0x4(%esp)
  10ac89:	8b 45 fc             	mov    -0x4(%ebp),%eax
  10ac8c:	89 04 24             	mov    %eax,(%esp)
  10ac8f:	e8 bb fc ff ff       	call   10a94f <llist_push>
  10ac94:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
  10ac98:	8b 45 f4             	mov    -0xc(%ebp),%eax
  10ac9b:	89 44 24 04          	mov    %eax,0x4(%esp)
  10ac9f:	8b 45 08             	mov    0x8(%ebp),%eax
  10aca2:	89 04 24             	mov    %eax,(%esp)
  10aca5:	e8 dd fd ff ff       	call   10aa87 <llist_get>
  10acaa:	89 45 f8             	mov    %eax,-0x8(%ebp)
  10acad:	83 7d f8 00          	cmpl   $0x0,-0x8(%ebp)
  10acb1:	75 cf                	jne    10ac82 <llist_copy+0x17>
  10acb3:	8b 45 fc             	mov    -0x4(%ebp),%eax
  10acb6:	c9                   	leave  
  10acb7:	c3                   	ret    

0010acb8 <pack_create>:
  10acb8:	55                   	push   %ebp
  10acb9:	89 e5                	mov    %esp,%ebp
  10acbb:	83 ec 18             	sub    $0x18,%esp
  10acbe:	c7 04 24 08 00 00 00 	movl   $0x8,(%esp)
  10acc5:	e8 9f 82 ff ff       	call   102f69 <malloc>
  10acca:	89 45 fc             	mov    %eax,-0x4(%ebp)
  10accd:	8b 55 fc             	mov    -0x4(%ebp),%edx
  10acd0:	8b 45 08             	mov    0x8(%ebp),%eax
  10acd3:	89 42 04             	mov    %eax,0x4(%edx)
  10acd6:	8b 55 fc             	mov    -0x4(%ebp),%edx
  10acd9:	8b 45 08             	mov    0x8(%ebp),%eax
  10acdc:	89 02                	mov    %eax,(%edx)
  10acde:	8b 45 fc             	mov    -0x4(%ebp),%eax
  10ace1:	c9                   	leave  
  10ace2:	c3                   	ret    

0010ace3 <packstr>:
  10ace3:	55                   	push   %ebp
  10ace4:	89 e5                	mov    %esp,%ebp
  10ace6:	53                   	push   %ebx
  10ace7:	83 ec 14             	sub    $0x14,%esp
  10acea:	8b 45 08             	mov    0x8(%ebp),%eax
  10aced:	8b 00                	mov    (%eax),%eax
  10acef:	89 c2                	mov    %eax,%edx
  10acf1:	8b 45 0c             	mov    0xc(%ebp),%eax
  10acf4:	89 44 24 04          	mov    %eax,0x4(%esp)
  10acf8:	89 14 24             	mov    %edx,(%esp)
  10acfb:	e8 a9 11 00 00       	call   10bea9 <strcpy>
  10ad00:	8b 45 08             	mov    0x8(%ebp),%eax
  10ad03:	8b 18                	mov    (%eax),%ebx
  10ad05:	8b 45 0c             	mov    0xc(%ebp),%eax
  10ad08:	89 04 24             	mov    %eax,(%esp)
  10ad0b:	e8 2c 12 00 00       	call   10bf3c <strlen>
  10ad10:	83 c0 01             	add    $0x1,%eax
  10ad13:	8d 14 03             	lea    (%ebx,%eax,1),%edx
  10ad16:	8b 45 08             	mov    0x8(%ebp),%eax
  10ad19:	89 10                	mov    %edx,(%eax)
  10ad1b:	83 c4 14             	add    $0x14,%esp
  10ad1e:	5b                   	pop    %ebx
  10ad1f:	5d                   	pop    %ebp
  10ad20:	c3                   	ret    

0010ad21 <packnstr>:
  10ad21:	55                   	push   %ebp
  10ad22:	89 e5                	mov    %esp,%ebp
  10ad24:	53                   	push   %ebx
  10ad25:	83 ec 14             	sub    $0x14,%esp
  10ad28:	8b 45 08             	mov    0x8(%ebp),%eax
  10ad2b:	8b 00                	mov    (%eax),%eax
  10ad2d:	89 c2                	mov    %eax,%edx
  10ad2f:	8b 45 10             	mov    0x10(%ebp),%eax
  10ad32:	89 44 24 08          	mov    %eax,0x8(%esp)
  10ad36:	8b 45 0c             	mov    0xc(%ebp),%eax
  10ad39:	89 44 24 04          	mov    %eax,0x4(%esp)
  10ad3d:	89 14 24             	mov    %edx,(%esp)
  10ad40:	e8 37 13 00 00       	call   10c07c <strncpy>
  10ad45:	8b 45 08             	mov    0x8(%ebp),%eax
  10ad48:	8b 18                	mov    (%eax),%ebx
  10ad4a:	8b 45 08             	mov    0x8(%ebp),%eax
  10ad4d:	8b 00                	mov    (%eax),%eax
  10ad4f:	89 04 24             	mov    %eax,(%esp)
  10ad52:	e8 e5 11 00 00       	call   10bf3c <strlen>
  10ad57:	83 c0 01             	add    $0x1,%eax
  10ad5a:	8d 14 03             	lea    (%ebx,%eax,1),%edx
  10ad5d:	8b 45 08             	mov    0x8(%ebp),%eax
  10ad60:	89 10                	mov    %edx,(%eax)
  10ad62:	83 c4 14             	add    $0x14,%esp
  10ad65:	5b                   	pop    %ebx
  10ad66:	5d                   	pop    %ebp
  10ad67:	c3                   	ret    

0010ad68 <packdata>:
  10ad68:	55                   	push   %ebp
  10ad69:	89 e5                	mov    %esp,%ebp
  10ad6b:	83 ec 18             	sub    $0x18,%esp
  10ad6e:	8b 45 08             	mov    0x8(%ebp),%eax
  10ad71:	8b 00                	mov    (%eax),%eax
  10ad73:	89 c2                	mov    %eax,%edx
  10ad75:	8b 45 10             	mov    0x10(%ebp),%eax
  10ad78:	89 02                	mov    %eax,(%edx)
  10ad7a:	8b 45 08             	mov    0x8(%ebp),%eax
  10ad7d:	8b 00                	mov    (%eax),%eax
  10ad7f:	8d 50 04             	lea    0x4(%eax),%edx
  10ad82:	8b 45 08             	mov    0x8(%ebp),%eax
  10ad85:	89 10                	mov    %edx,(%eax)
  10ad87:	8b 45 08             	mov    0x8(%ebp),%eax
  10ad8a:	8b 10                	mov    (%eax),%edx
  10ad8c:	8b 45 10             	mov    0x10(%ebp),%eax
  10ad8f:	89 44 24 08          	mov    %eax,0x8(%esp)
  10ad93:	8b 45 0c             	mov    0xc(%ebp),%eax
  10ad96:	89 44 24 04          	mov    %eax,0x4(%esp)
  10ad9a:	89 14 24             	mov    %edx,(%esp)
  10ad9d:	e8 e2 0d 00 00       	call   10bb84 <memcpy>
  10ada2:	8b 45 08             	mov    0x8(%ebp),%eax
  10ada5:	8b 00                	mov    (%eax),%eax
  10ada7:	89 c2                	mov    %eax,%edx
  10ada9:	03 55 10             	add    0x10(%ebp),%edx
  10adac:	8b 45 08             	mov    0x8(%ebp),%eax
  10adaf:	89 10                	mov    %edx,(%eax)
  10adb1:	c9                   	leave  
  10adb2:	c3                   	ret    

0010adb3 <unpackstr>:
  10adb3:	55                   	push   %ebp
  10adb4:	89 e5                	mov    %esp,%ebp
  10adb6:	53                   	push   %ebx
  10adb7:	83 ec 04             	sub    $0x4,%esp
  10adba:	8b 45 08             	mov    0x8(%ebp),%eax
  10adbd:	8b 00                	mov    (%eax),%eax
  10adbf:	89 c2                	mov    %eax,%edx
  10adc1:	8b 45 0c             	mov    0xc(%ebp),%eax
  10adc4:	89 10                	mov    %edx,(%eax)
  10adc6:	8b 45 08             	mov    0x8(%ebp),%eax
  10adc9:	8b 18                	mov    (%eax),%ebx
  10adcb:	8b 45 08             	mov    0x8(%ebp),%eax
  10adce:	8b 00                	mov    (%eax),%eax
  10add0:	89 04 24             	mov    %eax,(%esp)
  10add3:	e8 64 11 00 00       	call   10bf3c <strlen>
  10add8:	83 c0 01             	add    $0x1,%eax
  10addb:	8d 14 03             	lea    (%ebx,%eax,1),%edx
  10adde:	8b 45 08             	mov    0x8(%ebp),%eax
  10ade1:	89 10                	mov    %edx,(%eax)
  10ade3:	83 c4 04             	add    $0x4,%esp
  10ade6:	5b                   	pop    %ebx
  10ade7:	5d                   	pop    %ebp
  10ade8:	c3                   	ret    

0010ade9 <unpackdata>:
  10ade9:	55                   	push   %ebp
  10adea:	89 e5                	mov    %esp,%ebp
  10adec:	83 ec 28             	sub    $0x28,%esp
  10adef:	8b 45 08             	mov    0x8(%ebp),%eax
  10adf2:	8b 00                	mov    (%eax),%eax
  10adf4:	8b 00                	mov    (%eax),%eax
  10adf6:	89 45 fc             	mov    %eax,-0x4(%ebp)
  10adf9:	8b 45 08             	mov    0x8(%ebp),%eax
  10adfc:	8b 00                	mov    (%eax),%eax
  10adfe:	8d 50 04             	lea    0x4(%eax),%edx
  10ae01:	8b 45 08             	mov    0x8(%ebp),%eax
  10ae04:	89 10                	mov    %edx,(%eax)
  10ae06:	8b 55 fc             	mov    -0x4(%ebp),%edx
  10ae09:	8b 45 08             	mov    0x8(%ebp),%eax
  10ae0c:	8b 00                	mov    (%eax),%eax
  10ae0e:	89 54 24 08          	mov    %edx,0x8(%esp)
  10ae12:	89 44 24 04          	mov    %eax,0x4(%esp)
  10ae16:	8b 45 0c             	mov    0xc(%ebp),%eax
  10ae19:	89 04 24             	mov    %eax,(%esp)
  10ae1c:	e8 63 0d 00 00       	call   10bb84 <memcpy>
  10ae21:	8b 45 08             	mov    0x8(%ebp),%eax
  10ae24:	8b 10                	mov    (%eax),%edx
  10ae26:	8b 45 fc             	mov    -0x4(%ebp),%eax
  10ae29:	01 c2                	add    %eax,%edx
  10ae2b:	8b 45 08             	mov    0x8(%ebp),%eax
  10ae2e:	89 10                	mov    %edx,(%eax)
  10ae30:	c9                   	leave  
  10ae31:	c3                   	ret    
	...

0010ae34 <perm_check>:
  10ae34:	55                   	push   %ebp
  10ae35:	89 e5                	mov    %esp,%ebp
  10ae37:	83 ec 14             	sub    $0x14,%esp
  10ae3a:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
  10ae41:	83 7d 10 01          	cmpl   $0x1,0x10(%ebp)
  10ae45:	74 06                	je     10ae4d <perm_check+0x19>
  10ae47:	83 7d 14 01          	cmpl   $0x1,0x14(%ebp)
  10ae4b:	75 0c                	jne    10ae59 <perm_check+0x25>
  10ae4d:	c7 45 ec 01 00 00 00 	movl   $0x1,-0x14(%ebp)
  10ae54:	e9 83 00 00 00       	jmp    10aedc <perm_check+0xa8>
  10ae59:	83 7d 1c 01          	cmpl   $0x1,0x1c(%ebp)
  10ae5d:	75 0b                	jne    10ae6a <perm_check+0x36>
  10ae5f:	8b 45 18             	mov    0x18(%ebp),%eax
  10ae62:	25 24 01 00 00       	and    $0x124,%eax
  10ae67:	89 45 fc             	mov    %eax,-0x4(%ebp)
  10ae6a:	83 7d 1c 02          	cmpl   $0x2,0x1c(%ebp)
  10ae6e:	75 0b                	jne    10ae7b <perm_check+0x47>
  10ae70:	8b 45 18             	mov    0x18(%ebp),%eax
  10ae73:	25 92 00 00 00       	and    $0x92,%eax
  10ae78:	89 45 fc             	mov    %eax,-0x4(%ebp)
  10ae7b:	83 7d 1c 03          	cmpl   $0x3,0x1c(%ebp)
  10ae7f:	75 09                	jne    10ae8a <perm_check+0x56>
  10ae81:	8b 45 18             	mov    0x18(%ebp),%eax
  10ae84:	83 e0 49             	and    $0x49,%eax
  10ae87:	89 45 fc             	mov    %eax,-0x4(%ebp)
  10ae8a:	8b 45 10             	mov    0x10(%ebp),%eax
  10ae8d:	3b 45 08             	cmp    0x8(%ebp),%eax
  10ae90:	75 15                	jne    10aea7 <perm_check+0x73>
  10ae92:	8b 45 fc             	mov    -0x4(%ebp),%eax
  10ae95:	25 c0 01 00 00       	and    $0x1c0,%eax
  10ae9a:	85 c0                	test   %eax,%eax
  10ae9c:	74 09                	je     10aea7 <perm_check+0x73>
  10ae9e:	c7 45 ec 01 00 00 00 	movl   $0x1,-0x14(%ebp)
  10aea5:	eb 35                	jmp    10aedc <perm_check+0xa8>
  10aea7:	8b 45 14             	mov    0x14(%ebp),%eax
  10aeaa:	3b 45 0c             	cmp    0xc(%ebp),%eax
  10aead:	75 13                	jne    10aec2 <perm_check+0x8e>
  10aeaf:	8b 45 fc             	mov    -0x4(%ebp),%eax
  10aeb2:	83 e0 38             	and    $0x38,%eax
  10aeb5:	85 c0                	test   %eax,%eax
  10aeb7:	74 09                	je     10aec2 <perm_check+0x8e>
  10aeb9:	c7 45 ec 01 00 00 00 	movl   $0x1,-0x14(%ebp)
  10aec0:	eb 1a                	jmp    10aedc <perm_check+0xa8>
  10aec2:	8b 45 fc             	mov    -0x4(%ebp),%eax
  10aec5:	83 e0 07             	and    $0x7,%eax
  10aec8:	85 c0                	test   %eax,%eax
  10aeca:	74 09                	je     10aed5 <perm_check+0xa1>
  10aecc:	c7 45 ec 01 00 00 00 	movl   $0x1,-0x14(%ebp)
  10aed3:	eb 07                	jmp    10aedc <perm_check+0xa8>
  10aed5:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
  10aedc:	8b 45 ec             	mov    -0x14(%ebp),%eax
  10aedf:	c9                   	leave  
  10aee0:	c3                   	ret    
  10aee1:	00 00                	add    %al,(%eax)
	...

0010aee4 <tree_do_create>:
  10aee4:	55                   	push   %ebp
  10aee5:	89 e5                	mov    %esp,%ebp
  10aee7:	83 ec 18             	sub    $0x18,%esp
  10aeea:	c7 44 24 04 0c 00 00 	movl   $0xc,0x4(%esp)
  10aef1:	00 
  10aef2:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
  10aef9:	e8 4f 82 ff ff       	call   10314d <calloc>
  10aefe:	89 45 fc             	mov    %eax,-0x4(%ebp)
  10af01:	8b 55 fc             	mov    -0x4(%ebp),%edx
  10af04:	8b 45 08             	mov    0x8(%ebp),%eax
  10af07:	89 42 04             	mov    %eax,0x4(%edx)
  10af0a:	8b 55 fc             	mov    -0x4(%ebp),%edx
  10af0d:	8b 45 0c             	mov    0xc(%ebp),%eax
  10af10:	89 42 08             	mov    %eax,0x8(%edx)
  10af13:	8b 45 fc             	mov    -0x4(%ebp),%eax
  10af16:	c9                   	leave  
  10af17:	c3                   	ret    

0010af18 <tree_destroy>:
  10af18:	55                   	push   %ebp
  10af19:	89 e5                	mov    %esp,%ebp
  10af1b:	83 ec 08             	sub    $0x8,%esp
  10af1e:	8b 45 08             	mov    0x8(%ebp),%eax
  10af21:	89 04 24             	mov    %eax,(%esp)
  10af24:	e8 74 80 ff ff       	call   102f9d <free>
  10af29:	c9                   	leave  
  10af2a:	c3                   	ret    

0010af2b <do_search>:
  10af2b:	55                   	push   %ebp
  10af2c:	89 e5                	mov    %esp,%ebp
  10af2e:	57                   	push   %edi
  10af2f:	56                   	push   %esi
  10af30:	53                   	push   %ebx
  10af31:	83 ec 2c             	sub    $0x2c,%esp
  10af34:	8b 45 0c             	mov    0xc(%ebp),%eax
  10af37:	89 45 d8             	mov    %eax,-0x28(%ebp)
  10af3a:	8b 45 10             	mov    0x10(%ebp),%eax
  10af3d:	89 45 dc             	mov    %eax,-0x24(%ebp)
  10af40:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
  10af47:	8b 45 08             	mov    0x8(%ebp),%eax
  10af4a:	8b 00                	mov    (%eax),%eax
  10af4c:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  10af4f:	8b 45 d8             	mov    -0x28(%ebp),%eax
  10af52:	8b 55 dc             	mov    -0x24(%ebp),%edx
  10af55:	83 c0 ff             	add    $0xffffffff,%eax
  10af58:	83 d2 ff             	adc    $0xffffffff,%edx
  10af5b:	89 45 e8             	mov    %eax,-0x18(%ebp)
  10af5e:	89 55 ec             	mov    %edx,-0x14(%ebp)
  10af61:	eb 6a                	jmp    10afcd <do_search+0xa2>
  10af63:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  10af66:	89 45 e0             	mov    %eax,-0x20(%ebp)
  10af69:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  10af6c:	89 44 24 04          	mov    %eax,0x4(%esp)
  10af70:	8b 45 08             	mov    0x8(%ebp),%eax
  10af73:	89 04 24             	mov    %eax,(%esp)
  10af76:	e8 86 00 00 00       	call   10b001 <get_key>
  10af7b:	89 45 e8             	mov    %eax,-0x18(%ebp)
  10af7e:	89 55 ec             	mov    %edx,-0x14(%ebp)
  10af81:	8b 45 d8             	mov    -0x28(%ebp),%eax
  10af84:	8b 55 dc             	mov    -0x24(%ebp),%edx
  10af87:	89 d1                	mov    %edx,%ecx
  10af89:	33 4d ec             	xor    -0x14(%ebp),%ecx
  10af8c:	33 45 e8             	xor    -0x18(%ebp),%eax
  10af8f:	09 c8                	or     %ecx,%eax
  10af91:	85 c0                	test   %eax,%eax
  10af93:	74 3e                	je     10afd3 <do_search+0xa8>
  10af95:	8b 45 d8             	mov    -0x28(%ebp),%eax
  10af98:	8b 55 dc             	mov    -0x24(%ebp),%edx
  10af9b:	89 45 d0             	mov    %eax,-0x30(%ebp)
  10af9e:	89 55 d4             	mov    %edx,-0x2c(%ebp)
  10afa1:	8b 55 d4             	mov    -0x2c(%ebp),%edx
  10afa4:	3b 55 ec             	cmp    -0x14(%ebp),%edx
  10afa7:	77 1b                	ja     10afc4 <do_search+0x99>
  10afa9:	8b 45 d4             	mov    -0x2c(%ebp),%eax
  10afac:	3b 45 ec             	cmp    -0x14(%ebp),%eax
  10afaf:	72 08                	jb     10afb9 <do_search+0x8e>
  10afb1:	8b 55 d0             	mov    -0x30(%ebp),%edx
  10afb4:	3b 55 e8             	cmp    -0x18(%ebp),%edx
  10afb7:	73 0b                	jae    10afc4 <do_search+0x99>
  10afb9:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  10afbc:	8b 40 04             	mov    0x4(%eax),%eax
  10afbf:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  10afc2:	eb 09                	jmp    10afcd <do_search+0xa2>
  10afc4:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  10afc7:	8b 40 08             	mov    0x8(%eax),%eax
  10afca:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  10afcd:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
  10afd1:	75 90                	jne    10af63 <do_search+0x38>
  10afd3:	8b 55 14             	mov    0x14(%ebp),%edx
  10afd6:	8b 45 e0             	mov    -0x20(%ebp),%eax
  10afd9:	89 02                	mov    %eax,(%edx)
  10afdb:	8b 5d e8             	mov    -0x18(%ebp),%ebx
  10afde:	8b 75 d8             	mov    -0x28(%ebp),%esi
  10afe1:	8b 7d ec             	mov    -0x14(%ebp),%edi
  10afe4:	8b 4d dc             	mov    -0x24(%ebp),%ecx
  10afe7:	89 f0                	mov    %esi,%eax
  10afe9:	31 d8                	xor    %ebx,%eax
  10afeb:	89 ca                	mov    %ecx,%edx
  10afed:	31 fa                	xor    %edi,%edx
  10afef:	09 d0                	or     %edx,%eax
  10aff1:	85 c0                	test   %eax,%eax
  10aff3:	0f 94 c0             	sete   %al
  10aff6:	0f b6 c0             	movzbl %al,%eax
  10aff9:	83 c4 2c             	add    $0x2c,%esp
  10affc:	5b                   	pop    %ebx
  10affd:	5e                   	pop    %esi
  10affe:	5f                   	pop    %edi
  10afff:	5d                   	pop    %ebp
  10b000:	c3                   	ret    

0010b001 <get_key>:
  10b001:	55                   	push   %ebp
  10b002:	89 e5                	mov    %esp,%ebp
  10b004:	83 ec 08             	sub    $0x8,%esp
  10b007:	8b 45 0c             	mov    0xc(%ebp),%eax
  10b00a:	89 44 24 04          	mov    %eax,0x4(%esp)
  10b00e:	8b 45 08             	mov    0x8(%ebp),%eax
  10b011:	89 04 24             	mov    %eax,(%esp)
  10b014:	e8 12 00 00 00       	call   10b02b <to_node>
  10b019:	89 c2                	mov    %eax,%edx
  10b01b:	8b 45 08             	mov    0x8(%ebp),%eax
  10b01e:	8b 40 08             	mov    0x8(%eax),%eax
  10b021:	8d 04 02             	lea    (%edx,%eax,1),%eax
  10b024:	8b 50 04             	mov    0x4(%eax),%edx
  10b027:	8b 00                	mov    (%eax),%eax
  10b029:	c9                   	leave  
  10b02a:	c3                   	ret    

0010b02b <to_node>:
  10b02b:	55                   	push   %ebp
  10b02c:	89 e5                	mov    %esp,%ebp
  10b02e:	8b 45 08             	mov    0x8(%ebp),%eax
  10b031:	8b 40 04             	mov    0x4(%eax),%eax
  10b034:	f7 d8                	neg    %eax
  10b036:	03 45 0c             	add    0xc(%ebp),%eax
  10b039:	5d                   	pop    %ebp
  10b03a:	c3                   	ret    

0010b03b <tree_search>:
  10b03b:	55                   	push   %ebp
  10b03c:	89 e5                	mov    %esp,%ebp
  10b03e:	83 ec 38             	sub    $0x38,%esp
  10b041:	8b 45 0c             	mov    0xc(%ebp),%eax
  10b044:	89 45 e8             	mov    %eax,-0x18(%ebp)
  10b047:	8b 45 10             	mov    0x10(%ebp),%eax
  10b04a:	89 45 ec             	mov    %eax,-0x14(%ebp)
  10b04d:	8d 45 fc             	lea    -0x4(%ebp),%eax
  10b050:	89 44 24 0c          	mov    %eax,0xc(%esp)
  10b054:	8b 45 e8             	mov    -0x18(%ebp),%eax
  10b057:	8b 55 ec             	mov    -0x14(%ebp),%edx
  10b05a:	89 44 24 04          	mov    %eax,0x4(%esp)
  10b05e:	89 54 24 08          	mov    %edx,0x8(%esp)
  10b062:	8b 45 08             	mov    0x8(%ebp),%eax
  10b065:	89 04 24             	mov    %eax,(%esp)
  10b068:	e8 be fe ff ff       	call   10af2b <do_search>
  10b06d:	85 c0                	test   %eax,%eax
  10b06f:	74 17                	je     10b088 <tree_search+0x4d>
  10b071:	8b 45 fc             	mov    -0x4(%ebp),%eax
  10b074:	89 44 24 04          	mov    %eax,0x4(%esp)
  10b078:	8b 45 08             	mov    0x8(%ebp),%eax
  10b07b:	89 04 24             	mov    %eax,(%esp)
  10b07e:	e8 a8 ff ff ff       	call   10b02b <to_node>
  10b083:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  10b086:	eb 07                	jmp    10b08f <tree_search+0x54>
  10b088:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
  10b08f:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  10b092:	c9                   	leave  
  10b093:	c3                   	ret    

0010b094 <rotate_left>:
  10b094:	55                   	push   %ebp
  10b095:	89 e5                	mov    %esp,%ebp
  10b097:	83 ec 10             	sub    $0x10,%esp
  10b09a:	8b 45 08             	mov    0x8(%ebp),%eax
  10b09d:	8b 00                	mov    (%eax),%eax
  10b09f:	89 45 f8             	mov    %eax,-0x8(%ebp)
  10b0a2:	8b 45 f8             	mov    -0x8(%ebp),%eax
  10b0a5:	8b 40 08             	mov    0x8(%eax),%eax
  10b0a8:	89 45 fc             	mov    %eax,-0x4(%ebp)
  10b0ab:	8b 45 f8             	mov    -0x8(%ebp),%eax
  10b0ae:	8b 10                	mov    (%eax),%edx
  10b0b0:	8b 45 fc             	mov    -0x4(%ebp),%eax
  10b0b3:	89 10                	mov    %edx,(%eax)
  10b0b5:	8b 55 f8             	mov    -0x8(%ebp),%edx
  10b0b8:	8b 45 fc             	mov    -0x4(%ebp),%eax
  10b0bb:	89 02                	mov    %eax,(%edx)
  10b0bd:	8b 45 fc             	mov    -0x4(%ebp),%eax
  10b0c0:	8b 40 04             	mov    0x4(%eax),%eax
  10b0c3:	85 c0                	test   %eax,%eax
  10b0c5:	74 0b                	je     10b0d2 <rotate_left+0x3e>
  10b0c7:	8b 45 fc             	mov    -0x4(%ebp),%eax
  10b0ca:	8b 50 04             	mov    0x4(%eax),%edx
  10b0cd:	8b 45 f8             	mov    -0x8(%ebp),%eax
  10b0d0:	89 02                	mov    %eax,(%edx)
  10b0d2:	8b 45 fc             	mov    -0x4(%ebp),%eax
  10b0d5:	8b 50 04             	mov    0x4(%eax),%edx
  10b0d8:	8b 45 f8             	mov    -0x8(%ebp),%eax
  10b0db:	89 50 08             	mov    %edx,0x8(%eax)
  10b0de:	8b 55 fc             	mov    -0x4(%ebp),%edx
  10b0e1:	8b 45 f8             	mov    -0x8(%ebp),%eax
  10b0e4:	89 42 04             	mov    %eax,0x4(%edx)
  10b0e7:	8b 55 08             	mov    0x8(%ebp),%edx
  10b0ea:	8b 45 fc             	mov    -0x4(%ebp),%eax
  10b0ed:	89 02                	mov    %eax,(%edx)
  10b0ef:	c9                   	leave  
  10b0f0:	c3                   	ret    

0010b0f1 <rotate_right>:
  10b0f1:	55                   	push   %ebp
  10b0f2:	89 e5                	mov    %esp,%ebp
  10b0f4:	83 ec 10             	sub    $0x10,%esp
  10b0f7:	8b 45 08             	mov    0x8(%ebp),%eax
  10b0fa:	8b 00                	mov    (%eax),%eax
  10b0fc:	89 45 f8             	mov    %eax,-0x8(%ebp)
  10b0ff:	8b 45 f8             	mov    -0x8(%ebp),%eax
  10b102:	8b 40 04             	mov    0x4(%eax),%eax
  10b105:	89 45 fc             	mov    %eax,-0x4(%ebp)
  10b108:	8b 45 f8             	mov    -0x8(%ebp),%eax
  10b10b:	8b 10                	mov    (%eax),%edx
  10b10d:	8b 45 fc             	mov    -0x4(%ebp),%eax
  10b110:	89 10                	mov    %edx,(%eax)
  10b112:	8b 55 f8             	mov    -0x8(%ebp),%edx
  10b115:	8b 45 fc             	mov    -0x4(%ebp),%eax
  10b118:	89 02                	mov    %eax,(%edx)
  10b11a:	8b 45 fc             	mov    -0x4(%ebp),%eax
  10b11d:	8b 40 08             	mov    0x8(%eax),%eax
  10b120:	85 c0                	test   %eax,%eax
  10b122:	74 0b                	je     10b12f <rotate_right+0x3e>
  10b124:	8b 45 fc             	mov    -0x4(%ebp),%eax
  10b127:	8b 50 08             	mov    0x8(%eax),%edx
  10b12a:	8b 45 f8             	mov    -0x8(%ebp),%eax
  10b12d:	89 02                	mov    %eax,(%edx)
  10b12f:	8b 45 fc             	mov    -0x4(%ebp),%eax
  10b132:	8b 50 08             	mov    0x8(%eax),%edx
  10b135:	8b 45 f8             	mov    -0x8(%ebp),%eax
  10b138:	89 50 04             	mov    %edx,0x4(%eax)
  10b13b:	8b 55 fc             	mov    -0x4(%ebp),%edx
  10b13e:	8b 45 f8             	mov    -0x8(%ebp),%eax
  10b141:	89 42 08             	mov    %eax,0x8(%edx)
  10b144:	8b 55 08             	mov    0x8(%ebp),%edx
  10b147:	8b 45 fc             	mov    -0x4(%ebp),%eax
  10b14a:	89 02                	mov    %eax,(%edx)
  10b14c:	c9                   	leave  
  10b14d:	c3                   	ret    

0010b14e <link_from_parent>:
  10b14e:	55                   	push   %ebp
  10b14f:	89 e5                	mov    %esp,%ebp
  10b151:	83 ec 04             	sub    $0x4,%esp
  10b154:	8b 45 0c             	mov    0xc(%ebp),%eax
  10b157:	8b 00                	mov    (%eax),%eax
  10b159:	85 c0                	test   %eax,%eax
  10b15b:	75 08                	jne    10b165 <link_from_parent+0x17>
  10b15d:	8b 45 08             	mov    0x8(%ebp),%eax
  10b160:	89 45 fc             	mov    %eax,-0x4(%ebp)
  10b163:	eb 25                	jmp    10b18a <link_from_parent+0x3c>
  10b165:	8b 45 0c             	mov    0xc(%ebp),%eax
  10b168:	8b 00                	mov    (%eax),%eax
  10b16a:	8b 40 04             	mov    0x4(%eax),%eax
  10b16d:	3b 45 0c             	cmp    0xc(%ebp),%eax
  10b170:	75 0d                	jne    10b17f <link_from_parent+0x31>
  10b172:	8b 45 0c             	mov    0xc(%ebp),%eax
  10b175:	8b 00                	mov    (%eax),%eax
  10b177:	83 c0 04             	add    $0x4,%eax
  10b17a:	89 45 fc             	mov    %eax,-0x4(%ebp)
  10b17d:	eb 0b                	jmp    10b18a <link_from_parent+0x3c>
  10b17f:	8b 45 0c             	mov    0xc(%ebp),%eax
  10b182:	8b 00                	mov    (%eax),%eax
  10b184:	83 c0 08             	add    $0x8,%eax
  10b187:	89 45 fc             	mov    %eax,-0x4(%ebp)
  10b18a:	8b 45 fc             	mov    -0x4(%ebp),%eax
  10b18d:	c9                   	leave  
  10b18e:	c3                   	ret    

0010b18f <rebalance>:
  10b18f:	55                   	push   %ebp
  10b190:	89 e5                	mov    %esp,%ebp
  10b192:	83 ec 28             	sub    $0x28,%esp
  10b195:	e9 2b 02 00 00       	jmp    10b3c5 <rebalance+0x236>
  10b19a:	8b 45 0c             	mov    0xc(%ebp),%eax
  10b19d:	89 44 24 04          	mov    %eax,0x4(%esp)
  10b1a1:	8b 45 08             	mov    0x8(%ebp),%eax
  10b1a4:	89 04 24             	mov    %eax,(%esp)
  10b1a7:	e8 a2 ff ff ff       	call   10b14e <link_from_parent>
  10b1ac:	89 45 f8             	mov    %eax,-0x8(%ebp)
  10b1af:	8b 45 0c             	mov    0xc(%ebp),%eax
  10b1b2:	8b 40 0c             	mov    0xc(%eax),%eax
  10b1b5:	83 f8 01             	cmp    $0x1,%eax
  10b1b8:	0f 8e fc 00 00 00    	jle    10b2ba <rebalance+0x12b>
  10b1be:	8b 45 0c             	mov    0xc(%ebp),%eax
  10b1c1:	8b 40 08             	mov    0x8(%eax),%eax
  10b1c4:	89 45 fc             	mov    %eax,-0x4(%ebp)
  10b1c7:	8b 45 0c             	mov    0xc(%ebp),%eax
  10b1ca:	8b 40 08             	mov    0x8(%eax),%eax
  10b1cd:	8b 40 0c             	mov    0xc(%eax),%eax
  10b1d0:	85 c0                	test   %eax,%eax
  10b1d2:	7e 39                	jle    10b20d <rebalance+0x7e>
  10b1d4:	8b 45 f8             	mov    -0x8(%ebp),%eax
  10b1d7:	89 04 24             	mov    %eax,(%esp)
  10b1da:	e8 b5 fe ff ff       	call   10b094 <rotate_left>
  10b1df:	8b 45 0c             	mov    0xc(%ebp),%eax
  10b1e2:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
  10b1e9:	8b 45 fc             	mov    -0x4(%ebp),%eax
  10b1ec:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
  10b1f3:	8b 45 f8             	mov    -0x8(%ebp),%eax
  10b1f6:	8b 00                	mov    (%eax),%eax
  10b1f8:	c7 44 24 04 ff ff ff 	movl   $0xffffffff,0x4(%esp)
  10b1ff:	ff 
  10b200:	89 04 24             	mov    %eax,(%esp)
  10b203:	e8 c9 01 00 00       	call   10b3d1 <adjust_balance>
  10b208:	e9 b0 01 00 00       	jmp    10b3bd <rebalance+0x22e>
  10b20d:	8b 45 0c             	mov    0xc(%ebp),%eax
  10b210:	8b 40 08             	mov    0x8(%eax),%eax
  10b213:	8b 40 0c             	mov    0xc(%eax),%eax
  10b216:	85 c0                	test   %eax,%eax
  10b218:	75 24                	jne    10b23e <rebalance+0xaf>
  10b21a:	8b 45 f8             	mov    -0x8(%ebp),%eax
  10b21d:	89 04 24             	mov    %eax,(%esp)
  10b220:	e8 6f fe ff ff       	call   10b094 <rotate_left>
  10b225:	8b 45 0c             	mov    0xc(%ebp),%eax
  10b228:	c7 40 0c 01 00 00 00 	movl   $0x1,0xc(%eax)
  10b22f:	8b 45 fc             	mov    -0x4(%ebp),%eax
  10b232:	c7 40 0c ff ff ff ff 	movl   $0xffffffff,0xc(%eax)
  10b239:	e9 7f 01 00 00       	jmp    10b3bd <rebalance+0x22e>
  10b23e:	8b 45 0c             	mov    0xc(%ebp),%eax
  10b241:	83 c0 08             	add    $0x8,%eax
  10b244:	89 04 24             	mov    %eax,(%esp)
  10b247:	e8 a5 fe ff ff       	call   10b0f1 <rotate_right>
  10b24c:	8b 45 f8             	mov    -0x8(%ebp),%eax
  10b24f:	89 04 24             	mov    %eax,(%esp)
  10b252:	e8 3d fe ff ff       	call   10b094 <rotate_left>
  10b257:	8b 45 f8             	mov    -0x8(%ebp),%eax
  10b25a:	8b 00                	mov    (%eax),%eax
  10b25c:	8b 40 0c             	mov    0xc(%eax),%eax
  10b25f:	83 f8 01             	cmp    $0x1,%eax
  10b262:	75 09                	jne    10b26d <rebalance+0xde>
  10b264:	c7 45 e8 ff ff ff ff 	movl   $0xffffffff,-0x18(%ebp)
  10b26b:	eb 07                	jmp    10b274 <rebalance+0xe5>
  10b26d:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
  10b274:	8b 45 0c             	mov    0xc(%ebp),%eax
  10b277:	8b 55 e8             	mov    -0x18(%ebp),%edx
  10b27a:	89 50 0c             	mov    %edx,0xc(%eax)
  10b27d:	8b 45 f8             	mov    -0x8(%ebp),%eax
  10b280:	8b 00                	mov    (%eax),%eax
  10b282:	8b 40 0c             	mov    0xc(%eax),%eax
  10b285:	83 f8 ff             	cmp    $0xffffffff,%eax
  10b288:	0f 94 c0             	sete   %al
  10b28b:	0f b6 d0             	movzbl %al,%edx
  10b28e:	8b 45 fc             	mov    -0x4(%ebp),%eax
  10b291:	89 50 0c             	mov    %edx,0xc(%eax)
  10b294:	8b 45 f8             	mov    -0x8(%ebp),%eax
  10b297:	8b 00                	mov    (%eax),%eax
  10b299:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
  10b2a0:	8b 45 f8             	mov    -0x8(%ebp),%eax
  10b2a3:	8b 00                	mov    (%eax),%eax
  10b2a5:	c7 44 24 04 ff ff ff 	movl   $0xffffffff,0x4(%esp)
  10b2ac:	ff 
  10b2ad:	89 04 24             	mov    %eax,(%esp)
  10b2b0:	e8 1c 01 00 00       	call   10b3d1 <adjust_balance>
  10b2b5:	e9 03 01 00 00       	jmp    10b3bd <rebalance+0x22e>
  10b2ba:	8b 45 0c             	mov    0xc(%ebp),%eax
  10b2bd:	8b 40 0c             	mov    0xc(%eax),%eax
  10b2c0:	83 f8 fe             	cmp    $0xfffffffe,%eax
  10b2c3:	0f 8f f4 00 00 00    	jg     10b3bd <rebalance+0x22e>
  10b2c9:	8b 45 0c             	mov    0xc(%ebp),%eax
  10b2cc:	8b 40 04             	mov    0x4(%eax),%eax
  10b2cf:	89 45 fc             	mov    %eax,-0x4(%ebp)
  10b2d2:	8b 45 0c             	mov    0xc(%ebp),%eax
  10b2d5:	8b 40 04             	mov    0x4(%eax),%eax
  10b2d8:	8b 40 0c             	mov    0xc(%eax),%eax
  10b2db:	85 c0                	test   %eax,%eax
  10b2dd:	79 39                	jns    10b318 <rebalance+0x189>
  10b2df:	8b 45 f8             	mov    -0x8(%ebp),%eax
  10b2e2:	89 04 24             	mov    %eax,(%esp)
  10b2e5:	e8 07 fe ff ff       	call   10b0f1 <rotate_right>
  10b2ea:	8b 45 0c             	mov    0xc(%ebp),%eax
  10b2ed:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
  10b2f4:	8b 45 fc             	mov    -0x4(%ebp),%eax
  10b2f7:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
  10b2fe:	8b 45 f8             	mov    -0x8(%ebp),%eax
  10b301:	8b 00                	mov    (%eax),%eax
  10b303:	c7 44 24 04 ff ff ff 	movl   $0xffffffff,0x4(%esp)
  10b30a:	ff 
  10b30b:	89 04 24             	mov    %eax,(%esp)
  10b30e:	e8 be 00 00 00       	call   10b3d1 <adjust_balance>
  10b313:	e9 a5 00 00 00       	jmp    10b3bd <rebalance+0x22e>
  10b318:	8b 45 0c             	mov    0xc(%ebp),%eax
  10b31b:	8b 40 04             	mov    0x4(%eax),%eax
  10b31e:	8b 40 0c             	mov    0xc(%eax),%eax
  10b321:	85 c0                	test   %eax,%eax
  10b323:	75 21                	jne    10b346 <rebalance+0x1b7>
  10b325:	8b 45 f8             	mov    -0x8(%ebp),%eax
  10b328:	89 04 24             	mov    %eax,(%esp)
  10b32b:	e8 c1 fd ff ff       	call   10b0f1 <rotate_right>
  10b330:	8b 45 0c             	mov    0xc(%ebp),%eax
  10b333:	c7 40 0c ff ff ff ff 	movl   $0xffffffff,0xc(%eax)
  10b33a:	8b 45 fc             	mov    -0x4(%ebp),%eax
  10b33d:	c7 40 0c 01 00 00 00 	movl   $0x1,0xc(%eax)
  10b344:	eb 77                	jmp    10b3bd <rebalance+0x22e>
  10b346:	8b 45 0c             	mov    0xc(%ebp),%eax
  10b349:	83 c0 04             	add    $0x4,%eax
  10b34c:	89 04 24             	mov    %eax,(%esp)
  10b34f:	e8 40 fd ff ff       	call   10b094 <rotate_left>
  10b354:	8b 45 f8             	mov    -0x8(%ebp),%eax
  10b357:	89 04 24             	mov    %eax,(%esp)
  10b35a:	e8 92 fd ff ff       	call   10b0f1 <rotate_right>
  10b35f:	8b 45 f8             	mov    -0x8(%ebp),%eax
  10b362:	8b 00                	mov    (%eax),%eax
  10b364:	8b 40 0c             	mov    0xc(%eax),%eax
  10b367:	83 f8 ff             	cmp    $0xffffffff,%eax
  10b36a:	0f 94 c0             	sete   %al
  10b36d:	0f b6 d0             	movzbl %al,%edx
  10b370:	8b 45 0c             	mov    0xc(%ebp),%eax
  10b373:	89 50 0c             	mov    %edx,0xc(%eax)
  10b376:	8b 45 f8             	mov    -0x8(%ebp),%eax
  10b379:	8b 00                	mov    (%eax),%eax
  10b37b:	8b 40 0c             	mov    0xc(%eax),%eax
  10b37e:	83 f8 01             	cmp    $0x1,%eax
  10b381:	75 09                	jne    10b38c <rebalance+0x1fd>
  10b383:	c7 45 ec ff ff ff ff 	movl   $0xffffffff,-0x14(%ebp)
  10b38a:	eb 07                	jmp    10b393 <rebalance+0x204>
  10b38c:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
  10b393:	8b 45 fc             	mov    -0x4(%ebp),%eax
  10b396:	8b 55 ec             	mov    -0x14(%ebp),%edx
  10b399:	89 50 0c             	mov    %edx,0xc(%eax)
  10b39c:	8b 45 f8             	mov    -0x8(%ebp),%eax
  10b39f:	8b 00                	mov    (%eax),%eax
  10b3a1:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
  10b3a8:	8b 45 f8             	mov    -0x8(%ebp),%eax
  10b3ab:	8b 00                	mov    (%eax),%eax
  10b3ad:	c7 44 24 04 ff ff ff 	movl   $0xffffffff,0x4(%esp)
  10b3b4:	ff 
  10b3b5:	89 04 24             	mov    %eax,(%esp)
  10b3b8:	e8 14 00 00 00       	call   10b3d1 <adjust_balance>
  10b3bd:	8b 45 0c             	mov    0xc(%ebp),%eax
  10b3c0:	8b 00                	mov    (%eax),%eax
  10b3c2:	89 45 0c             	mov    %eax,0xc(%ebp)
  10b3c5:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
  10b3c9:	0f 85 cb fd ff ff    	jne    10b19a <rebalance+0xb>
  10b3cf:	c9                   	leave  
  10b3d0:	c3                   	ret    

0010b3d1 <adjust_balance>:
  10b3d1:	55                   	push   %ebp
  10b3d2:	89 e5                	mov    %esp,%ebp
  10b3d4:	83 ec 10             	sub    $0x10,%esp
  10b3d7:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
  10b3de:	e9 89 00 00 00       	jmp    10b46c <adjust_balance+0x9b>
  10b3e3:	8b 45 08             	mov    0x8(%ebp),%eax
  10b3e6:	8b 00                	mov    (%eax),%eax
  10b3e8:	8b 40 04             	mov    0x4(%eax),%eax
  10b3eb:	3b 45 08             	cmp    0x8(%ebp),%eax
  10b3ee:	75 3b                	jne    10b42b <adjust_balance+0x5a>
  10b3f0:	8b 45 08             	mov    0x8(%ebp),%eax
  10b3f3:	8b 00                	mov    (%eax),%eax
  10b3f5:	8b 40 0c             	mov    0xc(%eax),%eax
  10b3f8:	85 c0                	test   %eax,%eax
  10b3fa:	7e 07                	jle    10b403 <adjust_balance+0x32>
  10b3fc:	c7 45 fc 01 00 00 00 	movl   $0x1,-0x4(%ebp)
  10b403:	8b 45 08             	mov    0x8(%ebp),%eax
  10b406:	8b 10                	mov    (%eax),%edx
  10b408:	8b 45 08             	mov    0x8(%ebp),%eax
  10b40b:	8b 00                	mov    (%eax),%eax
  10b40d:	8b 40 0c             	mov    0xc(%eax),%eax
  10b410:	2b 45 0c             	sub    0xc(%ebp),%eax
  10b413:	89 42 0c             	mov    %eax,0xc(%edx)
  10b416:	8b 45 08             	mov    0x8(%ebp),%eax
  10b419:	8b 00                	mov    (%eax),%eax
  10b41b:	8b 40 0c             	mov    0xc(%eax),%eax
  10b41e:	85 c0                	test   %eax,%eax
  10b420:	7e 42                	jle    10b464 <adjust_balance+0x93>
  10b422:	c7 45 fc 01 00 00 00 	movl   $0x1,-0x4(%ebp)
  10b429:	eb 39                	jmp    10b464 <adjust_balance+0x93>
  10b42b:	8b 45 08             	mov    0x8(%ebp),%eax
  10b42e:	8b 00                	mov    (%eax),%eax
  10b430:	8b 40 0c             	mov    0xc(%eax),%eax
  10b433:	85 c0                	test   %eax,%eax
  10b435:	79 07                	jns    10b43e <adjust_balance+0x6d>
  10b437:	c7 45 fc 01 00 00 00 	movl   $0x1,-0x4(%ebp)
  10b43e:	8b 45 08             	mov    0x8(%ebp),%eax
  10b441:	8b 10                	mov    (%eax),%edx
  10b443:	8b 45 08             	mov    0x8(%ebp),%eax
  10b446:	8b 00                	mov    (%eax),%eax
  10b448:	8b 40 0c             	mov    0xc(%eax),%eax
  10b44b:	03 45 0c             	add    0xc(%ebp),%eax
  10b44e:	89 42 0c             	mov    %eax,0xc(%edx)
  10b451:	8b 45 08             	mov    0x8(%ebp),%eax
  10b454:	8b 00                	mov    (%eax),%eax
  10b456:	8b 40 0c             	mov    0xc(%eax),%eax
  10b459:	85 c0                	test   %eax,%eax
  10b45b:	79 07                	jns    10b464 <adjust_balance+0x93>
  10b45d:	c7 45 fc 01 00 00 00 	movl   $0x1,-0x4(%ebp)
  10b464:	8b 45 08             	mov    0x8(%ebp),%eax
  10b467:	8b 00                	mov    (%eax),%eax
  10b469:	89 45 08             	mov    %eax,0x8(%ebp)
  10b46c:	8b 45 08             	mov    0x8(%ebp),%eax
  10b46f:	8b 00                	mov    (%eax),%eax
  10b471:	85 c0                	test   %eax,%eax
  10b473:	74 0a                	je     10b47f <adjust_balance+0xae>
  10b475:	83 7d fc 00          	cmpl   $0x0,-0x4(%ebp)
  10b479:	0f 84 64 ff ff ff    	je     10b3e3 <adjust_balance+0x12>
  10b47f:	c9                   	leave  
  10b480:	c3                   	ret    

0010b481 <tree_insert>:
  10b481:	55                   	push   %ebp
  10b482:	89 e5                	mov    %esp,%ebp
  10b484:	83 ec 38             	sub    $0x38,%esp
  10b487:	8b 45 0c             	mov    0xc(%ebp),%eax
  10b48a:	89 44 24 04          	mov    %eax,0x4(%esp)
  10b48e:	8b 45 08             	mov    0x8(%ebp),%eax
  10b491:	89 04 24             	mov    %eax,(%esp)
  10b494:	e8 fe 00 00 00       	call   10b597 <to_tree_item>
  10b499:	89 45 f4             	mov    %eax,-0xc(%ebp)
  10b49c:	8b 45 f4             	mov    -0xc(%ebp),%eax
  10b49f:	89 44 24 04          	mov    %eax,0x4(%esp)
  10b4a3:	8b 45 08             	mov    0x8(%ebp),%eax
  10b4a6:	89 04 24             	mov    %eax,(%esp)
  10b4a9:	e8 53 fb ff ff       	call   10b001 <get_key>
  10b4ae:	89 45 f8             	mov    %eax,-0x8(%ebp)
  10b4b1:	89 55 fc             	mov    %edx,-0x4(%ebp)
  10b4b4:	8b 45 f4             	mov    -0xc(%ebp),%eax
  10b4b7:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
  10b4be:	8b 45 f4             	mov    -0xc(%ebp),%eax
  10b4c1:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
  10b4c8:	8b 45 f4             	mov    -0xc(%ebp),%eax
  10b4cb:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
  10b4d2:	8b 45 08             	mov    0x8(%ebp),%eax
  10b4d5:	8b 00                	mov    (%eax),%eax
  10b4d7:	85 c0                	test   %eax,%eax
  10b4d9:	75 1c                	jne    10b4f7 <tree_insert+0x76>
  10b4db:	8b 45 f4             	mov    -0xc(%ebp),%eax
  10b4de:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
  10b4e4:	8b 55 08             	mov    0x8(%ebp),%edx
  10b4e7:	8b 45 f4             	mov    -0xc(%ebp),%eax
  10b4ea:	89 02                	mov    %eax,(%edx)
  10b4ec:	8b 45 08             	mov    0x8(%ebp),%eax
  10b4ef:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  10b4f2:	e9 9b 00 00 00       	jmp    10b592 <tree_insert+0x111>
  10b4f7:	8d 45 f0             	lea    -0x10(%ebp),%eax
  10b4fa:	89 44 24 0c          	mov    %eax,0xc(%esp)
  10b4fe:	8b 45 f8             	mov    -0x8(%ebp),%eax
  10b501:	8b 55 fc             	mov    -0x4(%ebp),%edx
  10b504:	89 44 24 04          	mov    %eax,0x4(%esp)
  10b508:	89 54 24 08          	mov    %edx,0x8(%esp)
  10b50c:	8b 45 08             	mov    0x8(%ebp),%eax
  10b50f:	89 04 24             	mov    %eax,(%esp)
  10b512:	e8 14 fa ff ff       	call   10af2b <do_search>
  10b517:	85 c0                	test   %eax,%eax
  10b519:	75 71                	jne    10b58c <tree_insert+0x10b>
  10b51b:	8b 55 f0             	mov    -0x10(%ebp),%edx
  10b51e:	8b 45 f4             	mov    -0xc(%ebp),%eax
  10b521:	89 10                	mov    %edx,(%eax)
  10b523:	8b 45 f0             	mov    -0x10(%ebp),%eax
  10b526:	89 44 24 04          	mov    %eax,0x4(%esp)
  10b52a:	8b 45 08             	mov    0x8(%ebp),%eax
  10b52d:	89 04 24             	mov    %eax,(%esp)
  10b530:	e8 cc fa ff ff       	call   10b001 <get_key>
  10b535:	89 45 e8             	mov    %eax,-0x18(%ebp)
  10b538:	89 55 ec             	mov    %edx,-0x14(%ebp)
  10b53b:	8b 45 ec             	mov    -0x14(%ebp),%eax
  10b53e:	3b 45 fc             	cmp    -0x4(%ebp),%eax
  10b541:	72 1b                	jb     10b55e <tree_insert+0xdd>
  10b543:	8b 45 ec             	mov    -0x14(%ebp),%eax
  10b546:	3b 45 fc             	cmp    -0x4(%ebp),%eax
  10b549:	77 08                	ja     10b553 <tree_insert+0xd2>
  10b54b:	8b 45 e8             	mov    -0x18(%ebp),%eax
  10b54e:	3b 45 f8             	cmp    -0x8(%ebp),%eax
  10b551:	76 0b                	jbe    10b55e <tree_insert+0xdd>
  10b553:	8b 55 f0             	mov    -0x10(%ebp),%edx
  10b556:	8b 45 f4             	mov    -0xc(%ebp),%eax
  10b559:	89 42 04             	mov    %eax,0x4(%edx)
  10b55c:	eb 09                	jmp    10b567 <tree_insert+0xe6>
  10b55e:	8b 55 f0             	mov    -0x10(%ebp),%edx
  10b561:	8b 45 f4             	mov    -0xc(%ebp),%eax
  10b564:	89 42 08             	mov    %eax,0x8(%edx)
  10b567:	c7 44 24 04 01 00 00 	movl   $0x1,0x4(%esp)
  10b56e:	00 
  10b56f:	8b 45 f4             	mov    -0xc(%ebp),%eax
  10b572:	89 04 24             	mov    %eax,(%esp)
  10b575:	e8 57 fe ff ff       	call   10b3d1 <adjust_balance>
  10b57a:	8b 45 f4             	mov    -0xc(%ebp),%eax
  10b57d:	89 44 24 04          	mov    %eax,0x4(%esp)
  10b581:	8b 45 08             	mov    0x8(%ebp),%eax
  10b584:	89 04 24             	mov    %eax,(%esp)
  10b587:	e8 03 fc ff ff       	call   10b18f <rebalance>
  10b58c:	8b 45 08             	mov    0x8(%ebp),%eax
  10b58f:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  10b592:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  10b595:	c9                   	leave  
  10b596:	c3                   	ret    

0010b597 <to_tree_item>:
  10b597:	55                   	push   %ebp
  10b598:	89 e5                	mov    %esp,%ebp
  10b59a:	8b 55 0c             	mov    0xc(%ebp),%edx
  10b59d:	8b 45 08             	mov    0x8(%ebp),%eax
  10b5a0:	8b 40 04             	mov    0x4(%eax),%eax
  10b5a3:	8d 04 02             	lea    (%edx,%eax,1),%eax
  10b5a6:	5d                   	pop    %ebp
  10b5a7:	c3                   	ret    

0010b5a8 <tree_remove>:
  10b5a8:	55                   	push   %ebp
  10b5a9:	89 e5                	mov    %esp,%ebp
  10b5ab:	83 ec 38             	sub    $0x38,%esp
  10b5ae:	8b 45 0c             	mov    0xc(%ebp),%eax
  10b5b1:	89 44 24 04          	mov    %eax,0x4(%esp)
  10b5b5:	8b 45 08             	mov    0x8(%ebp),%eax
  10b5b8:	89 04 24             	mov    %eax,(%esp)
  10b5bb:	e8 d7 ff ff ff       	call   10b597 <to_tree_item>
  10b5c0:	89 45 e8             	mov    %eax,-0x18(%ebp)
  10b5c3:	8b 45 e8             	mov    -0x18(%ebp),%eax
  10b5c6:	89 44 24 04          	mov    %eax,0x4(%esp)
  10b5ca:	8b 45 08             	mov    0x8(%ebp),%eax
  10b5cd:	89 04 24             	mov    %eax,(%esp)
  10b5d0:	e8 79 fb ff ff       	call   10b14e <link_from_parent>
  10b5d5:	89 45 ec             	mov    %eax,-0x14(%ebp)
  10b5d8:	8b 45 e8             	mov    -0x18(%ebp),%eax
  10b5db:	8b 40 04             	mov    0x4(%eax),%eax
  10b5de:	85 c0                	test   %eax,%eax
  10b5e0:	75 45                	jne    10b627 <tree_remove+0x7f>
  10b5e2:	8b 45 e8             	mov    -0x18(%ebp),%eax
  10b5e5:	8b 40 08             	mov    0x8(%eax),%eax
  10b5e8:	85 c0                	test   %eax,%eax
  10b5ea:	75 3b                	jne    10b627 <tree_remove+0x7f>
  10b5ec:	c7 44 24 04 ff ff ff 	movl   $0xffffffff,0x4(%esp)
  10b5f3:	ff 
  10b5f4:	8b 45 e8             	mov    -0x18(%ebp),%eax
  10b5f7:	89 04 24             	mov    %eax,(%esp)
  10b5fa:	e8 d2 fd ff ff       	call   10b3d1 <adjust_balance>
  10b5ff:	8b 45 ec             	mov    -0x14(%ebp),%eax
  10b602:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
  10b608:	8b 45 e8             	mov    -0x18(%ebp),%eax
  10b60b:	8b 00                	mov    (%eax),%eax
  10b60d:	89 44 24 04          	mov    %eax,0x4(%esp)
  10b611:	8b 45 08             	mov    0x8(%ebp),%eax
  10b614:	89 04 24             	mov    %eax,(%esp)
  10b617:	e8 73 fb ff ff       	call   10b18f <rebalance>
  10b61c:	8b 45 0c             	mov    0xc(%ebp),%eax
  10b61f:	89 45 dc             	mov    %eax,-0x24(%ebp)
  10b622:	e9 35 02 00 00       	jmp    10b85c <tree_remove+0x2b4>
  10b627:	8b 45 e8             	mov    -0x18(%ebp),%eax
  10b62a:	8b 40 04             	mov    0x4(%eax),%eax
  10b62d:	85 c0                	test   %eax,%eax
  10b62f:	74 54                	je     10b685 <tree_remove+0xdd>
  10b631:	8b 45 e8             	mov    -0x18(%ebp),%eax
  10b634:	8b 40 08             	mov    0x8(%eax),%eax
  10b637:	85 c0                	test   %eax,%eax
  10b639:	75 4a                	jne    10b685 <tree_remove+0xdd>
  10b63b:	c7 44 24 04 ff ff ff 	movl   $0xffffffff,0x4(%esp)
  10b642:	ff 
  10b643:	8b 45 e8             	mov    -0x18(%ebp),%eax
  10b646:	89 04 24             	mov    %eax,(%esp)
  10b649:	e8 83 fd ff ff       	call   10b3d1 <adjust_balance>
  10b64e:	8b 45 e8             	mov    -0x18(%ebp),%eax
  10b651:	8b 50 04             	mov    0x4(%eax),%edx
  10b654:	8b 45 ec             	mov    -0x14(%ebp),%eax
  10b657:	89 10                	mov    %edx,(%eax)
  10b659:	8b 45 e8             	mov    -0x18(%ebp),%eax
  10b65c:	8b 50 04             	mov    0x4(%eax),%edx
  10b65f:	8b 45 e8             	mov    -0x18(%ebp),%eax
  10b662:	8b 00                	mov    (%eax),%eax
  10b664:	89 02                	mov    %eax,(%edx)
  10b666:	8b 45 e8             	mov    -0x18(%ebp),%eax
  10b669:	8b 00                	mov    (%eax),%eax
  10b66b:	89 44 24 04          	mov    %eax,0x4(%esp)
  10b66f:	8b 45 08             	mov    0x8(%ebp),%eax
  10b672:	89 04 24             	mov    %eax,(%esp)
  10b675:	e8 15 fb ff ff       	call   10b18f <rebalance>
  10b67a:	8b 45 0c             	mov    0xc(%ebp),%eax
  10b67d:	89 45 dc             	mov    %eax,-0x24(%ebp)
  10b680:	e9 d7 01 00 00       	jmp    10b85c <tree_remove+0x2b4>
  10b685:	8b 45 e8             	mov    -0x18(%ebp),%eax
  10b688:	8b 40 04             	mov    0x4(%eax),%eax
  10b68b:	85 c0                	test   %eax,%eax
  10b68d:	75 54                	jne    10b6e3 <tree_remove+0x13b>
  10b68f:	8b 45 e8             	mov    -0x18(%ebp),%eax
  10b692:	8b 40 08             	mov    0x8(%eax),%eax
  10b695:	85 c0                	test   %eax,%eax
  10b697:	74 4a                	je     10b6e3 <tree_remove+0x13b>
  10b699:	c7 44 24 04 ff ff ff 	movl   $0xffffffff,0x4(%esp)
  10b6a0:	ff 
  10b6a1:	8b 45 e8             	mov    -0x18(%ebp),%eax
  10b6a4:	89 04 24             	mov    %eax,(%esp)
  10b6a7:	e8 25 fd ff ff       	call   10b3d1 <adjust_balance>
  10b6ac:	8b 45 e8             	mov    -0x18(%ebp),%eax
  10b6af:	8b 50 08             	mov    0x8(%eax),%edx
  10b6b2:	8b 45 ec             	mov    -0x14(%ebp),%eax
  10b6b5:	89 10                	mov    %edx,(%eax)
  10b6b7:	8b 45 e8             	mov    -0x18(%ebp),%eax
  10b6ba:	8b 50 08             	mov    0x8(%eax),%edx
  10b6bd:	8b 45 e8             	mov    -0x18(%ebp),%eax
  10b6c0:	8b 00                	mov    (%eax),%eax
  10b6c2:	89 02                	mov    %eax,(%edx)
  10b6c4:	8b 45 e8             	mov    -0x18(%ebp),%eax
  10b6c7:	8b 00                	mov    (%eax),%eax
  10b6c9:	89 44 24 04          	mov    %eax,0x4(%esp)
  10b6cd:	8b 45 08             	mov    0x8(%ebp),%eax
  10b6d0:	89 04 24             	mov    %eax,(%esp)
  10b6d3:	e8 b7 fa ff ff       	call   10b18f <rebalance>
  10b6d8:	8b 45 0c             	mov    0xc(%ebp),%eax
  10b6db:	89 45 dc             	mov    %eax,-0x24(%ebp)
  10b6de:	e9 79 01 00 00       	jmp    10b85c <tree_remove+0x2b4>
  10b6e3:	8b 45 0c             	mov    0xc(%ebp),%eax
  10b6e6:	89 44 24 04          	mov    %eax,0x4(%esp)
  10b6ea:	8b 45 08             	mov    0x8(%ebp),%eax
  10b6ed:	89 04 24             	mov    %eax,(%esp)
  10b6f0:	e8 a2 fe ff ff       	call   10b597 <to_tree_item>
  10b6f5:	89 45 f0             	mov    %eax,-0x10(%ebp)
  10b6f8:	8b 45 e8             	mov    -0x18(%ebp),%eax
  10b6fb:	8b 40 04             	mov    0x4(%eax),%eax
  10b6fe:	89 45 f0             	mov    %eax,-0x10(%ebp)
  10b701:	eb 09                	jmp    10b70c <tree_remove+0x164>
  10b703:	8b 45 f0             	mov    -0x10(%ebp),%eax
  10b706:	8b 40 08             	mov    0x8(%eax),%eax
  10b709:	89 45 f0             	mov    %eax,-0x10(%ebp)
  10b70c:	8b 45 f0             	mov    -0x10(%ebp),%eax
  10b70f:	8b 40 08             	mov    0x8(%eax),%eax
  10b712:	85 c0                	test   %eax,%eax
  10b714:	75 ed                	jne    10b703 <tree_remove+0x15b>
  10b716:	8b 45 f0             	mov    -0x10(%ebp),%eax
  10b719:	89 44 24 04          	mov    %eax,0x4(%esp)
  10b71d:	8b 45 08             	mov    0x8(%ebp),%eax
  10b720:	89 04 24             	mov    %eax,(%esp)
  10b723:	e8 26 fa ff ff       	call   10b14e <link_from_parent>
  10b728:	89 45 f4             	mov    %eax,-0xc(%ebp)
  10b72b:	8b 45 f0             	mov    -0x10(%ebp),%eax
  10b72e:	8b 40 04             	mov    0x4(%eax),%eax
  10b731:	89 45 f8             	mov    %eax,-0x8(%ebp)
  10b734:	8b 45 f0             	mov    -0x10(%ebp),%eax
  10b737:	8b 00                	mov    (%eax),%eax
  10b739:	89 45 fc             	mov    %eax,-0x4(%ebp)
  10b73c:	8b 45 e8             	mov    -0x18(%ebp),%eax
  10b73f:	8b 10                	mov    (%eax),%edx
  10b741:	8b 45 f0             	mov    -0x10(%ebp),%eax
  10b744:	89 10                	mov    %edx,(%eax)
  10b746:	8b 45 e8             	mov    -0x18(%ebp),%eax
  10b749:	8b 50 08             	mov    0x8(%eax),%edx
  10b74c:	8b 45 f0             	mov    -0x10(%ebp),%eax
  10b74f:	89 50 08             	mov    %edx,0x8(%eax)
  10b752:	8b 45 e8             	mov    -0x18(%ebp),%eax
  10b755:	8b 50 04             	mov    0x4(%eax),%edx
  10b758:	8b 45 f0             	mov    -0x10(%ebp),%eax
  10b75b:	89 50 04             	mov    %edx,0x4(%eax)
  10b75e:	8b 45 e8             	mov    -0x18(%ebp),%eax
  10b761:	8b 50 0c             	mov    0xc(%eax),%edx
  10b764:	8b 45 f0             	mov    -0x10(%ebp),%eax
  10b767:	89 50 0c             	mov    %edx,0xc(%eax)
  10b76a:	8b 45 f0             	mov    -0x10(%ebp),%eax
  10b76d:	8b 40 04             	mov    0x4(%eax),%eax
  10b770:	3b 45 f0             	cmp    -0x10(%ebp),%eax
  10b773:	75 0a                	jne    10b77f <tree_remove+0x1d7>
  10b775:	8b 45 f0             	mov    -0x10(%ebp),%eax
  10b778:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
  10b77f:	8b 45 f0             	mov    -0x10(%ebp),%eax
  10b782:	8b 40 04             	mov    0x4(%eax),%eax
  10b785:	85 c0                	test   %eax,%eax
  10b787:	74 0b                	je     10b794 <tree_remove+0x1ec>
  10b789:	8b 45 f0             	mov    -0x10(%ebp),%eax
  10b78c:	8b 50 04             	mov    0x4(%eax),%edx
  10b78f:	8b 45 f0             	mov    -0x10(%ebp),%eax
  10b792:	89 02                	mov    %eax,(%edx)
  10b794:	8b 45 f0             	mov    -0x10(%ebp),%eax
  10b797:	8b 40 08             	mov    0x8(%eax),%eax
  10b79a:	85 c0                	test   %eax,%eax
  10b79c:	74 0b                	je     10b7a9 <tree_remove+0x201>
  10b79e:	8b 45 f0             	mov    -0x10(%ebp),%eax
  10b7a1:	8b 50 08             	mov    0x8(%eax),%edx
  10b7a4:	8b 45 f0             	mov    -0x10(%ebp),%eax
  10b7a7:	89 02                	mov    %eax,(%edx)
  10b7a9:	8b 55 f4             	mov    -0xc(%ebp),%edx
  10b7ac:	8b 45 f8             	mov    -0x8(%ebp),%eax
  10b7af:	89 02                	mov    %eax,(%edx)
  10b7b1:	8b 55 ec             	mov    -0x14(%ebp),%edx
  10b7b4:	8b 45 f0             	mov    -0x10(%ebp),%eax
  10b7b7:	89 02                	mov    %eax,(%edx)
  10b7b9:	8b 45 fc             	mov    -0x4(%ebp),%eax
  10b7bc:	3b 45 e8             	cmp    -0x18(%ebp),%eax
  10b7bf:	75 49                	jne    10b80a <tree_remove+0x262>
  10b7c1:	8b 45 f0             	mov    -0x10(%ebp),%eax
  10b7c4:	8b 40 0c             	mov    0xc(%eax),%eax
  10b7c7:	8d 50 01             	lea    0x1(%eax),%edx
  10b7ca:	8b 45 f0             	mov    -0x10(%ebp),%eax
  10b7cd:	89 50 0c             	mov    %edx,0xc(%eax)
  10b7d0:	8b 55 f0             	mov    -0x10(%ebp),%edx
  10b7d3:	8b 45 f8             	mov    -0x8(%ebp),%eax
  10b7d6:	89 42 04             	mov    %eax,0x4(%edx)
  10b7d9:	8b 45 f0             	mov    -0x10(%ebp),%eax
  10b7dc:	8b 40 0c             	mov    0xc(%eax),%eax
  10b7df:	85 c0                	test   %eax,%eax
  10b7e1:	7f 13                	jg     10b7f6 <tree_remove+0x24e>
  10b7e3:	c7 44 24 04 ff ff ff 	movl   $0xffffffff,0x4(%esp)
  10b7ea:	ff 
  10b7eb:	8b 45 f0             	mov    -0x10(%ebp),%eax
  10b7ee:	89 04 24             	mov    %eax,(%esp)
  10b7f1:	e8 db fb ff ff       	call   10b3d1 <adjust_balance>
  10b7f6:	8b 45 f0             	mov    -0x10(%ebp),%eax
  10b7f9:	89 44 24 04          	mov    %eax,0x4(%esp)
  10b7fd:	8b 45 08             	mov    0x8(%ebp),%eax
  10b800:	89 04 24             	mov    %eax,(%esp)
  10b803:	e8 87 f9 ff ff       	call   10b18f <rebalance>
  10b808:	eb 4c                	jmp    10b856 <tree_remove+0x2ae>
  10b80a:	83 7d f8 00          	cmpl   $0x0,-0x8(%ebp)
  10b80e:	74 08                	je     10b818 <tree_remove+0x270>
  10b810:	8b 55 f8             	mov    -0x8(%ebp),%edx
  10b813:	8b 45 fc             	mov    -0x4(%ebp),%eax
  10b816:	89 02                	mov    %eax,(%edx)
  10b818:	8b 45 fc             	mov    -0x4(%ebp),%eax
  10b81b:	8b 40 0c             	mov    0xc(%eax),%eax
  10b81e:	8d 50 ff             	lea    -0x1(%eax),%edx
  10b821:	8b 45 fc             	mov    -0x4(%ebp),%eax
  10b824:	89 50 0c             	mov    %edx,0xc(%eax)
  10b827:	8b 45 fc             	mov    -0x4(%ebp),%eax
  10b82a:	8b 40 0c             	mov    0xc(%eax),%eax
  10b82d:	85 c0                	test   %eax,%eax
  10b82f:	78 13                	js     10b844 <tree_remove+0x29c>
  10b831:	c7 44 24 04 ff ff ff 	movl   $0xffffffff,0x4(%esp)
  10b838:	ff 
  10b839:	8b 45 fc             	mov    -0x4(%ebp),%eax
  10b83c:	89 04 24             	mov    %eax,(%esp)
  10b83f:	e8 8d fb ff ff       	call   10b3d1 <adjust_balance>
  10b844:	8b 45 fc             	mov    -0x4(%ebp),%eax
  10b847:	89 44 24 04          	mov    %eax,0x4(%esp)
  10b84b:	8b 45 08             	mov    0x8(%ebp),%eax
  10b84e:	89 04 24             	mov    %eax,(%esp)
  10b851:	e8 39 f9 ff ff       	call   10b18f <rebalance>
  10b856:	8b 45 0c             	mov    0xc(%ebp),%eax
  10b859:	89 45 dc             	mov    %eax,-0x24(%ebp)
  10b85c:	8b 45 dc             	mov    -0x24(%ebp),%eax
  10b85f:	c9                   	leave  
  10b860:	c3                   	ret    

0010b861 <tree_prev>:
  10b861:	55                   	push   %ebp
  10b862:	89 e5                	mov    %esp,%ebp
  10b864:	83 ec 20             	sub    $0x20,%esp
  10b867:	8b 45 0c             	mov    0xc(%ebp),%eax
  10b86a:	89 44 24 04          	mov    %eax,0x4(%esp)
  10b86e:	8b 45 08             	mov    0x8(%ebp),%eax
  10b871:	89 04 24             	mov    %eax,(%esp)
  10b874:	e8 1e fd ff ff       	call   10b597 <to_tree_item>
  10b879:	89 45 f8             	mov    %eax,-0x8(%ebp)
  10b87c:	8b 45 f8             	mov    -0x8(%ebp),%eax
  10b87f:	89 45 fc             	mov    %eax,-0x4(%ebp)
  10b882:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
  10b886:	75 0a                	jne    10b892 <tree_prev+0x31>
  10b888:	8b 45 08             	mov    0x8(%ebp),%eax
  10b88b:	8b 00                	mov    (%eax),%eax
  10b88d:	89 45 f8             	mov    %eax,-0x8(%ebp)
  10b890:	eb 69                	jmp    10b8fb <tree_prev+0x9a>
  10b892:	8b 45 f8             	mov    -0x8(%ebp),%eax
  10b895:	8b 40 04             	mov    0x4(%eax),%eax
  10b898:	85 c0                	test   %eax,%eax
  10b89a:	75 4b                	jne    10b8e7 <tree_prev+0x86>
  10b89c:	8b 45 f8             	mov    -0x8(%ebp),%eax
  10b89f:	89 45 fc             	mov    %eax,-0x4(%ebp)
  10b8a2:	8b 45 f8             	mov    -0x8(%ebp),%eax
  10b8a5:	8b 00                	mov    (%eax),%eax
  10b8a7:	89 45 f8             	mov    %eax,-0x8(%ebp)
  10b8aa:	83 7d f8 00          	cmpl   $0x0,-0x8(%ebp)
  10b8ae:	74 0b                	je     10b8bb <tree_prev+0x5a>
  10b8b0:	8b 45 f8             	mov    -0x8(%ebp),%eax
  10b8b3:	8b 40 04             	mov    0x4(%eax),%eax
  10b8b6:	3b 45 fc             	cmp    -0x4(%ebp),%eax
  10b8b9:	74 e1                	je     10b89c <tree_prev+0x3b>
  10b8bb:	83 7d f8 00          	cmpl   $0x0,-0x8(%ebp)
  10b8bf:	74 17                	je     10b8d8 <tree_prev+0x77>
  10b8c1:	8b 45 f8             	mov    -0x8(%ebp),%eax
  10b8c4:	89 44 24 04          	mov    %eax,0x4(%esp)
  10b8c8:	8b 45 08             	mov    0x8(%ebp),%eax
  10b8cb:	89 04 24             	mov    %eax,(%esp)
  10b8ce:	e8 58 f7 ff ff       	call   10b02b <to_node>
  10b8d3:	89 45 ec             	mov    %eax,-0x14(%ebp)
  10b8d6:	eb 07                	jmp    10b8df <tree_prev+0x7e>
  10b8d8:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
  10b8df:	8b 45 ec             	mov    -0x14(%ebp),%eax
  10b8e2:	89 45 e8             	mov    %eax,-0x18(%ebp)
  10b8e5:	eb 33                	jmp    10b91a <tree_prev+0xb9>
  10b8e7:	8b 45 f8             	mov    -0x8(%ebp),%eax
  10b8ea:	8b 40 04             	mov    0x4(%eax),%eax
  10b8ed:	89 45 f8             	mov    %eax,-0x8(%ebp)
  10b8f0:	eb 09                	jmp    10b8fb <tree_prev+0x9a>
  10b8f2:	8b 45 f8             	mov    -0x8(%ebp),%eax
  10b8f5:	8b 40 08             	mov    0x8(%eax),%eax
  10b8f8:	89 45 f8             	mov    %eax,-0x8(%ebp)
  10b8fb:	8b 45 f8             	mov    -0x8(%ebp),%eax
  10b8fe:	8b 40 08             	mov    0x8(%eax),%eax
  10b901:	85 c0                	test   %eax,%eax
  10b903:	75 ed                	jne    10b8f2 <tree_prev+0x91>
  10b905:	8b 45 f8             	mov    -0x8(%ebp),%eax
  10b908:	89 44 24 04          	mov    %eax,0x4(%esp)
  10b90c:	8b 45 08             	mov    0x8(%ebp),%eax
  10b90f:	89 04 24             	mov    %eax,(%esp)
  10b912:	e8 14 f7 ff ff       	call   10b02b <to_node>
  10b917:	89 45 e8             	mov    %eax,-0x18(%ebp)
  10b91a:	8b 45 e8             	mov    -0x18(%ebp),%eax
  10b91d:	c9                   	leave  
  10b91e:	c3                   	ret    

0010b91f <tree_next>:
  10b91f:	55                   	push   %ebp
  10b920:	89 e5                	mov    %esp,%ebp
  10b922:	83 ec 20             	sub    $0x20,%esp
  10b925:	8b 45 0c             	mov    0xc(%ebp),%eax
  10b928:	89 44 24 04          	mov    %eax,0x4(%esp)
  10b92c:	8b 45 08             	mov    0x8(%ebp),%eax
  10b92f:	89 04 24             	mov    %eax,(%esp)
  10b932:	e8 60 fc ff ff       	call   10b597 <to_tree_item>
  10b937:	89 45 f8             	mov    %eax,-0x8(%ebp)
  10b93a:	8b 45 f8             	mov    -0x8(%ebp),%eax
  10b93d:	89 45 fc             	mov    %eax,-0x4(%ebp)
  10b940:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
  10b944:	75 0a                	jne    10b950 <tree_next+0x31>
  10b946:	8b 45 08             	mov    0x8(%ebp),%eax
  10b949:	8b 00                	mov    (%eax),%eax
  10b94b:	89 45 f8             	mov    %eax,-0x8(%ebp)
  10b94e:	eb 69                	jmp    10b9b9 <tree_next+0x9a>
  10b950:	8b 45 f8             	mov    -0x8(%ebp),%eax
  10b953:	8b 40 08             	mov    0x8(%eax),%eax
  10b956:	85 c0                	test   %eax,%eax
  10b958:	75 4b                	jne    10b9a5 <tree_next+0x86>
  10b95a:	8b 45 f8             	mov    -0x8(%ebp),%eax
  10b95d:	89 45 fc             	mov    %eax,-0x4(%ebp)
  10b960:	8b 45 f8             	mov    -0x8(%ebp),%eax
  10b963:	8b 00                	mov    (%eax),%eax
  10b965:	89 45 f8             	mov    %eax,-0x8(%ebp)
  10b968:	83 7d f8 00          	cmpl   $0x0,-0x8(%ebp)
  10b96c:	74 0b                	je     10b979 <tree_next+0x5a>
  10b96e:	8b 45 f8             	mov    -0x8(%ebp),%eax
  10b971:	8b 40 08             	mov    0x8(%eax),%eax
  10b974:	3b 45 fc             	cmp    -0x4(%ebp),%eax
  10b977:	74 e1                	je     10b95a <tree_next+0x3b>
  10b979:	83 7d f8 00          	cmpl   $0x0,-0x8(%ebp)
  10b97d:	74 17                	je     10b996 <tree_next+0x77>
  10b97f:	8b 45 f8             	mov    -0x8(%ebp),%eax
  10b982:	89 44 24 04          	mov    %eax,0x4(%esp)
  10b986:	8b 45 08             	mov    0x8(%ebp),%eax
  10b989:	89 04 24             	mov    %eax,(%esp)
  10b98c:	e8 9a f6 ff ff       	call   10b02b <to_node>
  10b991:	89 45 ec             	mov    %eax,-0x14(%ebp)
  10b994:	eb 07                	jmp    10b99d <tree_next+0x7e>
  10b996:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
  10b99d:	8b 45 ec             	mov    -0x14(%ebp),%eax
  10b9a0:	89 45 e8             	mov    %eax,-0x18(%ebp)
  10b9a3:	eb 33                	jmp    10b9d8 <tree_next+0xb9>
  10b9a5:	8b 45 f8             	mov    -0x8(%ebp),%eax
  10b9a8:	8b 40 08             	mov    0x8(%eax),%eax
  10b9ab:	89 45 f8             	mov    %eax,-0x8(%ebp)
  10b9ae:	eb 09                	jmp    10b9b9 <tree_next+0x9a>
  10b9b0:	8b 45 f8             	mov    -0x8(%ebp),%eax
  10b9b3:	8b 40 04             	mov    0x4(%eax),%eax
  10b9b6:	89 45 f8             	mov    %eax,-0x8(%ebp)
  10b9b9:	8b 45 f8             	mov    -0x8(%ebp),%eax
  10b9bc:	8b 40 04             	mov    0x4(%eax),%eax
  10b9bf:	85 c0                	test   %eax,%eax
  10b9c1:	75 ed                	jne    10b9b0 <tree_next+0x91>
  10b9c3:	8b 45 f8             	mov    -0x8(%ebp),%eax
  10b9c6:	89 44 24 04          	mov    %eax,0x4(%esp)
  10b9ca:	8b 45 08             	mov    0x8(%ebp),%eax
  10b9cd:	89 04 24             	mov    %eax,(%esp)
  10b9d0:	e8 56 f6 ff ff       	call   10b02b <to_node>
  10b9d5:	89 45 e8             	mov    %eax,-0x18(%ebp)
  10b9d8:	8b 45 e8             	mov    -0x18(%ebp),%eax
  10b9db:	c9                   	leave  
  10b9dc:	c3                   	ret    
  10b9dd:	00 00                	add    %al,(%eax)
	...

0010b9e0 <memccpy>:
  10b9e0:	55                   	push   %ebp
  10b9e1:	89 e5                	mov    %esp,%ebp
  10b9e3:	83 ec 10             	sub    $0x10,%esp
  10b9e6:	8b 45 08             	mov    0x8(%ebp),%eax
  10b9e9:	89 45 f4             	mov    %eax,-0xc(%ebp)
  10b9ec:	8b 45 0c             	mov    0xc(%ebp),%eax
  10b9ef:	89 45 f8             	mov    %eax,-0x8(%ebp)
  10b9f2:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
  10b9f9:	eb 2c                	jmp    10ba27 <memccpy+0x47>
  10b9fb:	8b 55 fc             	mov    -0x4(%ebp),%edx
  10b9fe:	8b 45 f4             	mov    -0xc(%ebp),%eax
  10ba01:	8d 0c 10             	lea    (%eax,%edx,1),%ecx
  10ba04:	8b 55 fc             	mov    -0x4(%ebp),%edx
  10ba07:	8b 45 f8             	mov    -0x8(%ebp),%eax
  10ba0a:	01 d0                	add    %edx,%eax
  10ba0c:	0f b6 00             	movzbl (%eax),%eax
  10ba0f:	88 01                	mov    %al,(%ecx)
  10ba11:	8b 55 fc             	mov    -0x4(%ebp),%edx
  10ba14:	8b 45 f8             	mov    -0x8(%ebp),%eax
  10ba17:	01 d0                	add    %edx,%eax
  10ba19:	0f b6 10             	movzbl (%eax),%edx
  10ba1c:	8b 45 10             	mov    0x10(%ebp),%eax
  10ba1f:	38 c2                	cmp    %al,%dl
  10ba21:	74 0c                	je     10ba2f <memccpy+0x4f>
  10ba23:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
  10ba27:	8b 45 fc             	mov    -0x4(%ebp),%eax
  10ba2a:	3b 45 14             	cmp    0x14(%ebp),%eax
  10ba2d:	72 cc                	jb     10b9fb <memccpy+0x1b>
  10ba2f:	8b 45 08             	mov    0x8(%ebp),%eax
  10ba32:	c9                   	leave  
  10ba33:	c3                   	ret    

0010ba34 <memchr>:
  10ba34:	55                   	push   %ebp
  10ba35:	89 e5                	mov    %esp,%ebp
  10ba37:	83 ec 14             	sub    $0x14,%esp
  10ba3a:	8b 45 08             	mov    0x8(%ebp),%eax
  10ba3d:	89 45 f8             	mov    %eax,-0x8(%ebp)
  10ba40:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
  10ba47:	eb 23                	jmp    10ba6c <memchr+0x38>
  10ba49:	8b 55 fc             	mov    -0x4(%ebp),%edx
  10ba4c:	8b 45 f8             	mov    -0x8(%ebp),%eax
  10ba4f:	01 d0                	add    %edx,%eax
  10ba51:	0f b6 10             	movzbl (%eax),%edx
  10ba54:	8b 45 0c             	mov    0xc(%ebp),%eax
  10ba57:	38 c2                	cmp    %al,%dl
  10ba59:	75 0d                	jne    10ba68 <memchr+0x34>
  10ba5b:	8b 55 fc             	mov    -0x4(%ebp),%edx
  10ba5e:	8b 45 f8             	mov    -0x8(%ebp),%eax
  10ba61:	01 d0                	add    %edx,%eax
  10ba63:	89 45 ec             	mov    %eax,-0x14(%ebp)
  10ba66:	eb 13                	jmp    10ba7b <memchr+0x47>
  10ba68:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
  10ba6c:	8b 45 fc             	mov    -0x4(%ebp),%eax
  10ba6f:	3b 45 10             	cmp    0x10(%ebp),%eax
  10ba72:	72 d5                	jb     10ba49 <memchr+0x15>
  10ba74:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
  10ba7b:	8b 45 ec             	mov    -0x14(%ebp),%eax
  10ba7e:	c9                   	leave  
  10ba7f:	c3                   	ret    

0010ba80 <memcmp>:
  10ba80:	55                   	push   %ebp
  10ba81:	89 e5                	mov    %esp,%ebp
  10ba83:	83 ec 24             	sub    $0x24,%esp
  10ba86:	8b 45 08             	mov    0x8(%ebp),%eax
  10ba89:	3b 45 0c             	cmp    0xc(%ebp),%eax
  10ba8c:	75 0c                	jne    10ba9a <memcmp+0x1a>
  10ba8e:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
  10ba95:	e9 e5 00 00 00       	jmp    10bb7f <memcmp+0xff>
  10ba9a:	8b 45 10             	mov    0x10(%ebp),%eax
  10ba9d:	c1 e8 02             	shr    $0x2,%eax
  10baa0:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  10baa3:	8b 45 10             	mov    0x10(%ebp),%eax
  10baa6:	83 e0 03             	and    $0x3,%eax
  10baa9:	89 45 e8             	mov    %eax,-0x18(%ebp)
  10baac:	8b 45 08             	mov    0x8(%ebp),%eax
  10baaf:	89 45 ec             	mov    %eax,-0x14(%ebp)
  10bab2:	8b 45 0c             	mov    0xc(%ebp),%eax
  10bab5:	89 45 f0             	mov    %eax,-0x10(%ebp)
  10bab8:	8b 55 08             	mov    0x8(%ebp),%edx
  10babb:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  10babe:	c1 e0 02             	shl    $0x2,%eax
  10bac1:	8d 04 02             	lea    (%edx,%eax,1),%eax
  10bac4:	89 45 f4             	mov    %eax,-0xc(%ebp)
  10bac7:	8b 55 0c             	mov    0xc(%ebp),%edx
  10baca:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  10bacd:	c1 e0 02             	shl    $0x2,%eax
  10bad0:	8d 04 02             	lea    (%edx,%eax,1),%eax
  10bad3:	89 45 f8             	mov    %eax,-0x8(%ebp)
  10bad6:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
  10badd:	eb 3d                	jmp    10bb1c <memcmp+0x9c>
  10badf:	8b 45 fc             	mov    -0x4(%ebp),%eax
  10bae2:	c1 e0 02             	shl    $0x2,%eax
  10bae5:	03 45 ec             	add    -0x14(%ebp),%eax
  10bae8:	8b 10                	mov    (%eax),%edx
  10baea:	8b 45 fc             	mov    -0x4(%ebp),%eax
  10baed:	c1 e0 02             	shl    $0x2,%eax
  10baf0:	03 45 f0             	add    -0x10(%ebp),%eax
  10baf3:	8b 00                	mov    (%eax),%eax
  10baf5:	39 c2                	cmp    %eax,%edx
  10baf7:	74 1f                	je     10bb18 <memcmp+0x98>
  10baf9:	8b 45 fc             	mov    -0x4(%ebp),%eax
  10bafc:	c1 e0 02             	shl    $0x2,%eax
  10baff:	03 45 ec             	add    -0x14(%ebp),%eax
  10bb02:	8b 10                	mov    (%eax),%edx
  10bb04:	8b 45 fc             	mov    -0x4(%ebp),%eax
  10bb07:	c1 e0 02             	shl    $0x2,%eax
  10bb0a:	03 45 f0             	add    -0x10(%ebp),%eax
  10bb0d:	8b 00                	mov    (%eax),%eax
  10bb0f:	89 d1                	mov    %edx,%ecx
  10bb11:	29 c1                	sub    %eax,%ecx
  10bb13:	89 4d dc             	mov    %ecx,-0x24(%ebp)
  10bb16:	eb 67                	jmp    10bb7f <memcmp+0xff>
  10bb18:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
  10bb1c:	8b 45 fc             	mov    -0x4(%ebp),%eax
  10bb1f:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
  10bb22:	72 bb                	jb     10badf <memcmp+0x5f>
  10bb24:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
  10bb2b:	eb 43                	jmp    10bb70 <memcmp+0xf0>
  10bb2d:	8b 55 fc             	mov    -0x4(%ebp),%edx
  10bb30:	8b 45 f4             	mov    -0xc(%ebp),%eax
  10bb33:	01 d0                	add    %edx,%eax
  10bb35:	0f b6 08             	movzbl (%eax),%ecx
  10bb38:	8b 55 fc             	mov    -0x4(%ebp),%edx
  10bb3b:	8b 45 f8             	mov    -0x8(%ebp),%eax
  10bb3e:	01 d0                	add    %edx,%eax
  10bb40:	0f b6 00             	movzbl (%eax),%eax
  10bb43:	38 c1                	cmp    %al,%cl
  10bb45:	74 25                	je     10bb6c <memcmp+0xec>
  10bb47:	8b 55 fc             	mov    -0x4(%ebp),%edx
  10bb4a:	8b 45 f4             	mov    -0xc(%ebp),%eax
  10bb4d:	01 d0                	add    %edx,%eax
  10bb4f:	0f b6 00             	movzbl (%eax),%eax
  10bb52:	0f b6 c8             	movzbl %al,%ecx
  10bb55:	8b 55 fc             	mov    -0x4(%ebp),%edx
  10bb58:	8b 45 f8             	mov    -0x8(%ebp),%eax
  10bb5b:	01 d0                	add    %edx,%eax
  10bb5d:	0f b6 00             	movzbl (%eax),%eax
  10bb60:	0f b6 c0             	movzbl %al,%eax
  10bb63:	89 ca                	mov    %ecx,%edx
  10bb65:	29 c2                	sub    %eax,%edx
  10bb67:	89 55 dc             	mov    %edx,-0x24(%ebp)
  10bb6a:	eb 13                	jmp    10bb7f <memcmp+0xff>
  10bb6c:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
  10bb70:	8b 45 fc             	mov    -0x4(%ebp),%eax
  10bb73:	3b 45 e8             	cmp    -0x18(%ebp),%eax
  10bb76:	72 b5                	jb     10bb2d <memcmp+0xad>
  10bb78:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
  10bb7f:	8b 45 dc             	mov    -0x24(%ebp),%eax
  10bb82:	c9                   	leave  
  10bb83:	c3                   	ret    

0010bb84 <memcpy>:
  10bb84:	55                   	push   %ebp
  10bb85:	89 e5                	mov    %esp,%ebp
  10bb87:	83 ec 24             	sub    $0x24,%esp
  10bb8a:	8b 45 08             	mov    0x8(%ebp),%eax
  10bb8d:	3b 45 0c             	cmp    0xc(%ebp),%eax
  10bb90:	75 0b                	jne    10bb9d <memcpy+0x19>
  10bb92:	8b 45 08             	mov    0x8(%ebp),%eax
  10bb95:	89 45 dc             	mov    %eax,-0x24(%ebp)
  10bb98:	e9 9a 00 00 00       	jmp    10bc37 <memcpy+0xb3>
  10bb9d:	8b 45 10             	mov    0x10(%ebp),%eax
  10bba0:	c1 e8 02             	shr    $0x2,%eax
  10bba3:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  10bba6:	8b 45 10             	mov    0x10(%ebp),%eax
  10bba9:	83 e0 03             	and    $0x3,%eax
  10bbac:	89 45 e8             	mov    %eax,-0x18(%ebp)
  10bbaf:	8b 45 08             	mov    0x8(%ebp),%eax
  10bbb2:	89 45 ec             	mov    %eax,-0x14(%ebp)
  10bbb5:	8b 45 0c             	mov    0xc(%ebp),%eax
  10bbb8:	89 45 f0             	mov    %eax,-0x10(%ebp)
  10bbbb:	8b 55 08             	mov    0x8(%ebp),%edx
  10bbbe:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  10bbc1:	c1 e0 02             	shl    $0x2,%eax
  10bbc4:	8d 04 02             	lea    (%edx,%eax,1),%eax
  10bbc7:	89 45 f4             	mov    %eax,-0xc(%ebp)
  10bbca:	8b 55 0c             	mov    0xc(%ebp),%edx
  10bbcd:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  10bbd0:	c1 e0 02             	shl    $0x2,%eax
  10bbd3:	8d 04 02             	lea    (%edx,%eax,1),%eax
  10bbd6:	89 45 f8             	mov    %eax,-0x8(%ebp)
  10bbd9:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
  10bbe0:	eb 1c                	jmp    10bbfe <memcpy+0x7a>
  10bbe2:	8b 45 fc             	mov    -0x4(%ebp),%eax
  10bbe5:	c1 e0 02             	shl    $0x2,%eax
  10bbe8:	89 c2                	mov    %eax,%edx
  10bbea:	03 55 ec             	add    -0x14(%ebp),%edx
  10bbed:	8b 45 fc             	mov    -0x4(%ebp),%eax
  10bbf0:	c1 e0 02             	shl    $0x2,%eax
  10bbf3:	03 45 f0             	add    -0x10(%ebp),%eax
  10bbf6:	8b 00                	mov    (%eax),%eax
  10bbf8:	89 02                	mov    %eax,(%edx)
  10bbfa:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
  10bbfe:	8b 45 fc             	mov    -0x4(%ebp),%eax
  10bc01:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
  10bc04:	72 dc                	jb     10bbe2 <memcpy+0x5e>
  10bc06:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
  10bc0d:	eb 1a                	jmp    10bc29 <memcpy+0xa5>
  10bc0f:	8b 55 fc             	mov    -0x4(%ebp),%edx
  10bc12:	8b 45 f4             	mov    -0xc(%ebp),%eax
  10bc15:	8d 0c 10             	lea    (%eax,%edx,1),%ecx
  10bc18:	8b 55 fc             	mov    -0x4(%ebp),%edx
  10bc1b:	8b 45 f8             	mov    -0x8(%ebp),%eax
  10bc1e:	01 d0                	add    %edx,%eax
  10bc20:	0f b6 00             	movzbl (%eax),%eax
  10bc23:	88 01                	mov    %al,(%ecx)
  10bc25:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
  10bc29:	8b 45 fc             	mov    -0x4(%ebp),%eax
  10bc2c:	3b 45 e8             	cmp    -0x18(%ebp),%eax
  10bc2f:	72 de                	jb     10bc0f <memcpy+0x8b>
  10bc31:	8b 45 08             	mov    0x8(%ebp),%eax
  10bc34:	89 45 dc             	mov    %eax,-0x24(%ebp)
  10bc37:	8b 45 dc             	mov    -0x24(%ebp),%eax
  10bc3a:	c9                   	leave  
  10bc3b:	c3                   	ret    

0010bc3c <memmove>:
  10bc3c:	55                   	push   %ebp
  10bc3d:	89 e5                	mov    %esp,%ebp
  10bc3f:	83 ec 24             	sub    $0x24,%esp
  10bc42:	8b 45 08             	mov    0x8(%ebp),%eax
  10bc45:	3b 45 0c             	cmp    0xc(%ebp),%eax
  10bc48:	75 0b                	jne    10bc55 <memmove+0x19>
  10bc4a:	8b 45 08             	mov    0x8(%ebp),%eax
  10bc4d:	89 45 dc             	mov    %eax,-0x24(%ebp)
  10bc50:	e9 07 01 00 00       	jmp    10bd5c <memmove+0x120>
  10bc55:	8b 45 10             	mov    0x10(%ebp),%eax
  10bc58:	c1 e8 02             	shr    $0x2,%eax
  10bc5b:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  10bc5e:	8b 45 10             	mov    0x10(%ebp),%eax
  10bc61:	83 e0 03             	and    $0x3,%eax
  10bc64:	89 45 e8             	mov    %eax,-0x18(%ebp)
  10bc67:	8b 45 08             	mov    0x8(%ebp),%eax
  10bc6a:	89 45 ec             	mov    %eax,-0x14(%ebp)
  10bc6d:	8b 45 0c             	mov    0xc(%ebp),%eax
  10bc70:	89 45 f0             	mov    %eax,-0x10(%ebp)
  10bc73:	8b 55 08             	mov    0x8(%ebp),%edx
  10bc76:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  10bc79:	c1 e0 02             	shl    $0x2,%eax
  10bc7c:	8d 04 02             	lea    (%edx,%eax,1),%eax
  10bc7f:	89 45 f4             	mov    %eax,-0xc(%ebp)
  10bc82:	8b 55 0c             	mov    0xc(%ebp),%edx
  10bc85:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  10bc88:	c1 e0 02             	shl    $0x2,%eax
  10bc8b:	8d 04 02             	lea    (%edx,%eax,1),%eax
  10bc8e:	89 45 f8             	mov    %eax,-0x8(%ebp)
  10bc91:	8b 45 0c             	mov    0xc(%ebp),%eax
  10bc94:	3b 45 08             	cmp    0x8(%ebp),%eax
  10bc97:	76 5a                	jbe    10bcf3 <memmove+0xb7>
  10bc99:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
  10bca0:	eb 1c                	jmp    10bcbe <memmove+0x82>
  10bca2:	8b 45 fc             	mov    -0x4(%ebp),%eax
  10bca5:	c1 e0 02             	shl    $0x2,%eax
  10bca8:	89 c2                	mov    %eax,%edx
  10bcaa:	03 55 ec             	add    -0x14(%ebp),%edx
  10bcad:	8b 45 fc             	mov    -0x4(%ebp),%eax
  10bcb0:	c1 e0 02             	shl    $0x2,%eax
  10bcb3:	03 45 f0             	add    -0x10(%ebp),%eax
  10bcb6:	8b 00                	mov    (%eax),%eax
  10bcb8:	89 02                	mov    %eax,(%edx)
  10bcba:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
  10bcbe:	8b 45 fc             	mov    -0x4(%ebp),%eax
  10bcc1:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
  10bcc4:	72 dc                	jb     10bca2 <memmove+0x66>
  10bcc6:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
  10bccd:	eb 1a                	jmp    10bce9 <memmove+0xad>
  10bccf:	8b 55 fc             	mov    -0x4(%ebp),%edx
  10bcd2:	8b 45 f4             	mov    -0xc(%ebp),%eax
  10bcd5:	8d 0c 10             	lea    (%eax,%edx,1),%ecx
  10bcd8:	8b 55 fc             	mov    -0x4(%ebp),%edx
  10bcdb:	8b 45 f8             	mov    -0x8(%ebp),%eax
  10bcde:	01 d0                	add    %edx,%eax
  10bce0:	0f b6 00             	movzbl (%eax),%eax
  10bce3:	88 01                	mov    %al,(%ecx)
  10bce5:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
  10bce9:	8b 45 fc             	mov    -0x4(%ebp),%eax
  10bcec:	3b 45 e8             	cmp    -0x18(%ebp),%eax
  10bcef:	72 de                	jb     10bccf <memmove+0x93>
  10bcf1:	eb 63                	jmp    10bd56 <memmove+0x11a>
  10bcf3:	8b 45 e8             	mov    -0x18(%ebp),%eax
  10bcf6:	89 45 fc             	mov    %eax,-0x4(%ebp)
  10bcf9:	eb 1d                	jmp    10bd18 <memmove+0xdc>
  10bcfb:	8b 45 fc             	mov    -0x4(%ebp),%eax
  10bcfe:	83 e8 01             	sub    $0x1,%eax
  10bd01:	89 c2                	mov    %eax,%edx
  10bd03:	03 55 f4             	add    -0xc(%ebp),%edx
  10bd06:	8b 45 fc             	mov    -0x4(%ebp),%eax
  10bd09:	83 e8 01             	sub    $0x1,%eax
  10bd0c:	03 45 f8             	add    -0x8(%ebp),%eax
  10bd0f:	0f b6 00             	movzbl (%eax),%eax
  10bd12:	88 02                	mov    %al,(%edx)
  10bd14:	83 6d fc 01          	subl   $0x1,-0x4(%ebp)
  10bd18:	83 7d fc 00          	cmpl   $0x0,-0x4(%ebp)
  10bd1c:	75 dd                	jne    10bcfb <memmove+0xbf>
  10bd1e:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  10bd21:	89 45 fc             	mov    %eax,-0x4(%ebp)
  10bd24:	eb 2a                	jmp    10bd50 <memmove+0x114>
  10bd26:	b8 01 00 00 00       	mov    $0x1,%eax
  10bd2b:	2b 45 fc             	sub    -0x4(%ebp),%eax
  10bd2e:	c1 e0 02             	shl    $0x2,%eax
  10bd31:	f7 d8                	neg    %eax
  10bd33:	89 c2                	mov    %eax,%edx
  10bd35:	03 55 ec             	add    -0x14(%ebp),%edx
  10bd38:	b8 01 00 00 00       	mov    $0x1,%eax
  10bd3d:	2b 45 fc             	sub    -0x4(%ebp),%eax
  10bd40:	c1 e0 02             	shl    $0x2,%eax
  10bd43:	f7 d8                	neg    %eax
  10bd45:	03 45 f0             	add    -0x10(%ebp),%eax
  10bd48:	8b 00                	mov    (%eax),%eax
  10bd4a:	89 02                	mov    %eax,(%edx)
  10bd4c:	83 6d fc 01          	subl   $0x1,-0x4(%ebp)
  10bd50:	83 7d fc 00          	cmpl   $0x0,-0x4(%ebp)
  10bd54:	75 d0                	jne    10bd26 <memmove+0xea>
  10bd56:	8b 45 08             	mov    0x8(%ebp),%eax
  10bd59:	89 45 dc             	mov    %eax,-0x24(%ebp)
  10bd5c:	8b 45 dc             	mov    -0x24(%ebp),%eax
  10bd5f:	c9                   	leave  
  10bd60:	c3                   	ret    

0010bd61 <memset>:
  10bd61:	55                   	push   %ebp
  10bd62:	89 e5                	mov    %esp,%ebp
  10bd64:	83 ec 10             	sub    $0x10,%esp
  10bd67:	8b 45 08             	mov    0x8(%ebp),%eax
  10bd6a:	89 45 fc             	mov    %eax,-0x4(%ebp)
  10bd6d:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
  10bd74:	eb 12                	jmp    10bd88 <memset+0x27>
  10bd76:	8b 55 f8             	mov    -0x8(%ebp),%edx
  10bd79:	8b 45 fc             	mov    -0x4(%ebp),%eax
  10bd7c:	8d 14 10             	lea    (%eax,%edx,1),%edx
  10bd7f:	8b 45 0c             	mov    0xc(%ebp),%eax
  10bd82:	88 02                	mov    %al,(%edx)
  10bd84:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
  10bd88:	8b 45 f8             	mov    -0x8(%ebp),%eax
  10bd8b:	3b 45 10             	cmp    0x10(%ebp),%eax
  10bd8e:	72 e6                	jb     10bd76 <memset+0x15>
  10bd90:	8b 45 08             	mov    0x8(%ebp),%eax
  10bd93:	c9                   	leave  
  10bd94:	c3                   	ret    

0010bd95 <strcat>:
  10bd95:	55                   	push   %ebp
  10bd96:	89 e5                	mov    %esp,%ebp
  10bd98:	83 ec 08             	sub    $0x8,%esp
  10bd9b:	8b 45 08             	mov    0x8(%ebp),%eax
  10bd9e:	89 04 24             	mov    %eax,(%esp)
  10bda1:	e8 96 01 00 00       	call   10bf3c <strlen>
  10bda6:	89 c2                	mov    %eax,%edx
  10bda8:	03 55 08             	add    0x8(%ebp),%edx
  10bdab:	8b 45 0c             	mov    0xc(%ebp),%eax
  10bdae:	89 44 24 04          	mov    %eax,0x4(%esp)
  10bdb2:	89 14 24             	mov    %edx,(%esp)
  10bdb5:	e8 ef 00 00 00       	call   10bea9 <strcpy>
  10bdba:	c9                   	leave  
  10bdbb:	c3                   	ret    

0010bdbc <strchr>:
  10bdbc:	55                   	push   %ebp
  10bdbd:	89 e5                	mov    %esp,%ebp
  10bdbf:	83 ec 14             	sub    $0x14,%esp
  10bdc2:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
  10bdc9:	eb 04                	jmp    10bdcf <strchr+0x13>
  10bdcb:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
  10bdcf:	8b 55 fc             	mov    -0x4(%ebp),%edx
  10bdd2:	8b 45 08             	mov    0x8(%ebp),%eax
  10bdd5:	01 d0                	add    %edx,%eax
  10bdd7:	0f b6 00             	movzbl (%eax),%eax
  10bdda:	84 c0                	test   %al,%al
  10bddc:	74 12                	je     10bdf0 <strchr+0x34>
  10bdde:	8b 55 fc             	mov    -0x4(%ebp),%edx
  10bde1:	8b 45 08             	mov    0x8(%ebp),%eax
  10bde4:	01 d0                	add    %edx,%eax
  10bde6:	0f b6 10             	movzbl (%eax),%edx
  10bde9:	8b 45 0c             	mov    0xc(%ebp),%eax
  10bdec:	38 c2                	cmp    %al,%dl
  10bdee:	75 db                	jne    10bdcb <strchr+0xf>
  10bdf0:	8b 55 fc             	mov    -0x4(%ebp),%edx
  10bdf3:	8b 45 08             	mov    0x8(%ebp),%eax
  10bdf6:	01 d0                	add    %edx,%eax
  10bdf8:	0f b6 00             	movzbl (%eax),%eax
  10bdfb:	0f be c0             	movsbl %al,%eax
  10bdfe:	3b 45 0c             	cmp    0xc(%ebp),%eax
  10be01:	75 0d                	jne    10be10 <strchr+0x54>
  10be03:	8b 45 08             	mov    0x8(%ebp),%eax
  10be06:	8b 55 fc             	mov    -0x4(%ebp),%edx
  10be09:	01 c2                	add    %eax,%edx
  10be0b:	89 55 ec             	mov    %edx,-0x14(%ebp)
  10be0e:	eb 07                	jmp    10be17 <strchr+0x5b>
  10be10:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
  10be17:	8b 45 ec             	mov    -0x14(%ebp),%eax
  10be1a:	c9                   	leave  
  10be1b:	c3                   	ret    

0010be1c <strcmp>:
  10be1c:	55                   	push   %ebp
  10be1d:	89 e5                	mov    %esp,%ebp
  10be1f:	83 ec 14             	sub    $0x14,%esp
  10be22:	8b 45 08             	mov    0x8(%ebp),%eax
  10be25:	3b 45 0c             	cmp    0xc(%ebp),%eax
  10be28:	75 09                	jne    10be33 <strcmp+0x17>
  10be2a:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
  10be31:	eb 71                	jmp    10bea4 <strcmp+0x88>
  10be33:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
  10be3a:	eb 43                	jmp    10be7f <strcmp+0x63>
  10be3c:	8b 55 fc             	mov    -0x4(%ebp),%edx
  10be3f:	8b 45 08             	mov    0x8(%ebp),%eax
  10be42:	01 d0                	add    %edx,%eax
  10be44:	0f b6 08             	movzbl (%eax),%ecx
  10be47:	8b 55 fc             	mov    -0x4(%ebp),%edx
  10be4a:	8b 45 0c             	mov    0xc(%ebp),%eax
  10be4d:	01 d0                	add    %edx,%eax
  10be4f:	0f b6 00             	movzbl (%eax),%eax
  10be52:	38 c1                	cmp    %al,%cl
  10be54:	74 25                	je     10be7b <strcmp+0x5f>
  10be56:	8b 55 fc             	mov    -0x4(%ebp),%edx
  10be59:	8b 45 08             	mov    0x8(%ebp),%eax
  10be5c:	01 d0                	add    %edx,%eax
  10be5e:	0f b6 00             	movzbl (%eax),%eax
  10be61:	0f be c8             	movsbl %al,%ecx
  10be64:	8b 55 fc             	mov    -0x4(%ebp),%edx
  10be67:	8b 45 0c             	mov    0xc(%ebp),%eax
  10be6a:	01 d0                	add    %edx,%eax
  10be6c:	0f b6 00             	movzbl (%eax),%eax
  10be6f:	0f be c0             	movsbl %al,%eax
  10be72:	89 ca                	mov    %ecx,%edx
  10be74:	29 c2                	sub    %eax,%edx
  10be76:	89 55 ec             	mov    %edx,-0x14(%ebp)
  10be79:	eb 29                	jmp    10bea4 <strcmp+0x88>
  10be7b:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
  10be7f:	8b 55 fc             	mov    -0x4(%ebp),%edx
  10be82:	8b 45 08             	mov    0x8(%ebp),%eax
  10be85:	01 d0                	add    %edx,%eax
  10be87:	0f b6 00             	movzbl (%eax),%eax
  10be8a:	84 c0                	test   %al,%al
  10be8c:	75 ae                	jne    10be3c <strcmp+0x20>
  10be8e:	8b 55 fc             	mov    -0x4(%ebp),%edx
  10be91:	8b 45 0c             	mov    0xc(%ebp),%eax
  10be94:	01 d0                	add    %edx,%eax
  10be96:	0f b6 00             	movzbl (%eax),%eax
  10be99:	84 c0                	test   %al,%al
  10be9b:	75 9f                	jne    10be3c <strcmp+0x20>
  10be9d:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
  10bea4:	8b 45 ec             	mov    -0x14(%ebp),%eax
  10bea7:	c9                   	leave  
  10bea8:	c3                   	ret    

0010bea9 <strcpy>:
  10bea9:	55                   	push   %ebp
  10beaa:	89 e5                	mov    %esp,%ebp
  10beac:	83 ec 10             	sub    $0x10,%esp
  10beaf:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
  10beb6:	eb 1a                	jmp    10bed2 <strcpy+0x29>
  10beb8:	8b 55 fc             	mov    -0x4(%ebp),%edx
  10bebb:	8b 45 08             	mov    0x8(%ebp),%eax
  10bebe:	8d 0c 10             	lea    (%eax,%edx,1),%ecx
  10bec1:	8b 55 fc             	mov    -0x4(%ebp),%edx
  10bec4:	8b 45 0c             	mov    0xc(%ebp),%eax
  10bec7:	01 d0                	add    %edx,%eax
  10bec9:	0f b6 00             	movzbl (%eax),%eax
  10becc:	88 01                	mov    %al,(%ecx)
  10bece:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
  10bed2:	8b 55 fc             	mov    -0x4(%ebp),%edx
  10bed5:	8b 45 0c             	mov    0xc(%ebp),%eax
  10bed8:	01 d0                	add    %edx,%eax
  10beda:	0f b6 00             	movzbl (%eax),%eax
  10bedd:	84 c0                	test   %al,%al
  10bedf:	75 d7                	jne    10beb8 <strcpy+0xf>
  10bee1:	8b 55 fc             	mov    -0x4(%ebp),%edx
  10bee4:	8b 45 08             	mov    0x8(%ebp),%eax
  10bee7:	01 d0                	add    %edx,%eax
  10bee9:	c6 00 00             	movb   $0x0,(%eax)
  10beec:	8b 45 08             	mov    0x8(%ebp),%eax
  10beef:	c9                   	leave  
  10bef0:	c3                   	ret    

0010bef1 <strdup>:
  10bef1:	55                   	push   %ebp
  10bef2:	89 e5                	mov    %esp,%ebp
  10bef4:	83 ec 28             	sub    $0x28,%esp
  10bef7:	8b 45 08             	mov    0x8(%ebp),%eax
  10befa:	89 04 24             	mov    %eax,(%esp)
  10befd:	e8 3a 00 00 00       	call   10bf3c <strlen>
  10bf02:	83 c0 01             	add    $0x1,%eax
  10bf05:	89 45 fc             	mov    %eax,-0x4(%ebp)
  10bf08:	8b 45 fc             	mov    -0x4(%ebp),%eax
  10bf0b:	89 04 24             	mov    %eax,(%esp)
  10bf0e:	e8 56 70 ff ff       	call   102f69 <malloc>
  10bf13:	89 c2                	mov    %eax,%edx
  10bf15:	8b 45 fc             	mov    -0x4(%ebp),%eax
  10bf18:	89 44 24 08          	mov    %eax,0x8(%esp)
  10bf1c:	8b 45 08             	mov    0x8(%ebp),%eax
  10bf1f:	89 44 24 04          	mov    %eax,0x4(%esp)
  10bf23:	89 14 24             	mov    %edx,(%esp)
  10bf26:	e8 59 fc ff ff       	call   10bb84 <memcpy>
  10bf2b:	c9                   	leave  
  10bf2c:	c3                   	ret    

0010bf2d <strerror>:
  10bf2d:	55                   	push   %ebp
  10bf2e:	89 e5                	mov    %esp,%ebp
  10bf30:	8b 45 08             	mov    0x8(%ebp),%eax
  10bf33:	8b 04 85 40 e0 10 00 	mov    0x10e040(,%eax,4),%eax
  10bf3a:	5d                   	pop    %ebp
  10bf3b:	c3                   	ret    

0010bf3c <strlen>:
  10bf3c:	55                   	push   %ebp
  10bf3d:	89 e5                	mov    %esp,%ebp
  10bf3f:	83 ec 10             	sub    $0x10,%esp
  10bf42:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
  10bf49:	eb 04                	jmp    10bf4f <strlen+0x13>
  10bf4b:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
  10bf4f:	8b 55 fc             	mov    -0x4(%ebp),%edx
  10bf52:	8b 45 08             	mov    0x8(%ebp),%eax
  10bf55:	01 d0                	add    %edx,%eax
  10bf57:	0f b6 00             	movzbl (%eax),%eax
  10bf5a:	84 c0                	test   %al,%al
  10bf5c:	75 ed                	jne    10bf4b <strlen+0xf>
  10bf5e:	8b 45 fc             	mov    -0x4(%ebp),%eax
  10bf61:	c9                   	leave  
  10bf62:	c3                   	ret    

0010bf63 <strncat>:
  10bf63:	55                   	push   %ebp
  10bf64:	89 e5                	mov    %esp,%ebp
  10bf66:	83 ec 1c             	sub    $0x1c,%esp
  10bf69:	8b 45 0c             	mov    0xc(%ebp),%eax
  10bf6c:	89 04 24             	mov    %eax,(%esp)
  10bf6f:	e8 c8 ff ff ff       	call   10bf3c <strlen>
  10bf74:	89 45 f4             	mov    %eax,-0xc(%ebp)
  10bf77:	8b 45 10             	mov    0x10(%ebp),%eax
  10bf7a:	89 45 e8             	mov    %eax,-0x18(%ebp)
  10bf7d:	8b 45 f4             	mov    -0xc(%ebp),%eax
  10bf80:	89 45 ec             	mov    %eax,-0x14(%ebp)
  10bf83:	8b 45 e8             	mov    -0x18(%ebp),%eax
  10bf86:	39 45 ec             	cmp    %eax,-0x14(%ebp)
  10bf89:	76 06                	jbe    10bf91 <strncat+0x2e>
  10bf8b:	8b 45 e8             	mov    -0x18(%ebp),%eax
  10bf8e:	89 45 ec             	mov    %eax,-0x14(%ebp)
  10bf91:	8b 45 ec             	mov    -0x14(%ebp),%eax
  10bf94:	89 45 f4             	mov    %eax,-0xc(%ebp)
  10bf97:	8b 45 08             	mov    0x8(%ebp),%eax
  10bf9a:	89 04 24             	mov    %eax,(%esp)
  10bf9d:	e8 9a ff ff ff       	call   10bf3c <strlen>
  10bfa2:	89 45 f8             	mov    %eax,-0x8(%ebp)
  10bfa5:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
  10bfac:	eb 1e                	jmp    10bfcc <strncat+0x69>
  10bfae:	8b 55 fc             	mov    -0x4(%ebp),%edx
  10bfb1:	8b 45 f8             	mov    -0x8(%ebp),%eax
  10bfb4:	01 d0                	add    %edx,%eax
  10bfb6:	89 c1                	mov    %eax,%ecx
  10bfb8:	03 4d 08             	add    0x8(%ebp),%ecx
  10bfbb:	8b 55 fc             	mov    -0x4(%ebp),%edx
  10bfbe:	8b 45 0c             	mov    0xc(%ebp),%eax
  10bfc1:	01 d0                	add    %edx,%eax
  10bfc3:	0f b6 00             	movzbl (%eax),%eax
  10bfc6:	88 01                	mov    %al,(%ecx)
  10bfc8:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
  10bfcc:	8b 45 fc             	mov    -0x4(%ebp),%eax
  10bfcf:	3b 45 f4             	cmp    -0xc(%ebp),%eax
  10bfd2:	72 da                	jb     10bfae <strncat+0x4b>
  10bfd4:	8b 55 f4             	mov    -0xc(%ebp),%edx
  10bfd7:	8b 45 f8             	mov    -0x8(%ebp),%eax
  10bfda:	01 d0                	add    %edx,%eax
  10bfdc:	03 45 08             	add    0x8(%ebp),%eax
  10bfdf:	c6 00 00             	movb   $0x0,(%eax)
  10bfe2:	8b 45 08             	mov    0x8(%ebp),%eax
  10bfe5:	c9                   	leave  
  10bfe6:	c3                   	ret    

0010bfe7 <strncmp>:
  10bfe7:	55                   	push   %ebp
  10bfe8:	89 e5                	mov    %esp,%ebp
  10bfea:	83 ec 14             	sub    $0x14,%esp
  10bfed:	8b 45 08             	mov    0x8(%ebp),%eax
  10bff0:	3b 45 0c             	cmp    0xc(%ebp),%eax
  10bff3:	75 09                	jne    10bffe <strncmp+0x17>
  10bff5:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
  10bffc:	eb 79                	jmp    10c077 <strncmp+0x90>
  10bffe:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
  10c005:	eb 43                	jmp    10c04a <strncmp+0x63>
  10c007:	8b 55 fc             	mov    -0x4(%ebp),%edx
  10c00a:	8b 45 08             	mov    0x8(%ebp),%eax
  10c00d:	01 d0                	add    %edx,%eax
  10c00f:	0f b6 08             	movzbl (%eax),%ecx
  10c012:	8b 55 fc             	mov    -0x4(%ebp),%edx
  10c015:	8b 45 0c             	mov    0xc(%ebp),%eax
  10c018:	01 d0                	add    %edx,%eax
  10c01a:	0f b6 00             	movzbl (%eax),%eax
  10c01d:	38 c1                	cmp    %al,%cl
  10c01f:	74 25                	je     10c046 <strncmp+0x5f>
  10c021:	8b 55 fc             	mov    -0x4(%ebp),%edx
  10c024:	8b 45 08             	mov    0x8(%ebp),%eax
  10c027:	01 d0                	add    %edx,%eax
  10c029:	0f b6 00             	movzbl (%eax),%eax
  10c02c:	0f be c8             	movsbl %al,%ecx
  10c02f:	8b 55 fc             	mov    -0x4(%ebp),%edx
  10c032:	8b 45 0c             	mov    0xc(%ebp),%eax
  10c035:	01 d0                	add    %edx,%eax
  10c037:	0f b6 00             	movzbl (%eax),%eax
  10c03a:	0f be c0             	movsbl %al,%eax
  10c03d:	89 ca                	mov    %ecx,%edx
  10c03f:	29 c2                	sub    %eax,%edx
  10c041:	89 55 ec             	mov    %edx,-0x14(%ebp)
  10c044:	eb 31                	jmp    10c077 <strncmp+0x90>
  10c046:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
  10c04a:	8b 55 fc             	mov    -0x4(%ebp),%edx
  10c04d:	8b 45 08             	mov    0x8(%ebp),%eax
  10c050:	01 d0                	add    %edx,%eax
  10c052:	0f b6 00             	movzbl (%eax),%eax
  10c055:	84 c0                	test   %al,%al
  10c057:	75 0f                	jne    10c068 <strncmp+0x81>
  10c059:	8b 55 fc             	mov    -0x4(%ebp),%edx
  10c05c:	8b 45 0c             	mov    0xc(%ebp),%eax
  10c05f:	01 d0                	add    %edx,%eax
  10c061:	0f b6 00             	movzbl (%eax),%eax
  10c064:	84 c0                	test   %al,%al
  10c066:	74 08                	je     10c070 <strncmp+0x89>
  10c068:	8b 45 fc             	mov    -0x4(%ebp),%eax
  10c06b:	3b 45 10             	cmp    0x10(%ebp),%eax
  10c06e:	72 97                	jb     10c007 <strncmp+0x20>
  10c070:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
  10c077:	8b 45 ec             	mov    -0x14(%ebp),%eax
  10c07a:	c9                   	leave  
  10c07b:	c3                   	ret    

0010c07c <strncpy>:
  10c07c:	55                   	push   %ebp
  10c07d:	89 e5                	mov    %esp,%ebp
  10c07f:	83 ec 1c             	sub    $0x1c,%esp
  10c082:	8b 45 0c             	mov    0xc(%ebp),%eax
  10c085:	89 04 24             	mov    %eax,(%esp)
  10c088:	e8 af fe ff ff       	call   10bf3c <strlen>
  10c08d:	83 c0 01             	add    $0x1,%eax
  10c090:	89 45 fc             	mov    %eax,-0x4(%ebp)
  10c093:	8b 45 10             	mov    0x10(%ebp),%eax
  10c096:	3b 45 fc             	cmp    -0x4(%ebp),%eax
  10c099:	73 06                	jae    10c0a1 <strncpy+0x25>
  10c09b:	8b 45 10             	mov    0x10(%ebp),%eax
  10c09e:	89 45 fc             	mov    %eax,-0x4(%ebp)
  10c0a1:	8b 45 fc             	mov    -0x4(%ebp),%eax
  10c0a4:	83 e8 01             	sub    $0x1,%eax
  10c0a7:	89 44 24 08          	mov    %eax,0x8(%esp)
  10c0ab:	8b 45 0c             	mov    0xc(%ebp),%eax
  10c0ae:	89 44 24 04          	mov    %eax,0x4(%esp)
  10c0b2:	8b 45 08             	mov    0x8(%ebp),%eax
  10c0b5:	89 04 24             	mov    %eax,(%esp)
  10c0b8:	e8 c7 fa ff ff       	call   10bb84 <memcpy>
  10c0bd:	8b 45 fc             	mov    -0x4(%ebp),%eax
  10c0c0:	83 e8 01             	sub    $0x1,%eax
  10c0c3:	03 45 08             	add    0x8(%ebp),%eax
  10c0c6:	c6 00 00             	movb   $0x0,(%eax)
  10c0c9:	8b 45 08             	mov    0x8(%ebp),%eax
  10c0cc:	c9                   	leave  
  10c0cd:	c3                   	ret    

0010c0ce <__strxspn>:
  10c0ce:	55                   	push   %ebp
  10c0cf:	89 e5                	mov    %esp,%ebp
  10c0d1:	81 ec 1c 01 00 00    	sub    $0x11c,%esp
  10c0d7:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
  10c0de:	c7 44 24 08 00 01 00 	movl   $0x100,0x8(%esp)
  10c0e5:	00 
  10c0e6:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  10c0ed:	00 
  10c0ee:	8d 85 fc fe ff ff    	lea    -0x104(%ebp),%eax
  10c0f4:	89 04 24             	mov    %eax,(%esp)
  10c0f7:	e8 65 fc ff ff       	call   10bd61 <memset>
  10c0fc:	eb 15                	jmp    10c113 <__strxspn+0x45>
  10c0fe:	8b 45 0c             	mov    0xc(%ebp),%eax
  10c101:	0f b6 00             	movzbl (%eax),%eax
  10c104:	0f b6 c0             	movzbl %al,%eax
  10c107:	c6 84 05 fc fe ff ff 	movb   $0x1,-0x104(%ebp,%eax,1)
  10c10e:	01 
  10c10f:	83 45 0c 01          	addl   $0x1,0xc(%ebp)
  10c113:	8b 45 0c             	mov    0xc(%ebp),%eax
  10c116:	0f b6 00             	movzbl (%eax),%eax
  10c119:	84 c0                	test   %al,%al
  10c11b:	75 e1                	jne    10c0fe <__strxspn+0x30>
  10c11d:	8b 45 10             	mov    0x10(%ebp),%eax
  10c120:	88 85 fc fe ff ff    	mov    %al,-0x104(%ebp)
  10c126:	eb 04                	jmp    10c12c <__strxspn+0x5e>
  10c128:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
  10c12c:	8b 45 08             	mov    0x8(%ebp),%eax
  10c12f:	0f b6 00             	movzbl (%eax),%eax
  10c132:	0f b6 c0             	movzbl %al,%eax
  10c135:	0f b6 84 05 fc fe ff 	movzbl -0x104(%ebp,%eax,1),%eax
  10c13c:	ff 
  10c13d:	0f be c0             	movsbl %al,%eax
  10c140:	3b 45 10             	cmp    0x10(%ebp),%eax
  10c143:	0f 95 c0             	setne  %al
  10c146:	83 45 08 01          	addl   $0x1,0x8(%ebp)
  10c14a:	84 c0                	test   %al,%al
  10c14c:	75 da                	jne    10c128 <__strxspn+0x5a>
  10c14e:	8b 45 fc             	mov    -0x4(%ebp),%eax
  10c151:	c9                   	leave  
  10c152:	c3                   	ret    

0010c153 <strpbrk>:
  10c153:	55                   	push   %ebp
  10c154:	89 e5                	mov    %esp,%ebp
  10c156:	83 ec 20             	sub    $0x20,%esp
  10c159:	c7 44 24 08 01 00 00 	movl   $0x1,0x8(%esp)
  10c160:	00 
  10c161:	8b 45 0c             	mov    0xc(%ebp),%eax
  10c164:	89 44 24 04          	mov    %eax,0x4(%esp)
  10c168:	8b 45 08             	mov    0x8(%ebp),%eax
  10c16b:	89 04 24             	mov    %eax,(%esp)
  10c16e:	e8 5b ff ff ff       	call   10c0ce <__strxspn>
  10c173:	03 45 08             	add    0x8(%ebp),%eax
  10c176:	89 45 fc             	mov    %eax,-0x4(%ebp)
  10c179:	8b 45 fc             	mov    -0x4(%ebp),%eax
  10c17c:	0f b6 00             	movzbl (%eax),%eax
  10c17f:	84 c0                	test   %al,%al
  10c181:	74 08                	je     10c18b <strpbrk+0x38>
  10c183:	8b 45 fc             	mov    -0x4(%ebp),%eax
  10c186:	89 45 ec             	mov    %eax,-0x14(%ebp)
  10c189:	eb 07                	jmp    10c192 <strpbrk+0x3f>
  10c18b:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
  10c192:	8b 45 ec             	mov    -0x14(%ebp),%eax
  10c195:	c9                   	leave  
  10c196:	c3                   	ret    

0010c197 <strsep>:
  10c197:	55                   	push   %ebp
  10c198:	89 e5                	mov    %esp,%ebp
  10c19a:	83 ec 1c             	sub    $0x1c,%esp
  10c19d:	8b 45 08             	mov    0x8(%ebp),%eax
  10c1a0:	8b 00                	mov    (%eax),%eax
  10c1a2:	89 45 f8             	mov    %eax,-0x8(%ebp)
  10c1a5:	83 7d f8 00          	cmpl   $0x0,-0x8(%ebp)
  10c1a9:	75 09                	jne    10c1b4 <strsep+0x1d>
  10c1ab:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
  10c1b2:	eb 33                	jmp    10c1e7 <strsep+0x50>
  10c1b4:	8b 45 0c             	mov    0xc(%ebp),%eax
  10c1b7:	89 44 24 04          	mov    %eax,0x4(%esp)
  10c1bb:	8b 45 f8             	mov    -0x8(%ebp),%eax
  10c1be:	89 04 24             	mov    %eax,(%esp)
  10c1c1:	e8 8d ff ff ff       	call   10c153 <strpbrk>
  10c1c6:	89 45 fc             	mov    %eax,-0x4(%ebp)
  10c1c9:	83 7d fc 00          	cmpl   $0x0,-0x4(%ebp)
  10c1cd:	74 0a                	je     10c1d9 <strsep+0x42>
  10c1cf:	8b 45 fc             	mov    -0x4(%ebp),%eax
  10c1d2:	c6 00 00             	movb   $0x0,(%eax)
  10c1d5:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
  10c1d9:	8b 55 08             	mov    0x8(%ebp),%edx
  10c1dc:	8b 45 fc             	mov    -0x4(%ebp),%eax
  10c1df:	89 02                	mov    %eax,(%edx)
  10c1e1:	8b 45 f8             	mov    -0x8(%ebp),%eax
  10c1e4:	89 45 ec             	mov    %eax,-0x14(%ebp)
  10c1e7:	8b 45 ec             	mov    -0x14(%ebp),%eax
  10c1ea:	c9                   	leave  
  10c1eb:	c3                   	ret    

0010c1ec <strtok>:
  10c1ec:	55                   	push   %ebp
  10c1ed:	89 e5                	mov    %esp,%ebp
  10c1ef:	83 ec 08             	sub    $0x8,%esp
  10c1f2:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
  10c1f6:	74 08                	je     10c200 <strtok+0x14>
  10c1f8:	8b 45 08             	mov    0x8(%ebp),%eax
  10c1fb:	a3 64 f9 10 00       	mov    %eax,0x10f964
  10c200:	8b 45 0c             	mov    0xc(%ebp),%eax
  10c203:	89 44 24 04          	mov    %eax,0x4(%esp)
  10c207:	c7 04 24 64 f9 10 00 	movl   $0x10f964,(%esp)
  10c20e:	e8 84 ff ff ff       	call   10c197 <strsep>
  10c213:	89 45 08             	mov    %eax,0x8(%ebp)
  10c216:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
  10c21a:	74 0a                	je     10c226 <strtok+0x3a>
  10c21c:	8b 45 08             	mov    0x8(%ebp),%eax
  10c21f:	0f b6 00             	movzbl (%eax),%eax
  10c222:	84 c0                	test   %al,%al
  10c224:	74 da                	je     10c200 <strtok+0x14>
  10c226:	8b 45 08             	mov    0x8(%ebp),%eax
  10c229:	c9                   	leave  
  10c22a:	c3                   	ret    

0010c22b <strntoumax>:
  10c22b:	55                   	push   %ebp
  10c22c:	89 e5                	mov    %esp,%ebp
  10c22e:	53                   	push   %ebx
  10c22f:	83 ec 34             	sub    $0x34,%esp
  10c232:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
  10c239:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
  10c240:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
  10c247:	eb 08                	jmp    10c251 <strntoumax+0x26>
  10c249:	83 45 08 01          	addl   $0x1,0x8(%ebp)
  10c24d:	83 6d 14 01          	subl   $0x1,0x14(%ebp)
  10c251:	83 7d 14 00          	cmpl   $0x0,0x14(%ebp)
  10c255:	74 3c                	je     10c293 <strntoumax+0x68>
  10c257:	8b 45 08             	mov    0x8(%ebp),%eax
  10c25a:	0f b6 00             	movzbl (%eax),%eax
  10c25d:	3c 20                	cmp    $0x20,%al
  10c25f:	74 e8                	je     10c249 <strntoumax+0x1e>
  10c261:	8b 45 08             	mov    0x8(%ebp),%eax
  10c264:	0f b6 00             	movzbl (%eax),%eax
  10c267:	3c 0c                	cmp    $0xc,%al
  10c269:	74 de                	je     10c249 <strntoumax+0x1e>
  10c26b:	8b 45 08             	mov    0x8(%ebp),%eax
  10c26e:	0f b6 00             	movzbl (%eax),%eax
  10c271:	3c 0a                	cmp    $0xa,%al
  10c273:	74 d4                	je     10c249 <strntoumax+0x1e>
  10c275:	8b 45 08             	mov    0x8(%ebp),%eax
  10c278:	0f b6 00             	movzbl (%eax),%eax
  10c27b:	3c 0d                	cmp    $0xd,%al
  10c27d:	74 ca                	je     10c249 <strntoumax+0x1e>
  10c27f:	8b 45 08             	mov    0x8(%ebp),%eax
  10c282:	0f b6 00             	movzbl (%eax),%eax
  10c285:	3c 09                	cmp    $0x9,%al
  10c287:	74 c0                	je     10c249 <strntoumax+0x1e>
  10c289:	8b 45 08             	mov    0x8(%ebp),%eax
  10c28c:	0f b6 00             	movzbl (%eax),%eax
  10c28f:	3c 0b                	cmp    $0xb,%al
  10c291:	74 b6                	je     10c249 <strntoumax+0x1e>
  10c293:	83 7d 14 00          	cmpl   $0x0,0x14(%ebp)
  10c297:	74 2a                	je     10c2c3 <strntoumax+0x98>
  10c299:	8b 45 08             	mov    0x8(%ebp),%eax
  10c29c:	0f b6 00             	movzbl (%eax),%eax
  10c29f:	88 45 f7             	mov    %al,-0x9(%ebp)
  10c2a2:	80 7d f7 2d          	cmpb   $0x2d,-0x9(%ebp)
  10c2a6:	74 06                	je     10c2ae <strntoumax+0x83>
  10c2a8:	80 7d f7 2b          	cmpb   $0x2b,-0x9(%ebp)
  10c2ac:	75 15                	jne    10c2c3 <strntoumax+0x98>
  10c2ae:	80 7d f7 2d          	cmpb   $0x2d,-0x9(%ebp)
  10c2b2:	0f 94 c0             	sete   %al
  10c2b5:	0f b6 c0             	movzbl %al,%eax
  10c2b8:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  10c2bb:	83 45 08 01          	addl   $0x1,0x8(%ebp)
  10c2bf:	83 6d 14 01          	subl   $0x1,0x14(%ebp)
  10c2c3:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
  10c2c7:	75 68                	jne    10c331 <strntoumax+0x106>
  10c2c9:	83 7d 14 01          	cmpl   $0x1,0x14(%ebp)
  10c2cd:	76 38                	jbe    10c307 <strntoumax+0xdc>
  10c2cf:	8b 45 08             	mov    0x8(%ebp),%eax
  10c2d2:	0f b6 00             	movzbl (%eax),%eax
  10c2d5:	3c 30                	cmp    $0x30,%al
  10c2d7:	75 2e                	jne    10c307 <strntoumax+0xdc>
  10c2d9:	8b 45 08             	mov    0x8(%ebp),%eax
  10c2dc:	83 c0 01             	add    $0x1,%eax
  10c2df:	0f b6 00             	movzbl (%eax),%eax
  10c2e2:	3c 78                	cmp    $0x78,%al
  10c2e4:	74 0d                	je     10c2f3 <strntoumax+0xc8>
  10c2e6:	8b 45 08             	mov    0x8(%ebp),%eax
  10c2e9:	83 c0 01             	add    $0x1,%eax
  10c2ec:	0f b6 00             	movzbl (%eax),%eax
  10c2ef:	3c 58                	cmp    $0x58,%al
  10c2f1:	75 14                	jne    10c307 <strntoumax+0xdc>
  10c2f3:	83 6d 14 02          	subl   $0x2,0x14(%ebp)
  10c2f7:	83 45 08 02          	addl   $0x2,0x8(%ebp)
  10c2fb:	c7 45 10 10 00 00 00 	movl   $0x10,0x10(%ebp)
  10c302:	e9 9b 00 00 00       	jmp    10c3a2 <strntoumax+0x177>
  10c307:	83 7d 14 00          	cmpl   $0x0,0x14(%ebp)
  10c30b:	74 1b                	je     10c328 <strntoumax+0xfd>
  10c30d:	8b 45 08             	mov    0x8(%ebp),%eax
  10c310:	0f b6 00             	movzbl (%eax),%eax
  10c313:	3c 30                	cmp    $0x30,%al
  10c315:	75 11                	jne    10c328 <strntoumax+0xfd>
  10c317:	83 6d 14 01          	subl   $0x1,0x14(%ebp)
  10c31b:	83 45 08 01          	addl   $0x1,0x8(%ebp)
  10c31f:	c7 45 10 08 00 00 00 	movl   $0x8,0x10(%ebp)
  10c326:	eb 7a                	jmp    10c3a2 <strntoumax+0x177>
  10c328:	c7 45 10 0a 00 00 00 	movl   $0xa,0x10(%ebp)
  10c32f:	eb 71                	jmp    10c3a2 <strntoumax+0x177>
  10c331:	83 7d 10 10          	cmpl   $0x10,0x10(%ebp)
  10c335:	75 6b                	jne    10c3a2 <strntoumax+0x177>
  10c337:	83 7d 14 01          	cmpl   $0x1,0x14(%ebp)
  10c33b:	76 65                	jbe    10c3a2 <strntoumax+0x177>
  10c33d:	8b 45 08             	mov    0x8(%ebp),%eax
  10c340:	0f b6 00             	movzbl (%eax),%eax
  10c343:	3c 30                	cmp    $0x30,%al
  10c345:	75 5b                	jne    10c3a2 <strntoumax+0x177>
  10c347:	8b 45 08             	mov    0x8(%ebp),%eax
  10c34a:	83 c0 01             	add    $0x1,%eax
  10c34d:	0f b6 00             	movzbl (%eax),%eax
  10c350:	3c 78                	cmp    $0x78,%al
  10c352:	74 0d                	je     10c361 <strntoumax+0x136>
  10c354:	8b 45 08             	mov    0x8(%ebp),%eax
  10c357:	83 c0 01             	add    $0x1,%eax
  10c35a:	0f b6 00             	movzbl (%eax),%eax
  10c35d:	3c 58                	cmp    $0x58,%al
  10c35f:	75 41                	jne    10c3a2 <strntoumax+0x177>
  10c361:	83 6d 14 02          	subl   $0x2,0x14(%ebp)
  10c365:	83 45 08 02          	addl   $0x2,0x8(%ebp)
  10c369:	eb 37                	jmp    10c3a2 <strntoumax+0x177>
  10c36b:	8b 45 10             	mov    0x10(%ebp),%eax
  10c36e:	89 c2                	mov    %eax,%edx
  10c370:	c1 fa 1f             	sar    $0x1f,%edx
  10c373:	8b 4d e8             	mov    -0x18(%ebp),%ecx
  10c376:	0f af ca             	imul   %edx,%ecx
  10c379:	8b 5d ec             	mov    -0x14(%ebp),%ebx
  10c37c:	0f af d8             	imul   %eax,%ebx
  10c37f:	01 d9                	add    %ebx,%ecx
  10c381:	f7 65 e8             	mull   -0x18(%ebp)
  10c384:	01 d1                	add    %edx,%ecx
  10c386:	89 ca                	mov    %ecx,%edx
  10c388:	8b 4d f0             	mov    -0x10(%ebp),%ecx
  10c38b:	89 cb                	mov    %ecx,%ebx
  10c38d:	c1 fb 1f             	sar    $0x1f,%ebx
  10c390:	01 c8                	add    %ecx,%eax
  10c392:	11 da                	adc    %ebx,%edx
  10c394:	89 45 e8             	mov    %eax,-0x18(%ebp)
  10c397:	89 55 ec             	mov    %edx,-0x14(%ebp)
  10c39a:	83 6d 14 01          	subl   $0x1,0x14(%ebp)
  10c39e:	83 45 08 01          	addl   $0x1,0x8(%ebp)
  10c3a2:	83 7d 14 00          	cmpl   $0x0,0x14(%ebp)
  10c3a6:	74 22                	je     10c3ca <strntoumax+0x19f>
  10c3a8:	8b 45 08             	mov    0x8(%ebp),%eax
  10c3ab:	0f b6 00             	movzbl (%eax),%eax
  10c3ae:	0f be c0             	movsbl %al,%eax
  10c3b1:	89 04 24             	mov    %eax,(%esp)
  10c3b4:	e8 56 00 00 00       	call   10c40f <digitval>
  10c3b9:	89 45 f0             	mov    %eax,-0x10(%ebp)
  10c3bc:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
  10c3c0:	78 08                	js     10c3ca <strntoumax+0x19f>
  10c3c2:	8b 45 f0             	mov    -0x10(%ebp),%eax
  10c3c5:	3b 45 10             	cmp    0x10(%ebp),%eax
  10c3c8:	7c a1                	jl     10c36b <strntoumax+0x140>
  10c3ca:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
  10c3ce:	74 08                	je     10c3d8 <strntoumax+0x1ad>
  10c3d0:	8b 55 08             	mov    0x8(%ebp),%edx
  10c3d3:	8b 45 0c             	mov    0xc(%ebp),%eax
  10c3d6:	89 10                	mov    %edx,(%eax)
  10c3d8:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
  10c3dc:	74 19                	je     10c3f7 <strntoumax+0x1cc>
  10c3de:	8b 45 e8             	mov    -0x18(%ebp),%eax
  10c3e1:	8b 55 ec             	mov    -0x14(%ebp),%edx
  10c3e4:	89 c1                	mov    %eax,%ecx
  10c3e6:	89 d3                	mov    %edx,%ebx
  10c3e8:	f7 d9                	neg    %ecx
  10c3ea:	83 d3 00             	adc    $0x0,%ebx
  10c3ed:	f7 db                	neg    %ebx
  10c3ef:	89 4d d0             	mov    %ecx,-0x30(%ebp)
  10c3f2:	89 5d d4             	mov    %ebx,-0x2c(%ebp)
  10c3f5:	eb 0c                	jmp    10c403 <strntoumax+0x1d8>
  10c3f7:	8b 45 e8             	mov    -0x18(%ebp),%eax
  10c3fa:	8b 55 ec             	mov    -0x14(%ebp),%edx
  10c3fd:	89 45 d0             	mov    %eax,-0x30(%ebp)
  10c400:	89 55 d4             	mov    %edx,-0x2c(%ebp)
  10c403:	8b 45 d0             	mov    -0x30(%ebp),%eax
  10c406:	8b 55 d4             	mov    -0x2c(%ebp),%edx
  10c409:	83 c4 34             	add    $0x34,%esp
  10c40c:	5b                   	pop    %ebx
  10c40d:	5d                   	pop    %ebp
  10c40e:	c3                   	ret    

0010c40f <digitval>:
  10c40f:	55                   	push   %ebp
  10c410:	89 e5                	mov    %esp,%ebp
  10c412:	83 ec 04             	sub    $0x4,%esp
  10c415:	83 7d 08 2f          	cmpl   $0x2f,0x8(%ebp)
  10c419:	7e 11                	jle    10c42c <digitval+0x1d>
  10c41b:	83 7d 08 39          	cmpl   $0x39,0x8(%ebp)
  10c41f:	7f 0b                	jg     10c42c <digitval+0x1d>
  10c421:	8b 45 08             	mov    0x8(%ebp),%eax
  10c424:	83 e8 30             	sub    $0x30,%eax
  10c427:	89 45 fc             	mov    %eax,-0x4(%ebp)
  10c42a:	eb 35                	jmp    10c461 <digitval+0x52>
  10c42c:	83 7d 08 40          	cmpl   $0x40,0x8(%ebp)
  10c430:	7e 11                	jle    10c443 <digitval+0x34>
  10c432:	83 7d 08 5a          	cmpl   $0x5a,0x8(%ebp)
  10c436:	7f 0b                	jg     10c443 <digitval+0x34>
  10c438:	8b 45 08             	mov    0x8(%ebp),%eax
  10c43b:	83 e8 37             	sub    $0x37,%eax
  10c43e:	89 45 fc             	mov    %eax,-0x4(%ebp)
  10c441:	eb 1e                	jmp    10c461 <digitval+0x52>
  10c443:	83 7d 08 60          	cmpl   $0x60,0x8(%ebp)
  10c447:	7e 11                	jle    10c45a <digitval+0x4b>
  10c449:	83 7d 08 7a          	cmpl   $0x7a,0x8(%ebp)
  10c44d:	7f 0b                	jg     10c45a <digitval+0x4b>
  10c44f:	8b 45 08             	mov    0x8(%ebp),%eax
  10c452:	83 e8 57             	sub    $0x57,%eax
  10c455:	89 45 fc             	mov    %eax,-0x4(%ebp)
  10c458:	eb 07                	jmp    10c461 <digitval+0x52>
  10c45a:	c7 45 fc ff ff ff ff 	movl   $0xffffffff,-0x4(%ebp)
  10c461:	8b 45 fc             	mov    -0x4(%ebp),%eax
  10c464:	c9                   	leave  
  10c465:	c3                   	ret    

0010c466 <strrchr>:
  10c466:	55                   	push   %ebp
  10c467:	89 e5                	mov    %esp,%ebp
  10c469:	83 ec 10             	sub    $0x10,%esp
  10c46c:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
  10c473:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
  10c47a:	eb 20                	jmp    10c49c <strrchr+0x36>
  10c47c:	8b 55 fc             	mov    -0x4(%ebp),%edx
  10c47f:	8b 45 08             	mov    0x8(%ebp),%eax
  10c482:	01 d0                	add    %edx,%eax
  10c484:	0f b6 00             	movzbl (%eax),%eax
  10c487:	0f be c0             	movsbl %al,%eax
  10c48a:	3b 45 0c             	cmp    0xc(%ebp),%eax
  10c48d:	75 09                	jne    10c498 <strrchr+0x32>
  10c48f:	8b 45 08             	mov    0x8(%ebp),%eax
  10c492:	03 45 fc             	add    -0x4(%ebp),%eax
  10c495:	89 45 f8             	mov    %eax,-0x8(%ebp)
  10c498:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
  10c49c:	8b 55 fc             	mov    -0x4(%ebp),%edx
  10c49f:	8b 45 08             	mov    0x8(%ebp),%eax
  10c4a2:	01 d0                	add    %edx,%eax
  10c4a4:	0f b6 00             	movzbl (%eax),%eax
  10c4a7:	84 c0                	test   %al,%al
  10c4a9:	75 d1                	jne    10c47c <strrchr+0x16>
  10c4ab:	8b 45 f8             	mov    -0x8(%ebp),%eax
  10c4ae:	c9                   	leave  
  10c4af:	c3                   	ret    

0010c4b0 <strxspn>:
  10c4b0:	55                   	push   %ebp
  10c4b1:	89 e5                	mov    %esp,%ebp
  10c4b3:	81 ec 1c 01 00 00    	sub    $0x11c,%esp
  10c4b9:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
  10c4c0:	c7 44 24 08 00 01 00 	movl   $0x100,0x8(%esp)
  10c4c7:	00 
  10c4c8:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  10c4cf:	00 
  10c4d0:	8d 85 fc fe ff ff    	lea    -0x104(%ebp),%eax
  10c4d6:	89 04 24             	mov    %eax,(%esp)
  10c4d9:	e8 83 f8 ff ff       	call   10bd61 <memset>
  10c4de:	eb 15                	jmp    10c4f5 <strxspn+0x45>
  10c4e0:	8b 45 0c             	mov    0xc(%ebp),%eax
  10c4e3:	0f b6 00             	movzbl (%eax),%eax
  10c4e6:	0f b6 c0             	movzbl %al,%eax
  10c4e9:	c6 84 05 fc fe ff ff 	movb   $0x1,-0x104(%ebp,%eax,1)
  10c4f0:	01 
  10c4f1:	83 45 0c 01          	addl   $0x1,0xc(%ebp)
  10c4f5:	8b 45 0c             	mov    0xc(%ebp),%eax
  10c4f8:	0f b6 00             	movzbl (%eax),%eax
  10c4fb:	84 c0                	test   %al,%al
  10c4fd:	75 e1                	jne    10c4e0 <strxspn+0x30>
  10c4ff:	8b 45 10             	mov    0x10(%ebp),%eax
  10c502:	88 85 fc fe ff ff    	mov    %al,-0x104(%ebp)
  10c508:	eb 04                	jmp    10c50e <strxspn+0x5e>
  10c50a:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
  10c50e:	8b 45 08             	mov    0x8(%ebp),%eax
  10c511:	0f b6 00             	movzbl (%eax),%eax
  10c514:	0f b6 c0             	movzbl %al,%eax
  10c517:	0f b6 84 05 fc fe ff 	movzbl -0x104(%ebp,%eax,1),%eax
  10c51e:	ff 
  10c51f:	0f be c0             	movsbl %al,%eax
  10c522:	3b 45 10             	cmp    0x10(%ebp),%eax
  10c525:	0f 95 c0             	setne  %al
  10c528:	83 45 08 01          	addl   $0x1,0x8(%ebp)
  10c52c:	84 c0                	test   %al,%al
  10c52e:	75 da                	jne    10c50a <strxspn+0x5a>
  10c530:	8b 45 fc             	mov    -0x4(%ebp),%eax
  10c533:	c9                   	leave  
  10c534:	c3                   	ret    

0010c535 <strspn>:
  10c535:	55                   	push   %ebp
  10c536:	89 e5                	mov    %esp,%ebp
  10c538:	83 ec 0c             	sub    $0xc,%esp
  10c53b:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  10c542:	00 
  10c543:	8b 45 0c             	mov    0xc(%ebp),%eax
  10c546:	89 44 24 04          	mov    %eax,0x4(%esp)
  10c54a:	8b 45 08             	mov    0x8(%ebp),%eax
  10c54d:	89 04 24             	mov    %eax,(%esp)
  10c550:	e8 5b ff ff ff       	call   10c4b0 <strxspn>
  10c555:	c9                   	leave  
  10c556:	c3                   	ret    

0010c557 <strcspn>:
  10c557:	55                   	push   %ebp
  10c558:	89 e5                	mov    %esp,%ebp
  10c55a:	83 ec 0c             	sub    $0xc,%esp
  10c55d:	c7 44 24 08 01 00 00 	movl   $0x1,0x8(%esp)
  10c564:	00 
  10c565:	8b 45 0c             	mov    0xc(%ebp),%eax
  10c568:	89 44 24 04          	mov    %eax,0x4(%esp)
  10c56c:	8b 45 08             	mov    0x8(%ebp),%eax
  10c56f:	89 04 24             	mov    %eax,(%esp)
  10c572:	e8 39 ff ff ff       	call   10c4b0 <strxspn>
  10c577:	c9                   	leave  
  10c578:	c3                   	ret    
